
C:\Users\IMRUL\AppData\Local\Temp\VMBuilds\event_group_3_tasks\uno\Debug/event_group_3_tasks.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
       0:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__ctors_end>
       4:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
       8:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
       c:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
      10:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
      14:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
      18:	0c 94 cf 16 	jmp	0x2d9e	; 0x2d9e <__vector_6>
      1c:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
      20:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
      24:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
      28:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
      2c:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
      30:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
      34:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
      38:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
      3c:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
      40:	0c 94 d3 09 	jmp	0x13a6	; 0x13a6 <__vector_16>
      44:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
      48:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <__vector_18>
      4c:	0c 94 7b 09 	jmp	0x12f6	; 0x12f6 <__vector_19>
      50:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
      54:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
      58:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
      5c:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
      60:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
      64:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>

00000068 <__trampolines_end>:
__trampolines_start():
      68:	00 00       	nop
      6a:	00 00       	nop
      6c:	23 00       	.word	0x0023	; ????
      6e:	26 00       	.word	0x0026	; ????
      70:	29 00       	.word	0x0029	; ????

00000072 <digital_pin_to_timer_PGM>:
      72:	00 00 00 08 00 02 01 00 00 03 04 07 00 00 00 00     ................
      82:	00 00 00 00                                         ....

00000086 <port_to_output_PGM>:
      86:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

00000090 <port_to_mode_PGM>:
      90:	00 00 00 00 24 00 27 00 2a 00                       ....$.'.*.

0000009a <digital_pin_to_port_PGM>:
      9a:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
      aa:	03 03 03 03                                         ....

000000ae <digital_pin_to_bit_mask_PGM>:
      ae:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
      be:	04 08 10 20                                         ... 

000000c2 <__ctors_start>:
__ctors_start():
      c2:	d2 16       	cp	r13, r18

000000c4 <__ctors_end>:
__dtors_end():
      c4:	11 24       	eor	r1, r1
      c6:	1f be       	out	0x3f, r1	; 63
      c8:	cf ef       	ldi	r28, 0xFF	; 255
      ca:	d8 e0       	ldi	r29, 0x08	; 8
      cc:	de bf       	out	0x3e, r29	; 62
      ce:	cd bf       	out	0x3d, r28	; 61

000000d0 <__do_copy_data>:
__do_copy_data():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
      d0:	11 e0       	ldi	r17, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
      d2:	a0 e0       	ldi	r26, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
      d4:	b1 e0       	ldi	r27, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
      d6:	ea e6       	ldi	r30, 0x6A	; 106
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
      d8:	f3 e3       	ldi	r31, 0x33	; 51
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
      da:	02 c0       	rjmp	.+4      	; 0xe0 <__do_copy_data+0x10>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
      dc:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
      de:	0d 92       	st	X+, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
      e0:	ae 39       	cpi	r26, 0x9E	; 158
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
      e2:	b1 07       	cpc	r27, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
      e4:	d9 f7       	brne	.-10     	; 0xdc <__do_copy_data+0xc>

000000e6 <__do_clear_bss>:
__do_clear_bss():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
      e6:	23 e0       	ldi	r18, 0x03	; 3
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
      e8:	ae e9       	ldi	r26, 0x9E	; 158
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
      ea:	b1 e0       	ldi	r27, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
      ec:	01 c0       	rjmp	.+2      	; 0xf0 <.do_clear_bss_start>

000000ee <.do_clear_bss_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
      ee:	1d 92       	st	X+, r1

000000f0 <.do_clear_bss_start>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
      f0:	ad 31       	cpi	r26, 0x1D	; 29
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
      f2:	b2 07       	cpc	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
      f4:	e1 f7       	brne	.-8      	; 0xee <.do_clear_bss_loop>

000000f6 <__do_global_ctors>:
__do_global_ctors():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
      f6:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
      f8:	c2 e6       	ldi	r28, 0x62	; 98
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
      fa:	d0 e0       	ldi	r29, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
      fc:	04 c0       	rjmp	.+8      	; 0x106 <__do_global_ctors+0x10>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
      fe:	21 97       	sbiw	r28, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
     100:	fe 01       	movw	r30, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
     102:	0e 94 9d 19 	call	0x333a	; 0x333a <__tablejump2__>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
     106:	c1 36       	cpi	r28, 0x61	; 97
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
     108:	d1 07       	cpc	r29, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
     10a:	c9 f7       	brne	.-14     	; 0xfe <__do_global_ctors+0x8>
     10c:	0e 94 11 17 	call	0x2e22	; 0x2e22 <main>
     110:	0c 94 b3 19 	jmp	0x3366	; 0x3366 <_exit>

00000114 <__bad_interrupt>:
__vector_22():
     114:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000118 <HardwareSerial::begin(unsigned long, unsigned char) [clone .constprop.29]>:
_ZN14HardwareSerial5beginEmh.constprop.29():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:121

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
     118:	e6 e3       	ldi	r30, 0x36	; 54
     11a:	f2 e0       	ldi	r31, 0x02	; 2
     11c:	a0 89       	ldd	r26, Z+16	; 0x10
     11e:	b1 89       	ldd	r27, Z+17	; 0x11
     120:	82 e0       	ldi	r24, 0x02	; 2
     122:	8c 93       	st	X, r24
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:135
    *_ucsra = 0;
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
     124:	a4 85       	ldd	r26, Z+12	; 0x0c
     126:	b5 85       	ldd	r27, Z+13	; 0x0d
     128:	1c 92       	st	X, r1
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:136
  *_ubrrl = baud_setting;
     12a:	a6 85       	ldd	r26, Z+14	; 0x0e
     12c:	b7 85       	ldd	r27, Z+15	; 0x0f
     12e:	8f ec       	ldi	r24, 0xCF	; 207
     130:	8c 93       	st	X, r24
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:138

  _written = false;
     132:	10 8e       	std	Z+24, r1	; 0x18
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:144

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
     134:	a4 89       	ldd	r26, Z+20	; 0x14
     136:	b5 89       	ldd	r27, Z+21	; 0x15
     138:	86 e0       	ldi	r24, 0x06	; 6
     13a:	8c 93       	st	X, r24
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:146
  
  sbi(*_ucsrb, RXEN0);
     13c:	a2 89       	ldd	r26, Z+18	; 0x12
     13e:	b3 89       	ldd	r27, Z+19	; 0x13
     140:	8c 91       	ld	r24, X
     142:	80 61       	ori	r24, 0x10	; 16
     144:	8c 93       	st	X, r24
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:147
  sbi(*_ucsrb, TXEN0);
     146:	a2 89       	ldd	r26, Z+18	; 0x12
     148:	b3 89       	ldd	r27, Z+19	; 0x13
     14a:	8c 91       	ld	r24, X
     14c:	88 60       	ori	r24, 0x08	; 8
     14e:	8c 93       	st	X, r24
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:148
  sbi(*_ucsrb, RXCIE0);
     150:	a2 89       	ldd	r26, Z+18	; 0x12
     152:	b3 89       	ldd	r27, Z+19	; 0x13
     154:	8c 91       	ld	r24, X
     156:	80 68       	ori	r24, 0x80	; 128
     158:	8c 93       	st	X, r24
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:149
  cbi(*_ucsrb, UDRIE0);
     15a:	02 88       	ldd	r0, Z+18	; 0x12
     15c:	f3 89       	ldd	r31, Z+19	; 0x13
     15e:	e0 2d       	mov	r30, r0
     160:	80 81       	ld	r24, Z
     162:	8f 7d       	andi	r24, 0xDF	; 223
     164:	80 83       	st	Z, r24
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:150
}
     166:	08 95       	ret

00000168 <pinMode.constprop.24>:
pinMode.constprop.24():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:31
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
     168:	90 e0       	ldi	r25, 0x00	; 0
     16a:	fc 01       	movw	r30, r24
     16c:	e2 55       	subi	r30, 0x52	; 82
     16e:	ff 4f       	sbci	r31, 0xFF	; 255
     170:	24 91       	lpm	r18, Z
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:32
	uint8_t port = digitalPinToPort(pin);
     172:	86 56       	subi	r24, 0x66	; 102
     174:	9f 4f       	sbci	r25, 0xFF	; 255
     176:	fc 01       	movw	r30, r24
     178:	84 91       	lpm	r24, Z
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:35
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
     17a:	88 23       	and	r24, r24
     17c:	99 f0       	breq	.+38     	; 0x1a4 <pinMode.constprop.24+0x3c>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:38

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
     17e:	90 e0       	ldi	r25, 0x00	; 0
     180:	88 0f       	add	r24, r24
     182:	99 1f       	adc	r25, r25
     184:	fc 01       	movw	r30, r24
     186:	e0 57       	subi	r30, 0x70	; 112
     188:	ff 4f       	sbci	r31, 0xFF	; 255
     18a:	a5 91       	lpm	r26, Z+
     18c:	b4 91       	lpm	r27, Z
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:39
	out = portOutputRegister(port);
     18e:	fc 01       	movw	r30, r24
     190:	ea 57       	subi	r30, 0x7A	; 122
     192:	ff 4f       	sbci	r31, 0xFF	; 255
     194:	85 91       	lpm	r24, Z+
     196:	94 91       	lpm	r25, Z
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:54
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
     198:	8f b7       	in	r24, 0x3f	; 63
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:55
                cli();
     19a:	f8 94       	cli
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:56
		*reg |= bit;
     19c:	ec 91       	ld	r30, X
     19e:	e2 2b       	or	r30, r18
     1a0:	ec 93       	st	X, r30
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:57
		SREG = oldSREG;
     1a2:	8f bf       	out	0x3f, r24	; 63
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:59
	}
}
     1a4:	08 95       	ret

000001a6 <Print::write(unsigned char const*, unsigned int)>:
_ZN5Print5writeEPKhj():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:35

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
     1a6:	af 92       	push	r10
     1a8:	bf 92       	push	r11
     1aa:	cf 92       	push	r12
     1ac:	df 92       	push	r13
     1ae:	ef 92       	push	r14
     1b0:	ff 92       	push	r15
     1b2:	0f 93       	push	r16
     1b4:	1f 93       	push	r17
     1b6:	cf 93       	push	r28
     1b8:	df 93       	push	r29
     1ba:	6c 01       	movw	r12, r24
     1bc:	7b 01       	movw	r14, r22
     1be:	8b 01       	movw	r16, r22
     1c0:	04 0f       	add	r16, r20
     1c2:	15 1f       	adc	r17, r21
     1c4:	eb 01       	movw	r28, r22
     1c6:	5e 01       	movw	r10, r28
     1c8:	ae 18       	sub	r10, r14
     1ca:	bf 08       	sbc	r11, r15
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:37
  size_t n = 0;
  while (size--) {
     1cc:	c0 17       	cp	r28, r16
     1ce:	d1 07       	cpc	r29, r17
     1d0:	59 f0       	breq	.+22     	; 0x1e8 <Print::write(unsigned char const*, unsigned int)+0x42>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:38
    if (write(*buffer++)) n++;
     1d2:	69 91       	ld	r22, Y+
     1d4:	d6 01       	movw	r26, r12
     1d6:	ed 91       	ld	r30, X+
     1d8:	fc 91       	ld	r31, X
     1da:	01 90       	ld	r0, Z+
     1dc:	f0 81       	ld	r31, Z
     1de:	e0 2d       	mov	r30, r0
     1e0:	c6 01       	movw	r24, r12
     1e2:	09 95       	icall
     1e4:	89 2b       	or	r24, r25
     1e6:	79 f7       	brne	.-34     	; 0x1c6 <Print::write(unsigned char const*, unsigned int)+0x20>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:42
    else break;
  }
  return n;
}
     1e8:	c5 01       	movw	r24, r10
     1ea:	df 91       	pop	r29
     1ec:	cf 91       	pop	r28
     1ee:	1f 91       	pop	r17
     1f0:	0f 91       	pop	r16
     1f2:	ff 90       	pop	r15
     1f4:	ef 90       	pop	r14
     1f6:	df 90       	pop	r13
     1f8:	cf 90       	pop	r12
     1fa:	bf 90       	pop	r11
     1fc:	af 90       	pop	r10
     1fe:	08 95       	ret

00000200 <HardwareSerial::availableForWrite()>:
_ZN14HardwareSerial17availableForWriteEv():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:198
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
     200:	fc 01       	movw	r30, r24
     202:	53 8d       	ldd	r21, Z+27	; 0x1b
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:199
    tail = _tx_buffer_tail;
     204:	44 8d       	ldd	r20, Z+28	; 0x1c
     206:	25 2f       	mov	r18, r21
     208:	30 e0       	ldi	r19, 0x00	; 0
     20a:	84 2f       	mov	r24, r20
     20c:	90 e0       	ldi	r25, 0x00	; 0
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:201
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     20e:	82 1b       	sub	r24, r18
     210:	93 0b       	sbc	r25, r19
     212:	54 17       	cp	r21, r20
     214:	10 f0       	brcs	.+4      	; 0x21a <HardwareSerial::availableForWrite()+0x1a>
     216:	cf 96       	adiw	r24, 0x3f	; 63
     218:	08 95       	ret
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:202
  return tail - head - 1;
     21a:	01 97       	sbiw	r24, 0x01	; 1
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:203
}
     21c:	08 95       	ret

0000021e <HardwareSerial::read()>:
_ZN14HardwareSerial4readEv():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:181
    return _rx_buffer[_rx_buffer_tail];
  }
}

int HardwareSerial::read(void)
{
     21e:	fc 01       	movw	r30, r24
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:183
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
     220:	91 8d       	ldd	r25, Z+25	; 0x19
     222:	82 8d       	ldd	r24, Z+26	; 0x1a
     224:	98 17       	cp	r25, r24
     226:	61 f0       	breq	.+24     	; 0x240 <HardwareSerial::read()+0x22>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:186
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
     228:	a2 8d       	ldd	r26, Z+26	; 0x1a
     22a:	ae 0f       	add	r26, r30
     22c:	bf 2f       	mov	r27, r31
     22e:	b1 1d       	adc	r27, r1
     230:	5d 96       	adiw	r26, 0x1d	; 29
     232:	8c 91       	ld	r24, X
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:187
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
     234:	92 8d       	ldd	r25, Z+26	; 0x1a
     236:	9f 5f       	subi	r25, 0xFF	; 255
     238:	9f 73       	andi	r25, 0x3F	; 63
     23a:	92 8f       	std	Z+26, r25	; 0x1a
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:188
    return c;
     23c:	90 e0       	ldi	r25, 0x00	; 0
     23e:	08 95       	ret
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:184

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     240:	8f ef       	ldi	r24, 0xFF	; 255
     242:	9f ef       	ldi	r25, 0xFF	; 255
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:190
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
     244:	08 95       	ret

00000246 <HardwareSerial::peek()>:
_ZN14HardwareSerial4peekEv():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:172
{
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
}

int HardwareSerial::peek(void)
{
     246:	fc 01       	movw	r30, r24
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:173
  if (_rx_buffer_head == _rx_buffer_tail) {
     248:	91 8d       	ldd	r25, Z+25	; 0x19
     24a:	82 8d       	ldd	r24, Z+26	; 0x1a
     24c:	98 17       	cp	r25, r24
     24e:	31 f0       	breq	.+12     	; 0x25c <HardwareSerial::peek()+0x16>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:176
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
     250:	82 8d       	ldd	r24, Z+26	; 0x1a
     252:	e8 0f       	add	r30, r24
     254:	f1 1d       	adc	r31, r1
     256:	85 8d       	ldd	r24, Z+29	; 0x1d
     258:	90 e0       	ldi	r25, 0x00	; 0
     25a:	08 95       	ret
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:174
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     25c:	8f ef       	ldi	r24, 0xFF	; 255
     25e:	9f ef       	ldi	r25, 0xFF	; 255
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:178
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
     260:	08 95       	ret

00000262 <HardwareSerial::available()>:
_ZN14HardwareSerial9availableEv():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:167
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
     262:	fc 01       	movw	r30, r24
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:168
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
     264:	91 8d       	ldd	r25, Z+25	; 0x19
     266:	22 8d       	ldd	r18, Z+26	; 0x1a
     268:	89 2f       	mov	r24, r25
     26a:	90 e0       	ldi	r25, 0x00	; 0
     26c:	80 5c       	subi	r24, 0xC0	; 192
     26e:	9f 4f       	sbci	r25, 0xFF	; 255
     270:	82 1b       	sub	r24, r18
     272:	91 09       	sbc	r25, r1
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:169
}
     274:	8f 73       	andi	r24, 0x3F	; 63
     276:	99 27       	eor	r25, r25
     278:	08 95       	ret

0000027a <Serial0_available()>:
_Z17Serial0_availablev():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial0.cpp:76
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
     27a:	86 e3       	ldi	r24, 0x36	; 54
     27c:	92 e0       	ldi	r25, 0x02	; 2
     27e:	0e 94 31 01 	call	0x262	; 0x262 <HardwareSerial::available()>
     282:	21 e0       	ldi	r18, 0x01	; 1
     284:	89 2b       	or	r24, r25
     286:	09 f4       	brne	.+2      	; 0x28a <Serial0_available()+0x10>
     288:	20 e0       	ldi	r18, 0x00	; 0
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial0.cpp:77
}
     28a:	82 2f       	mov	r24, r18
     28c:	08 95       	ret

0000028e <serialEventRun() [clone .part.1]>:
_Z14serialEventRunv.part.1():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:67
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
     28e:	0e 94 3d 01 	call	0x27a	; 0x27a <Serial0_available()>
     292:	81 11       	cpse	r24, r1
     294:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:78
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
#endif
}
     298:	08 95       	ret

0000029a <serialEventRun()>:
_Z14serialEventRunv():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:67
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
     29a:	80 e0       	ldi	r24, 0x00	; 0
     29c:	90 e0       	ldi	r25, 0x00	; 0
     29e:	89 2b       	or	r24, r25
     2a0:	11 f0       	breq	.+4      	; 0x2a6 <serialEventRun()+0xc>
     2a2:	0c 94 47 01 	jmp	0x28e	; 0x28e <serialEventRun() [clone .part.1]>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:78
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
#endif
}
     2a6:	08 95       	ret

000002a8 <HardwareSerial::_tx_udr_empty_irq()>:
_ZN14HardwareSerial17_tx_udr_empty_irqEv():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:90
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
     2a8:	fc 01       	movw	r30, r24
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:93
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
     2aa:	a4 8d       	ldd	r26, Z+28	; 0x1c
     2ac:	a8 0f       	add	r26, r24
     2ae:	b9 2f       	mov	r27, r25
     2b0:	b1 1d       	adc	r27, r1
     2b2:	a3 5a       	subi	r26, 0xA3	; 163
     2b4:	bf 4f       	sbci	r27, 0xFF	; 255
     2b6:	2c 91       	ld	r18, X
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:94
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
     2b8:	84 8d       	ldd	r24, Z+28	; 0x1c
     2ba:	90 e0       	ldi	r25, 0x00	; 0
     2bc:	01 96       	adiw	r24, 0x01	; 1
     2be:	8f 73       	andi	r24, 0x3F	; 63
     2c0:	99 27       	eor	r25, r25
     2c2:	84 8f       	std	Z+28, r24	; 0x1c
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:96

  *_udr = c;
     2c4:	a6 89       	ldd	r26, Z+22	; 0x16
     2c6:	b7 89       	ldd	r27, Z+23	; 0x17
     2c8:	2c 93       	st	X, r18
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:104
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
     2ca:	a0 89       	ldd	r26, Z+16	; 0x10
     2cc:	b1 89       	ldd	r27, Z+17	; 0x11
     2ce:	8c 91       	ld	r24, X
     2d0:	83 70       	andi	r24, 0x03	; 3
     2d2:	80 64       	ori	r24, 0x40	; 64
     2d4:	8c 93       	st	X, r24
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:109
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
     2d6:	93 8d       	ldd	r25, Z+27	; 0x1b
     2d8:	84 8d       	ldd	r24, Z+28	; 0x1c
     2da:	98 13       	cpse	r25, r24
     2dc:	06 c0       	rjmp	.+12     	; 0x2ea <HardwareSerial::_tx_udr_empty_irq()+0x42>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:111
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
     2de:	02 88       	ldd	r0, Z+18	; 0x12
     2e0:	f3 89       	ldd	r31, Z+19	; 0x13
     2e2:	e0 2d       	mov	r30, r0
     2e4:	80 81       	ld	r24, Z
     2e6:	8f 7d       	andi	r24, 0xDF	; 223
     2e8:	80 83       	st	Z, r24
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:113
  }
}
     2ea:	08 95       	ret

000002ec <HardwareSerial::write(unsigned char)>:
_ZN14HardwareSerial5writeEh():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:226
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
     2ec:	ef 92       	push	r14
     2ee:	ff 92       	push	r15
     2f0:	0f 93       	push	r16
     2f2:	1f 93       	push	r17
     2f4:	cf 93       	push	r28
     2f6:	df 93       	push	r29
     2f8:	ec 01       	movw	r28, r24
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:227
  _written = true;
     2fa:	81 e0       	ldi	r24, 0x01	; 1
     2fc:	88 8f       	std	Y+24, r24	; 0x18
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:232
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
     2fe:	9b 8d       	ldd	r25, Y+27	; 0x1b
     300:	8c 8d       	ldd	r24, Y+28	; 0x1c
     302:	98 13       	cpse	r25, r24
     304:	1a c0       	rjmp	.+52     	; 0x33a <HardwareSerial::write(unsigned char)+0x4e>
     306:	e8 89       	ldd	r30, Y+16	; 0x10
     308:	f9 89       	ldd	r31, Y+17	; 0x11
     30a:	80 81       	ld	r24, Z
     30c:	85 ff       	sbrs	r24, 5
     30e:	15 c0       	rjmp	.+42     	; 0x33a <HardwareSerial::write(unsigned char)+0x4e>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:241
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     310:	9f b7       	in	r25, 0x3f	; 63
__iCliRetVal():
c:\program files (x86)\arduino\hardware\tools\avr\avr\include\util/atomic.h:50
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     312:	f8 94       	cli
_ZN14HardwareSerial5writeEh():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:242
      *_udr = c;
     314:	ee 89       	ldd	r30, Y+22	; 0x16
     316:	ff 89       	ldd	r31, Y+23	; 0x17
     318:	60 83       	st	Z, r22
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:244
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
     31a:	e8 89       	ldd	r30, Y+16	; 0x10
     31c:	f9 89       	ldd	r31, Y+17	; 0x11
     31e:	80 81       	ld	r24, Z
     320:	83 70       	andi	r24, 0x03	; 3
     322:	80 64       	ori	r24, 0x40	; 64
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:275
  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
     324:	80 83       	st	Z, r24
__iRestore():
c:\program files (x86)\arduino\hardware\tools\avr\avr\include\util/atomic.h:70
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     326:	9f bf       	out	0x3f, r25	; 63
_ZN14HardwareSerial5writeEh():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:279
  }
  
  return 1;
}
     328:	81 e0       	ldi	r24, 0x01	; 1
     32a:	90 e0       	ldi	r25, 0x00	; 0
     32c:	df 91       	pop	r29
     32e:	cf 91       	pop	r28
     330:	1f 91       	pop	r17
     332:	0f 91       	pop	r16
     334:	ff 90       	pop	r15
     336:	ef 90       	pop	r14
     338:	08 95       	ret
     33a:	f6 2e       	mov	r15, r22
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:251
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
     33c:	0b 8d       	ldd	r16, Y+27	; 0x1b
     33e:	10 e0       	ldi	r17, 0x00	; 0
     340:	0f 5f       	subi	r16, 0xFF	; 255
     342:	1f 4f       	sbci	r17, 0xFF	; 255
     344:	0f 73       	andi	r16, 0x3F	; 63
     346:	11 27       	eor	r17, r17
     348:	e0 2e       	mov	r14, r16
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:255
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
     34a:	8c 8d       	ldd	r24, Y+28	; 0x1c
     34c:	8e 11       	cpse	r24, r14
     34e:	0c c0       	rjmp	.+24     	; 0x368 <HardwareSerial::write(unsigned char)+0x7c>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:256
    if (bit_is_clear(SREG, SREG_I)) {
     350:	0f b6       	in	r0, 0x3f	; 63
     352:	07 fc       	sbrc	r0, 7
     354:	fa cf       	rjmp	.-12     	; 0x34a <HardwareSerial::write(unsigned char)+0x5e>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:261
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
     356:	e8 89       	ldd	r30, Y+16	; 0x10
     358:	f9 89       	ldd	r31, Y+17	; 0x11
     35a:	80 81       	ld	r24, Z
     35c:	85 ff       	sbrs	r24, 5
     35e:	f5 cf       	rjmp	.-22     	; 0x34a <HardwareSerial::write(unsigned char)+0x5e>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:262
	_tx_udr_empty_irq();
     360:	ce 01       	movw	r24, r28
     362:	0e 94 54 01 	call	0x2a8	; 0x2a8 <HardwareSerial::_tx_udr_empty_irq()>
     366:	f1 cf       	rjmp	.-30     	; 0x34a <HardwareSerial::write(unsigned char)+0x5e>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:268
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
     368:	eb 8d       	ldd	r30, Y+27	; 0x1b
     36a:	ec 0f       	add	r30, r28
     36c:	fd 2f       	mov	r31, r29
     36e:	f1 1d       	adc	r31, r1
     370:	e3 5a       	subi	r30, 0xA3	; 163
     372:	ff 4f       	sbci	r31, 0xFF	; 255
     374:	f0 82       	st	Z, r15
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:273

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     376:	9f b7       	in	r25, 0x3f	; 63
__iCliRetVal():
c:\program files (x86)\arduino\hardware\tools\avr\avr\include\util/atomic.h:50
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     378:	f8 94       	cli
_ZN14HardwareSerial5writeEh():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:274
    _tx_buffer_head = i;
     37a:	0b 8f       	std	Y+27, r16	; 0x1b
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:275
    sbi(*_ucsrb, UDRIE0);
     37c:	ea 89       	ldd	r30, Y+18	; 0x12
     37e:	fb 89       	ldd	r31, Y+19	; 0x13
     380:	80 81       	ld	r24, Z
     382:	80 62       	ori	r24, 0x20	; 32
     384:	cf cf       	rjmp	.-98     	; 0x324 <HardwareSerial::write(unsigned char)+0x38>

00000386 <HardwareSerial::flush()>:
_ZN14HardwareSerial5flushEv():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:206
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
     386:	cf 93       	push	r28
     388:	df 93       	push	r29
     38a:	ec 01       	movw	r28, r24
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:210
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
     38c:	88 8d       	ldd	r24, Y+24	; 0x18
     38e:	88 23       	and	r24, r24
     390:	b9 f0       	breq	.+46     	; 0x3c0 <HardwareSerial::flush()+0x3a>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:213
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
     392:	aa 89       	ldd	r26, Y+18	; 0x12
     394:	bb 89       	ldd	r27, Y+19	; 0x13
     396:	e8 89       	ldd	r30, Y+16	; 0x10
     398:	f9 89       	ldd	r31, Y+17	; 0x11
     39a:	8c 91       	ld	r24, X
     39c:	85 fd       	sbrc	r24, 5
     39e:	03 c0       	rjmp	.+6      	; 0x3a6 <HardwareSerial::flush()+0x20>
     3a0:	80 81       	ld	r24, Z
     3a2:	86 fd       	sbrc	r24, 6
     3a4:	0d c0       	rjmp	.+26     	; 0x3c0 <HardwareSerial::flush()+0x3a>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:214
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
     3a6:	0f b6       	in	r0, 0x3f	; 63
     3a8:	07 fc       	sbrc	r0, 7
     3aa:	f7 cf       	rjmp	.-18     	; 0x39a <HardwareSerial::flush()+0x14>
     3ac:	8c 91       	ld	r24, X
     3ae:	85 ff       	sbrs	r24, 5
     3b0:	f2 cf       	rjmp	.-28     	; 0x396 <HardwareSerial::flush()+0x10>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:218
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
     3b2:	80 81       	ld	r24, Z
     3b4:	85 ff       	sbrs	r24, 5
     3b6:	ed cf       	rjmp	.-38     	; 0x392 <HardwareSerial::flush()+0xc>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:219
	  _tx_udr_empty_irq();
     3b8:	ce 01       	movw	r24, r28
     3ba:	0e 94 54 01 	call	0x2a8	; 0x2a8 <HardwareSerial::_tx_udr_empty_irq()>
     3be:	e9 cf       	rjmp	.-46     	; 0x392 <HardwareSerial::flush()+0xc>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:223
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
     3c0:	df 91       	pop	r29
     3c2:	cf 91       	pop	r28
     3c4:	08 95       	ret

000003c6 <turnOffPWM>:
turnOffPWM():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:77
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
     3c6:	83 30       	cpi	r24, 0x03	; 3
     3c8:	81 f0       	breq	.+32     	; 0x3ea <turnOffPWM+0x24>
     3ca:	28 f4       	brcc	.+10     	; 0x3d6 <turnOffPWM+0x10>
     3cc:	81 30       	cpi	r24, 0x01	; 1
     3ce:	99 f0       	breq	.+38     	; 0x3f6 <turnOffPWM+0x30>
     3d0:	82 30       	cpi	r24, 0x02	; 2
     3d2:	a9 f0       	breq	.+42     	; 0x3fe <turnOffPWM+0x38>
     3d4:	08 95       	ret
     3d6:	87 30       	cpi	r24, 0x07	; 7
     3d8:	a9 f0       	breq	.+42     	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
     3da:	88 30       	cpi	r24, 0x08	; 8
     3dc:	c9 f0       	breq	.+50     	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
     3de:	84 30       	cpi	r24, 0x04	; 4
     3e0:	b1 f4       	brne	.+44     	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:83
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
     3e2:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
     3e6:	8f 7d       	andi	r24, 0xDF	; 223
     3e8:	03 c0       	rjmp	.+6      	; 0x3f0 <turnOffPWM+0x2a>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:80
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
     3ea:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
     3ee:	8f 77       	andi	r24, 0x7F	; 127
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:83
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
     3f0:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
     3f4:	08 95       	ret
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:94
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
     3f6:	84 b5       	in	r24, 0x24	; 36
     3f8:	8f 77       	andi	r24, 0x7F	; 127
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:98
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
     3fa:	84 bd       	out	0x24, r24	; 36
     3fc:	08 95       	ret
     3fe:	84 b5       	in	r24, 0x24	; 36
     400:	8f 7d       	andi	r24, 0xDF	; 223
     402:	fb cf       	rjmp	.-10     	; 0x3fa <turnOffPWM+0x34>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:101
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
     404:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
     408:	8f 77       	andi	r24, 0x7F	; 127
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:104
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
     40a:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:136
		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
		#endif
	}
}
     40e:	08 95       	ret
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:104
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
     410:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
     414:	8f 7d       	andi	r24, 0xDF	; 223
     416:	f9 cf       	rjmp	.-14     	; 0x40a <__LOCK_REGION_LENGTH__+0xa>

00000418 <digitalRead>:
digitalRead():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:166

	SREG = oldSREG;
}

int digitalRead(uint8_t pin)
{
     418:	cf 93       	push	r28
     41a:	df 93       	push	r29
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:167
	uint8_t timer = digitalPinToTimer(pin);
     41c:	28 2f       	mov	r18, r24
     41e:	30 e0       	ldi	r19, 0x00	; 0
     420:	f9 01       	movw	r30, r18
     422:	ee 58       	subi	r30, 0x8E	; 142
     424:	ff 4f       	sbci	r31, 0xFF	; 255
     426:	84 91       	lpm	r24, Z
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:168
	uint8_t bit = digitalPinToBitMask(pin);
     428:	f9 01       	movw	r30, r18
     42a:	e2 55       	subi	r30, 0x52	; 82
     42c:	ff 4f       	sbci	r31, 0xFF	; 255
     42e:	d4 91       	lpm	r29, Z
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:169
	uint8_t port = digitalPinToPort(pin);
     430:	f9 01       	movw	r30, r18
     432:	e6 56       	subi	r30, 0x66	; 102
     434:	ff 4f       	sbci	r31, 0xFF	; 255
     436:	c4 91       	lpm	r28, Z
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:171

	if (port == NOT_A_PIN) return LOW;
     438:	cc 23       	and	r28, r28
     43a:	a1 f0       	breq	.+40     	; 0x464 <digitalRead+0x4c>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:175

	// If the pin that support PWM output, we need to turn it off
	// before getting a digital reading.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
     43c:	81 11       	cpse	r24, r1
     43e:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <turnOffPWM>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:177

	if (*portInputRegister(port) & bit) return HIGH;
     442:	ec 2f       	mov	r30, r28
     444:	f0 e0       	ldi	r31, 0x00	; 0
     446:	ee 0f       	add	r30, r30
     448:	ff 1f       	adc	r31, r31
     44a:	e8 59       	subi	r30, 0x98	; 152
     44c:	ff 4f       	sbci	r31, 0xFF	; 255
     44e:	a5 91       	lpm	r26, Z+
     450:	b4 91       	lpm	r27, Z
     452:	ec 91       	ld	r30, X
     454:	ed 23       	and	r30, r29
     456:	81 e0       	ldi	r24, 0x01	; 1
     458:	90 e0       	ldi	r25, 0x00	; 0
     45a:	09 f4       	brne	.+2      	; 0x45e <digitalRead+0x46>
     45c:	80 e0       	ldi	r24, 0x00	; 0
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:179
	return LOW;
}
     45e:	df 91       	pop	r29
     460:	cf 91       	pop	r28
     462:	08 95       	ret
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:171
{
	uint8_t timer = digitalPinToTimer(pin);
	uint8_t bit = digitalPinToBitMask(pin);
	uint8_t port = digitalPinToPort(pin);

	if (port == NOT_A_PIN) return LOW;
     464:	80 e0       	ldi	r24, 0x00	; 0
     466:	90 e0       	ldi	r25, 0x00	; 0
     468:	fa cf       	rjmp	.-12     	; 0x45e <digitalRead+0x46>

0000046a <digitalWrite>:
digitalWrite():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:139
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
     46a:	1f 93       	push	r17
     46c:	cf 93       	push	r28
     46e:	df 93       	push	r29
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:140
	uint8_t timer = digitalPinToTimer(pin);
     470:	28 2f       	mov	r18, r24
     472:	30 e0       	ldi	r19, 0x00	; 0
     474:	f9 01       	movw	r30, r18
     476:	ee 58       	subi	r30, 0x8E	; 142
     478:	ff 4f       	sbci	r31, 0xFF	; 255
     47a:	84 91       	lpm	r24, Z
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:141
	uint8_t bit = digitalPinToBitMask(pin);
     47c:	f9 01       	movw	r30, r18
     47e:	e2 55       	subi	r30, 0x52	; 82
     480:	ff 4f       	sbci	r31, 0xFF	; 255
     482:	d4 91       	lpm	r29, Z
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:142
	uint8_t port = digitalPinToPort(pin);
     484:	f9 01       	movw	r30, r18
     486:	e6 56       	subi	r30, 0x66	; 102
     488:	ff 4f       	sbci	r31, 0xFF	; 255
     48a:	c4 91       	lpm	r28, Z
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:145
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
     48c:	cc 23       	and	r28, r28
     48e:	a9 f0       	breq	.+42     	; 0x4ba <digitalWrite+0x50>
     490:	16 2f       	mov	r17, r22
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:149

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
     492:	81 11       	cpse	r24, r1
     494:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <turnOffPWM>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:151

	out = portOutputRegister(port);
     498:	ec 2f       	mov	r30, r28
     49a:	f0 e0       	ldi	r31, 0x00	; 0
     49c:	ee 0f       	add	r30, r30
     49e:	ff 1f       	adc	r31, r31
     4a0:	ea 57       	subi	r30, 0x7A	; 122
     4a2:	ff 4f       	sbci	r31, 0xFF	; 255
     4a4:	a5 91       	lpm	r26, Z+
     4a6:	b4 91       	lpm	r27, Z
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:153

	uint8_t oldSREG = SREG;
     4a8:	8f b7       	in	r24, 0x3f	; 63
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:154
	cli();
     4aa:	f8 94       	cli
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:157

	if (val == LOW) {
		*out &= ~bit;
     4ac:	ec 91       	ld	r30, X
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:156
	out = portOutputRegister(port);

	uint8_t oldSREG = SREG;
	cli();

	if (val == LOW) {
     4ae:	11 11       	cpse	r17, r1
     4b0:	08 c0       	rjmp	.+16     	; 0x4c2 <digitalWrite+0x58>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:157
		*out &= ~bit;
     4b2:	d0 95       	com	r29
     4b4:	de 23       	and	r29, r30
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:159
	} else {
		*out |= bit;
     4b6:	dc 93       	st	X, r29
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:162
	}

	SREG = oldSREG;
     4b8:	8f bf       	out	0x3f, r24	; 63
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:163
}
     4ba:	df 91       	pop	r29
     4bc:	cf 91       	pop	r28
     4be:	1f 91       	pop	r17
     4c0:	08 95       	ret
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring_digital.c:159
	cli();

	if (val == LOW) {
		*out &= ~bit;
	} else {
		*out |= bit;
     4c2:	de 2b       	or	r29, r30
     4c4:	f8 cf       	rjmp	.-16     	; 0x4b6 <digitalWrite+0x4c>

000004c6 <micros>:
micros():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:81
	return m;
}

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
     4c6:	3f b7       	in	r19, 0x3f	; 63
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:83
	
	cli();
     4c8:	f8 94       	cli
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:84
	m = timer0_overflow_count;
     4ca:	80 91 b7 01 	lds	r24, 0x01B7	; 0x8001b7 <timer0_overflow_count>
     4ce:	90 91 b8 01 	lds	r25, 0x01B8	; 0x8001b8 <timer0_overflow_count+0x1>
     4d2:	a0 91 b9 01 	lds	r26, 0x01B9	; 0x8001b9 <timer0_overflow_count+0x2>
     4d6:	b0 91 ba 01 	lds	r27, 0x01BA	; 0x8001ba <timer0_overflow_count+0x3>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:86
#if defined(TCNT0)
	t = TCNT0;
     4da:	26 b5       	in	r18, 0x26	; 38
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:94
#else
	#error TIMER 0 not defined
#endif

#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
     4dc:	a8 9b       	sbis	0x15, 0	; 21
     4de:	05 c0       	rjmp	.+10     	; 0x4ea <micros+0x24>
     4e0:	2f 3f       	cpi	r18, 0xFF	; 255
     4e2:	19 f0       	breq	.+6      	; 0x4ea <micros+0x24>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:95
		m++;
     4e4:	01 96       	adiw	r24, 0x01	; 1
     4e6:	a1 1d       	adc	r26, r1
     4e8:	b1 1d       	adc	r27, r1
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:101
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
     4ea:	3f bf       	out	0x3f, r19	; 63
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:103
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
     4ec:	ba 2f       	mov	r27, r26
     4ee:	a9 2f       	mov	r26, r25
     4f0:	98 2f       	mov	r25, r24
     4f2:	88 27       	eor	r24, r24
     4f4:	bc 01       	movw	r22, r24
     4f6:	cd 01       	movw	r24, r26
     4f8:	62 0f       	add	r22, r18
     4fa:	71 1d       	adc	r23, r1
     4fc:	81 1d       	adc	r24, r1
     4fe:	91 1d       	adc	r25, r1
     500:	42 e0       	ldi	r20, 0x02	; 2
     502:	66 0f       	add	r22, r22
     504:	77 1f       	adc	r23, r23
     506:	88 1f       	adc	r24, r24
     508:	99 1f       	adc	r25, r25
     50a:	4a 95       	dec	r20
     50c:	d1 f7       	brne	.-12     	; 0x502 <micros+0x3c>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:104
}
     50e:	08 95       	ret

00000510 <millis>:
millis():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:68
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
     510:	2f b7       	in	r18, 0x3f	; 63
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:72

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
     512:	f8 94       	cli
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:73
	m = timer0_millis;
     514:	60 91 b3 01 	lds	r22, 0x01B3	; 0x8001b3 <timer0_millis>
     518:	70 91 b4 01 	lds	r23, 0x01B4	; 0x8001b4 <timer0_millis+0x1>
     51c:	80 91 b5 01 	lds	r24, 0x01B5	; 0x8001b5 <timer0_millis+0x2>
     520:	90 91 b6 01 	lds	r25, 0x01B6	; 0x8001b6 <timer0_millis+0x3>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:74
	SREG = oldSREG;
     524:	2f bf       	out	0x3f, r18	; 63
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:77

	return m;
}
     526:	08 95       	ret

00000528 <VisualMicroDebug::DBG_YieldAndWait(unsigned long, bool) [clone .constprop.52]>:
_ZN16VisualMicroDebug16DBG_YieldAndWaitEmb.constprop.52():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:123

void VisualMicroDebug::DBG_YieldAndWait(unsigned long ms)
{
	DBG_YieldAndWait(ms, true);
}
void VisualMicroDebug::DBG_YieldAndWait(unsigned long ms, bool handle_events)
     528:	8f 92       	push	r8
     52a:	9f 92       	push	r9
     52c:	af 92       	push	r10
     52e:	bf 92       	push	r11
     530:	cf 92       	push	r12
     532:	df 92       	push	r13
     534:	ef 92       	push	r14
     536:	ff 92       	push	r15
     538:	6b 01       	movw	r12, r22
     53a:	7c 01       	movw	r14, r24
DBG_Millis():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:172
	return RTT::millis();
}
#else
unsigned long VisualMicroDebug::DBG_Millis()
{
	return millis();
     53c:	0e 94 88 02 	call	0x510	; 0x510 <millis>
     540:	4b 01       	movw	r8, r22
     542:	5c 01       	movw	r10, r24
_ZN16VisualMicroDebug16DBG_YieldAndWaitEmb.constprop.52():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:126
	DBG_YieldAndWait(ms, true);
}
void VisualMicroDebug::DBG_YieldAndWait(unsigned long ms, bool handle_events)
{
	unsigned long ms_start = DBG_Millis();
	unsigned long ms_end = ms_start + ms;
     544:	c8 0c       	add	r12, r8
     546:	d9 1c       	adc	r13, r9
     548:	ea 1c       	adc	r14, r10
     54a:	fb 1c       	adc	r15, r11
DBG_Millis():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:172
	return RTT::millis();
}
#else
unsigned long VisualMicroDebug::DBG_Millis()
{
	return millis();
     54c:	0e 94 88 02 	call	0x510	; 0x510 <millis>
_ZN16VisualMicroDebug16DBG_YieldAndWaitEmb.constprop.52():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:140

		//delay(1);

		ms_curr = DBG_Millis();

		if (ms_curr<ms_start || ms_curr>ms_end) {
     550:	68 15       	cp	r22, r8
     552:	79 05       	cpc	r23, r9
     554:	8a 05       	cpc	r24, r10
     556:	9b 05       	cpc	r25, r11
     558:	28 f0       	brcs	.+10     	; 0x564 <VisualMicroDebug::DBG_YieldAndWait(unsigned long, bool) [clone .constprop.52]+0x3c>
     55a:	c6 16       	cp	r12, r22
     55c:	d7 06       	cpc	r13, r23
     55e:	e8 06       	cpc	r14, r24
     560:	f9 06       	cpc	r15, r25
     562:	a0 f7       	brcc	.-24     	; 0x54c <VisualMicroDebug::DBG_YieldAndWait(unsigned long, bool) [clone .constprop.52]+0x24>
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:158
			//#endif
#endif
		}
	}

}
     564:	ff 90       	pop	r15
     566:	ef 90       	pop	r14
     568:	df 90       	pop	r13
     56a:	cf 90       	pop	r12
     56c:	bf 90       	pop	r11
     56e:	af 90       	pop	r10
     570:	9f 90       	pop	r9
     572:	8f 90       	pop	r8
     574:	08 95       	ret

00000576 <VisualMicroDebug::DBG_YieldAndWait(unsigned long) [clone .constprop.51]>:
_ZN16VisualMicroDebug16DBG_YieldAndWaitEm.constprop.51():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:121
#endif


void VisualMicroDebug::DBG_YieldAndWait(unsigned long ms)
{
	DBG_YieldAndWait(ms, true);
     576:	0c 94 94 02 	jmp	0x528	; 0x528 <VisualMicroDebug::DBG_YieldAndWait(unsigned long, bool) [clone .constprop.52]>

0000057a <VisualMicroDebug::outPacketStart(bool) [clone .constprop.41]>:
_ZN16VisualMicroDebug14outPacketStartEb.constprop.41():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:315
{
	return outPacketStart(false);
}


bool VisualMicroDebug::outPacketStart(bool noWait)
     57a:	cf 92       	push	r12
     57c:	df 92       	push	r13
     57e:	ef 92       	push	r14
     580:	ff 92       	push	r15
     582:	0f 93       	push	r16
     584:	1f 93       	push	r17
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:331
	yield();
#endif


#if defined(VM_DEBUG_BANDWIDTH_THROTTLE_MS) //&& (VM_DBT != VM_DBT_NET_UDP)
	if (!noWait)
     586:	81 11       	cpse	r24, r1
     588:	23 c0       	rjmp	.+70     	; 0x5d0 <VisualMicroDebug::outPacketStart(bool) [clone .constprop.41]+0x56>
DBG_Millis():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:172
	return RTT::millis();
}
#else
unsigned long VisualMicroDebug::DBG_Millis()
{
	return millis();
     58a:	0e 94 88 02 	call	0x510	; 0x510 <millis>
_ZN16VisualMicroDebug14outPacketStartEb.constprop.41():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:335
#if defined(VM_DEBUG_BANDWIDTH_THROTTLE_MS) //&& (VM_DBT != VM_DBT_NET_UDP)
	if (!noWait)
	{

		unsigned long ms_wait;
		ms_wait = (DBG_Millis() - lastPacketMS);
     58e:	00 91 d5 02 	lds	r16, 0x02D5	; 0x8002d5 <MicroDebug+0x2>
     592:	10 91 d6 02 	lds	r17, 0x02D6	; 0x8002d6 <MicroDebug+0x3>
     596:	20 91 d7 02 	lds	r18, 0x02D7	; 0x8002d7 <MicroDebug+0x4>
     59a:	30 91 d8 02 	lds	r19, 0x02D8	; 0x8002d8 <MicroDebug+0x5>
     59e:	dc 01       	movw	r26, r24
     5a0:	cb 01       	movw	r24, r22
     5a2:	80 1b       	sub	r24, r16
     5a4:	91 0b       	sbc	r25, r17
     5a6:	a2 0b       	sbc	r26, r18
     5a8:	b3 0b       	sbc	r27, r19
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:336
		if (ms_wait < VM_DEBUG_BANDWIDTH_THROTTLE_MS)
     5aa:	82 33       	cpi	r24, 0x32	; 50
     5ac:	91 05       	cpc	r25, r1
     5ae:	a1 05       	cpc	r26, r1
     5b0:	b1 05       	cpc	r27, r1
     5b2:	70 f4       	brcc	.+28     	; 0x5d0 <VisualMicroDebug::outPacketStart(bool) [clone .constprop.41]+0x56>
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:338
		{
			ms_wait = (VM_DEBUG_BANDWIDTH_THROTTLE_MS - ms_wait);
     5b4:	02 e3       	ldi	r16, 0x32	; 50
     5b6:	10 e0       	ldi	r17, 0x00	; 0
     5b8:	20 e0       	ldi	r18, 0x00	; 0
     5ba:	30 e0       	ldi	r19, 0x00	; 0
     5bc:	68 01       	movw	r12, r16
     5be:	79 01       	movw	r14, r18
     5c0:	c8 1a       	sub	r12, r24
     5c2:	d9 0a       	sbc	r13, r25
     5c4:	ea 0a       	sbc	r14, r26
     5c6:	fb 0a       	sbc	r15, r27
     5c8:	c7 01       	movw	r24, r14
     5ca:	b6 01       	movw	r22, r12
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:339
			DBG_YieldAndWait(ms_wait, true); //ota events if not first packet/version
     5cc:	0e 94 94 02 	call	0x528	; 0x528 <VisualMicroDebug::DBG_YieldAndWait(unsigned long, bool) [clone .constprop.52]>
DBG_Millis():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:172
	return RTT::millis();
}
#else
unsigned long VisualMicroDebug::DBG_Millis()
{
	return millis();
     5d0:	0e 94 88 02 	call	0x510	; 0x510 <millis>
_ZN16VisualMicroDebug14outPacketStartEb.constprop.41():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:351
			//DBG_YieldAndWait(3)
		//}
	}
	//XXX: this should really be after packet end!
	//1501 for cosa - lastPacketMS=millis();
	lastPacketMS = DBG_Millis();
     5d4:	60 93 d5 02 	sts	0x02D5, r22	; 0x8002d5 <MicroDebug+0x2>
     5d8:	70 93 d6 02 	sts	0x02D6, r23	; 0x8002d6 <MicroDebug+0x3>
     5dc:	80 93 d7 02 	sts	0x02D7, r24	; 0x8002d7 <MicroDebug+0x4>
     5e0:	90 93 d8 02 	sts	0x02D8, r25	; 0x8002d8 <MicroDebug+0x5>
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:428
	transport->beginPacket();
#endif
#endif

	return true;
}
     5e4:	81 e0       	ldi	r24, 0x01	; 1
     5e6:	1f 91       	pop	r17
     5e8:	0f 91       	pop	r16
     5ea:	ff 90       	pop	r15
     5ec:	ef 90       	pop	r14
     5ee:	df 90       	pop	r13
     5f0:	cf 90       	pop	r12
     5f2:	08 95       	ret

000005f4 <VisualMicroDebug::digitalWriteMessageCheck() [clone .part.0] [clone .constprop.55]>:
_ZN16VisualMicroDebug24digitalWriteMessageCheckEv.part.0.constprop.55():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:214
	BreakStartMillis = DBG_Millis();
	digitalWriteMessageCheck();
}

// Work out if we have a DigitalPin Inbound
void VisualMicroDebug::digitalWriteMessageCheck()
     5f4:	ef 92       	push	r14
     5f6:	ff 92       	push	r15
     5f8:	0f 93       	push	r16
     5fa:	1f 93       	push	r17
     5fc:	cf 93       	push	r28
     5fe:	df 93       	push	r29
     600:	00 d0       	rcall	.+0      	; 0x602 <VisualMicroDebug::digitalWriteMessageCheck() [clone .part.0] [clone .constprop.55]+0xe>
     602:	00 d0       	rcall	.+0      	; 0x604 <VisualMicroDebug::digitalWriteMessageCheck() [clone .part.0] [clone .constprop.55]+0x10>
     604:	cd b7       	in	r28, 0x3d	; 61
     606:	de b7       	in	r29, 0x3e	; 62
read():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1222
#elif defined(VMDGB_HAS_READER)
	b = reader->getchar();
#elif defined(VM_DBT) && (VM_DBT == VM_DBT_SOFTWARESERIAL)
	b = transport->read();
#else
	b = VM_DEBUGGER_SOFT_TRANSPORT.read();
     608:	86 e3       	ldi	r24, 0x36	; 54
     60a:	92 e0       	ldi	r25, 0x02	; 2
     60c:	0e 94 0f 01 	call	0x21e	; 0x21e <HardwareSerial::read()>
     610:	86 e3       	ldi	r24, 0x36	; 54
     612:	92 e0       	ldi	r25, 0x02	; 2
     614:	0e 94 0f 01 	call	0x21e	; 0x21e <HardwareSerial::read()>
     618:	8e 01       	movw	r16, r28
     61a:	0f 5f       	subi	r16, 0xFF	; 255
     61c:	1f 4f       	sbci	r17, 0xFF	; 255
     61e:	78 01       	movw	r14, r16
_ZN16VisualMicroDebug24digitalWriteMessageCheckEv.part.0.constprop.55():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:223
	int pinCharRead = 0;
	if (nxtChar == 'd') {
		// Read Our message back -> dxxxx:1 where xxxxx is the pin number (must be a number!)
		read(); // Remove d
		char nxt = read();
		while (nxt != ':') {
     620:	8a 33       	cpi	r24, 0x3A	; 58
     622:	41 f0       	breq	.+16     	; 0x634 <VisualMicroDebug::digitalWriteMessageCheck() [clone .part.0] [clone .constprop.55]+0x40>
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:224
			pinStr[pinCharRead] = nxt;
     624:	f8 01       	movw	r30, r16
     626:	81 93       	st	Z+, r24
     628:	8f 01       	movw	r16, r30
read():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1222
#elif defined(VMDGB_HAS_READER)
	b = reader->getchar();
#elif defined(VM_DBT) && (VM_DBT == VM_DBT_SOFTWARESERIAL)
	b = transport->read();
#else
	b = VM_DEBUGGER_SOFT_TRANSPORT.read();
     62a:	86 e3       	ldi	r24, 0x36	; 54
     62c:	92 e0       	ldi	r25, 0x02	; 2
     62e:	0e 94 0f 01 	call	0x21e	; 0x21e <HardwareSerial::read()>
     632:	f6 cf       	rjmp	.-20     	; 0x620 <VisualMicroDebug::digitalWriteMessageCheck() [clone .part.0] [clone .constprop.55]+0x2c>
_ZN16VisualMicroDebug24digitalWriteMessageCheckEv.part.0.constprop.55():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:228
		while (nxt != ':') {
			pinStr[pinCharRead] = nxt;
			pinCharRead++;
			nxt = read();
		}
		int pin = atoi(pinStr);	// at : so skip and read state char
     634:	c7 01       	movw	r24, r14
     636:	0e 94 55 19 	call	0x32aa	; 0x32aa <atoi>
     63a:	18 2f       	mov	r17, r24
read():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1222
#elif defined(VMDGB_HAS_READER)
	b = reader->getchar();
#elif defined(VM_DBT) && (VM_DBT == VM_DBT_SOFTWARESERIAL)
	b = transport->read();
#else
	b = VM_DEBUGGER_SOFT_TRANSPORT.read();
     63c:	86 e3       	ldi	r24, 0x36	; 54
     63e:	92 e0       	ldi	r25, 0x02	; 2
     640:	0e 94 0f 01 	call	0x21e	; 0x21e <HardwareSerial::read()>
_ZN16VisualMicroDebug24digitalWriteMessageCheckEv.part.0.constprop.55():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:229
			pinStr[pinCharRead] = nxt;
			pinCharRead++;
			nxt = read();
		}
		int pin = atoi(pinStr);	// at : so skip and read state char
		int state = read() - 48;
     644:	80 53       	subi	r24, 0x30	; 48
     646:	99 0b       	sbc	r25, r25
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:230
		if (state == 1 || state == 0) { // State check, not sure tri-state truly supported with DigiWrite
     648:	82 30       	cpi	r24, 0x02	; 2
     64a:	91 05       	cpc	r25, r1
     64c:	20 f4       	brcc	.+8      	; 0x656 <VisualMicroDebug::digitalWriteMessageCheck() [clone .part.0] [clone .constprop.55]+0x62>
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:231
			digitalWrite(pin, state);
     64e:	68 2f       	mov	r22, r24
     650:	81 2f       	mov	r24, r17
     652:	0e 94 35 02 	call	0x46a	; 0x46a <digitalWrite>
read():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1222
#elif defined(VMDGB_HAS_READER)
	b = reader->getchar();
#elif defined(VM_DBT) && (VM_DBT == VM_DBT_SOFTWARESERIAL)
	b = transport->read();
#else
	b = VM_DEBUGGER_SOFT_TRANSPORT.read();
     656:	86 e3       	ldi	r24, 0x36	; 54
     658:	92 e0       	ldi	r25, 0x02	; 2
     65a:	0e 94 0f 01 	call	0x21e	; 0x21e <HardwareSerial::read()>
_ZN16VisualMicroDebug24digitalWriteMessageCheckEv.part.0.constprop.55():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:233
		int pin = atoi(pinStr);	// at : so skip and read state char
		int state = read() - 48;
		if (state == 1 || state == 0) { // State check, not sure tri-state truly supported with DigiWrite
			digitalWrite(pin, state);
		}
		while (nxt != '\n' && nxt != '\r') {
     65e:	8a 30       	cpi	r24, 0x0A	; 10
     660:	11 f0       	breq	.+4      	; 0x666 <VisualMicroDebug::digitalWriteMessageCheck() [clone .part.0] [clone .constprop.55]+0x72>
     662:	8d 30       	cpi	r24, 0x0D	; 13
     664:	c1 f7       	brne	.-16     	; 0x656 <VisualMicroDebug::digitalWriteMessageCheck() [clone .part.0] [clone .constprop.55]+0x62>
peek():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1240
#elif defined(VMDGB_HAS_READER)
	b = reader->peekchar();
#elif defined(VM_DBT) && (VM_DBT == VM_DBT_SOFTWARESERIAL)
	b = transport->peek();
#else
	b = VM_DEBUGGER_SOFT_TRANSPORT.peek();
     666:	86 e3       	ldi	r24, 0x36	; 54
     668:	92 e0       	ldi	r25, 0x02	; 2
     66a:	0e 94 23 01 	call	0x246	; 0x246 <HardwareSerial::peek()>
_ZN16VisualMicroDebug24digitalWriteMessageCheckEv.part.0.constprop.55():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:236
			digitalWrite(pin, state);
		}
		while (nxt != '\n' && nxt != '\r') {
			nxt = read();
		}
		if (peek() == '\n') {
     66e:	8a 30       	cpi	r24, 0x0A	; 10
     670:	21 f4       	brne	.+8      	; 0x67a <VisualMicroDebug::digitalWriteMessageCheck() [clone .part.0] [clone .constprop.55]+0x86>
read():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1222
#elif defined(VMDGB_HAS_READER)
	b = reader->getchar();
#elif defined(VM_DBT) && (VM_DBT == VM_DBT_SOFTWARESERIAL)
	b = transport->read();
#else
	b = VM_DEBUGGER_SOFT_TRANSPORT.read();
     672:	86 e3       	ldi	r24, 0x36	; 54
     674:	92 e0       	ldi	r25, 0x02	; 2
     676:	0e 94 0f 01 	call	0x21e	; 0x21e <HardwareSerial::read()>
_ZN16VisualMicroDebug24digitalWriteMessageCheckEv.part.0.constprop.55():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:240
		}
		if (peek() == '\n') {
			read();
		}
	}
}
     67a:	0f 90       	pop	r0
     67c:	0f 90       	pop	r0
     67e:	0f 90       	pop	r0
     680:	0f 90       	pop	r0
     682:	df 91       	pop	r29
     684:	cf 91       	pop	r28
     686:	1f 91       	pop	r17
     688:	0f 91       	pop	r16
     68a:	ff 90       	pop	r15
     68c:	ef 90       	pop	r14
     68e:	08 95       	ret

00000690 <VisualMicroDebug::OnBreakPointBegin(unsigned long) [clone .constprop.33]>:
_ZN16VisualMicroDebug17OnBreakPointBeginEm.constprop.33():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:206
void VisualMicroDebug::OnBreakPointBegin(unsigned long iInBreakMsgRepeatMS)
{
#if defined(VM_DBT) && (VM_DBT == VM_DBT_NET_UDP)
	available();
#endif
	InBreakMsgRepeatMS = iInBreakMsgRepeatMS;
     690:	84 ef       	ldi	r24, 0xF4	; 244
     692:	91 e0       	ldi	r25, 0x01	; 1
     694:	a0 e0       	ldi	r26, 0x00	; 0
     696:	b0 e0       	ldi	r27, 0x00	; 0
     698:	80 93 e1 02 	sts	0x02E1, r24	; 0x8002e1 <MicroDebug+0xe>
     69c:	90 93 e2 02 	sts	0x02E2, r25	; 0x8002e2 <MicroDebug+0xf>
     6a0:	a0 93 e3 02 	sts	0x02E3, r26	; 0x8002e3 <MicroDebug+0x10>
     6a4:	b0 93 e4 02 	sts	0x02E4, r27	; 0x8002e4 <MicroDebug+0x11>
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:207
	InBreakMsgSent = 0L;
     6a8:	10 92 e5 02 	sts	0x02E5, r1	; 0x8002e5 <MicroDebug+0x12>
     6ac:	10 92 e6 02 	sts	0x02E6, r1	; 0x8002e6 <MicroDebug+0x13>
     6b0:	10 92 e7 02 	sts	0x02E7, r1	; 0x8002e7 <MicroDebug+0x14>
     6b4:	10 92 e8 02 	sts	0x02E8, r1	; 0x8002e8 <MicroDebug+0x15>
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:208
	BreakPrevMillis = BreakStartMillis;
     6b8:	80 91 d9 02 	lds	r24, 0x02D9	; 0x8002d9 <MicroDebug+0x6>
     6bc:	90 91 da 02 	lds	r25, 0x02DA	; 0x8002da <MicroDebug+0x7>
     6c0:	a0 91 db 02 	lds	r26, 0x02DB	; 0x8002db <MicroDebug+0x8>
     6c4:	b0 91 dc 02 	lds	r27, 0x02DC	; 0x8002dc <MicroDebug+0x9>
     6c8:	80 93 dd 02 	sts	0x02DD, r24	; 0x8002dd <MicroDebug+0xa>
     6cc:	90 93 de 02 	sts	0x02DE, r25	; 0x8002de <MicroDebug+0xb>
     6d0:	a0 93 df 02 	sts	0x02DF, r26	; 0x8002df <MicroDebug+0xc>
     6d4:	b0 93 e0 02 	sts	0x02E0, r27	; 0x8002e0 <MicroDebug+0xd>
DBG_Millis():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:172
	return RTT::millis();
}
#else
unsigned long VisualMicroDebug::DBG_Millis()
{
	return millis();
     6d8:	0e 94 88 02 	call	0x510	; 0x510 <millis>
_ZN16VisualMicroDebug17OnBreakPointBeginEm.constprop.33():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:209
	available();
#endif
	InBreakMsgRepeatMS = iInBreakMsgRepeatMS;
	InBreakMsgSent = 0L;
	BreakPrevMillis = BreakStartMillis;
	BreakStartMillis = DBG_Millis();
     6dc:	60 93 d9 02 	sts	0x02D9, r22	; 0x8002d9 <MicroDebug+0x6>
     6e0:	70 93 da 02 	sts	0x02DA, r23	; 0x8002da <MicroDebug+0x7>
     6e4:	80 93 db 02 	sts	0x02DB, r24	; 0x8002db <MicroDebug+0x8>
     6e8:	90 93 dc 02 	sts	0x02DC, r25	; 0x8002dc <MicroDebug+0x9>
peek():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1240
#elif defined(VMDGB_HAS_READER)
	b = reader->peekchar();
#elif defined(VM_DBT) && (VM_DBT == VM_DBT_SOFTWARESERIAL)
	b = transport->peek();
#else
	b = VM_DEBUGGER_SOFT_TRANSPORT.peek();
     6ec:	86 e3       	ldi	r24, 0x36	; 54
     6ee:	92 e0       	ldi	r25, 0x02	; 2
     6f0:	0e 94 23 01 	call	0x246	; 0x246 <HardwareSerial::peek()>
digitalWriteMessageCheck():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:219
void VisualMicroDebug::digitalWriteMessageCheck()
{
	char nxtChar = peek();
	char pinStr[4];
	int pinCharRead = 0;
	if (nxtChar == 'd') {
     6f4:	84 36       	cpi	r24, 0x64	; 100
     6f6:	11 f4       	brne	.+4      	; 0x6fc <VisualMicroDebug::OnBreakPointBegin(unsigned long) [clone .constprop.33]+0x6c>
     6f8:	0c 94 fa 02 	jmp	0x5f4	; 0x5f4 <VisualMicroDebug::digitalWriteMessageCheck() [clone .part.0] [clone .constprop.55]>
_ZN16VisualMicroDebug17OnBreakPointBeginEm.constprop.33():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:211
	InBreakMsgRepeatMS = iInBreakMsgRepeatMS;
	InBreakMsgSent = 0L;
	BreakPrevMillis = BreakStartMillis;
	BreakStartMillis = DBG_Millis();
	digitalWriteMessageCheck();
}
     6fc:	08 95       	ret

000006fe <VisualMicroDebug::OnBreakPointEnd() [clone .constprop.53]>:
_ZN16VisualMicroDebug15OnBreakPointEndEv.constprop.53():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1240
#elif defined(VMDGB_HAS_READER)
	b = reader->peekchar();
#elif defined(VM_DBT) && (VM_DBT == VM_DBT_SOFTWARESERIAL)
	b = transport->peek();
#else
	b = VM_DEBUGGER_SOFT_TRANSPORT.peek();
     6fe:	86 e3       	ldi	r24, 0x36	; 54
     700:	92 e0       	ldi	r25, 0x02	; 2
     702:	0e 94 23 01 	call	0x246	; 0x246 <HardwareSerial::peek()>
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:219
void VisualMicroDebug::digitalWriteMessageCheck()
{
	char nxtChar = peek();
	char pinStr[4];
	int pinCharRead = 0;
	if (nxtChar == 'd') {
     706:	84 36       	cpi	r24, 0x64	; 100
     708:	11 f4       	brne	.+4      	; 0x70e <VisualMicroDebug::OnBreakPointEnd() [clone .constprop.53]+0x10>
     70a:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <VisualMicroDebug::digitalWriteMessageCheck() [clone .part.0] [clone .constprop.55]>
DBG_Millis():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:172
	return RTT::millis();
}
#else
unsigned long VisualMicroDebug::DBG_Millis()
{
	return millis();
     70e:	0e 94 88 02 	call	0x510	; 0x510 <millis>
_ZN16VisualMicroDebug15OnBreakPointEndEv.constprop.53():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:305

void VisualMicroDebug::OnBreakPointEnd()
{
	digitalWriteMessageCheck(); // Check for Digital Pin
	//update millis to now. ensure time taken for debug doesn't affect comparison of the time to the next point
	BreakStartMillis = DBG_Millis();
     712:	60 93 d9 02 	sts	0x02D9, r22	; 0x8002d9 <MicroDebug+0x6>
     716:	70 93 da 02 	sts	0x02DA, r23	; 0x8002da <MicroDebug+0x7>
     71a:	80 93 db 02 	sts	0x02DB, r24	; 0x8002db <MicroDebug+0x8>
     71e:	90 93 dc 02 	sts	0x02DC, r25	; 0x8002dc <MicroDebug+0x9>
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:307

}
     722:	08 95       	ret

00000724 <Print::write(char const*) [clone .part.2] [clone .constprop.50]>:
_ZN5Print5writeEPKc.part.2.constprop.50():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.h:54
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
     724:	fc 01       	movw	r30, r24
     726:	01 90       	ld	r0, Z+
     728:	00 20       	and	r0, r0
     72a:	e9 f7       	brne	.-6      	; 0x726 <Print::write(char const*) [clone .part.2] [clone .constprop.50]+0x2>
     72c:	31 97       	sbiw	r30, 0x01	; 1
     72e:	af 01       	movw	r20, r30
     730:	48 1b       	sub	r20, r24
     732:	59 0b       	sbc	r21, r25
     734:	bc 01       	movw	r22, r24
     736:	86 e3       	ldi	r24, 0x36	; 54
     738:	92 e0       	ldi	r25, 0x02	; 2
     73a:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <Print::write(unsigned char const*, unsigned int)>

0000073e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]>:
_ZN5Print11printNumberEmh.constprop.46():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:203
  return n;
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base)
     73e:	8f 92       	push	r8
     740:	9f 92       	push	r9
     742:	af 92       	push	r10
     744:	bf 92       	push	r11
     746:	0f 93       	push	r16
     748:	1f 93       	push	r17
     74a:	cf 93       	push	r28
     74c:	df 93       	push	r29
     74e:	cd b7       	in	r28, 0x3d	; 61
     750:	de b7       	in	r29, 0x3e	; 62
     752:	a1 97       	sbiw	r28, 0x21	; 33
     754:	0f b6       	in	r0, 0x3f	; 63
     756:	f8 94       	cli
     758:	de bf       	out	0x3e, r29	; 62
     75a:	0f be       	out	0x3f, r0	; 63
     75c:	cd bf       	out	0x3d, r28	; 61
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:208
{
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
     75e:	19 a2       	std	Y+33, r1	; 0x21
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:211

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
     760:	42 30       	cpi	r20, 0x02	; 2
     762:	08 f4       	brcc	.+2      	; 0x766 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]+0x28>
     764:	4a e0       	ldi	r20, 0x0A	; 10
     766:	8e 01       	movw	r16, r28
     768:	0f 5d       	subi	r16, 0xDF	; 223
     76a:	1f 4f       	sbci	r17, 0xFF	; 255
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:214

  do {
    char c = n % base;
     76c:	84 2e       	mov	r8, r20
     76e:	91 2c       	mov	r9, r1
     770:	b1 2c       	mov	r11, r1
     772:	a1 2c       	mov	r10, r1
     774:	a5 01       	movw	r20, r10
     776:	94 01       	movw	r18, r8
     778:	0e 94 7b 19 	call	0x32f6	; 0x32f6 <__udivmodsi4>
     77c:	e6 2f       	mov	r30, r22
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:215
    n /= base;
     77e:	b9 01       	movw	r22, r18
     780:	ca 01       	movw	r24, r20
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:217

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
     782:	ea 30       	cpi	r30, 0x0A	; 10
     784:	f4 f4       	brge	.+60     	; 0x7c2 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]+0x84>
     786:	e0 5d       	subi	r30, 0xD0	; 208
     788:	d8 01       	movw	r26, r16
     78a:	ee 93       	st	-X, r30
     78c:	8d 01       	movw	r16, r26
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:218
  } while(n);
     78e:	23 2b       	or	r18, r19
     790:	24 2b       	or	r18, r20
     792:	25 2b       	or	r18, r21
     794:	79 f7       	brne	.-34     	; 0x774 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]+0x36>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.h:53
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
     796:	90 e0       	ldi	r25, 0x00	; 0
     798:	80 e0       	ldi	r24, 0x00	; 0
write():
     79a:	10 97       	sbiw	r26, 0x00	; 0
     79c:	19 f0       	breq	.+6      	; 0x7a4 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]+0x66>
     79e:	cd 01       	movw	r24, r26
     7a0:	0e 94 92 03 	call	0x724	; 0x724 <Print::write(char const*) [clone .part.2] [clone .constprop.50]>
_ZN5Print11printNumberEmh.constprop.46():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:221

  return write(str);
}
     7a4:	a1 96       	adiw	r28, 0x21	; 33
     7a6:	0f b6       	in	r0, 0x3f	; 63
     7a8:	f8 94       	cli
     7aa:	de bf       	out	0x3e, r29	; 62
     7ac:	0f be       	out	0x3f, r0	; 63
     7ae:	cd bf       	out	0x3d, r28	; 61
     7b0:	df 91       	pop	r29
     7b2:	cf 91       	pop	r28
     7b4:	1f 91       	pop	r17
     7b6:	0f 91       	pop	r16
     7b8:	bf 90       	pop	r11
     7ba:	af 90       	pop	r10
     7bc:	9f 90       	pop	r9
     7be:	8f 90       	pop	r8
     7c0:	08 95       	ret
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:217

  do {
    char c = n % base;
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
     7c2:	e9 5c       	subi	r30, 0xC9	; 201
     7c4:	e1 cf       	rjmp	.-62     	; 0x788 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]+0x4a>

000007c6 <Print::println(char const*) [clone .constprop.47]>:
_ZN5Print7printlnEPKc.constprop.47():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:138
  size_t n = print(s);
  n += println();
  return n;
}

size_t Print::println(const char c[])
     7c6:	cf 93       	push	r28
     7c8:	df 93       	push	r29
write():
     7ca:	0e 94 92 03 	call	0x724	; 0x724 <Print::write(char const*) [clone .part.2] [clone .constprop.50]>
     7ce:	ec 01       	movw	r28, r24
     7d0:	89 e1       	ldi	r24, 0x19	; 25
     7d2:	91 e0       	ldi	r25, 0x01	; 1
     7d4:	0e 94 92 03 	call	0x724	; 0x724 <Print::write(char const*) [clone .part.2] [clone .constprop.50]>
_ZN5Print7printlnEPKc.constprop.47():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:143
{
  size_t n = print(c);
  n += println();
  return n;
}
     7d8:	8c 0f       	add	r24, r28
     7da:	9d 1f       	adc	r25, r29
     7dc:	df 91       	pop	r29
     7de:	cf 91       	pop	r28
     7e0:	08 95       	ret

000007e2 <Print::print(char const*) [clone .constprop.42]>:
_ZN5Print5printEPKc.constprop.42():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:62
size_t Print::print(const String &s)
{
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
     7e2:	0c 94 92 03 	jmp	0x724	; 0x724 <Print::write(char const*) [clone .part.2] [clone .constprop.50]>

000007e6 <VisualMicroDebug::breakWait(unsigned char) [clone .constprop.38]>:
_ZN16VisualMicroDebug9breakWaitEh.constprop.38():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1288

#if defined(VM_DBT) //&& ( VM_DBT == VM_DBT_HARDWARESERIAL || VM_DBT == VM_DBT_FASTSERIAL)
//TODO: implement sturcture serial com!
//we never get called if break was not set during compliation
//return _vm_cmd so that we can setVariable if required (caller needs to know result)
uint8_t VisualMicroDebug::breakWait(uint8_t breakPointId)
     7e6:	cf 93       	push	r28
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1295
	//console write not working yet
#if defined(VM_DBT) && (VM_DBT == VM_DBT_NET_CONSOLE)
	return 'c';
#endif

	if (!alwaysBreak)
     7e8:	90 91 e9 02 	lds	r25, 0x02E9	; 0x8002e9 <MicroDebug+0x16>
     7ec:	99 23       	and	r25, r25
     7ee:	f1 f1       	breq	.+124    	; 0x86c <VisualMicroDebug::breakWait(unsigned char) [clone .constprop.38]+0x86>
     7f0:	c8 2f       	mov	r28, r24
available():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1270
#elif defined(VMDGB_HAS_READER)
	b = reader->available();
#elif defined(VM_DBT) && (VM_DBT == VM_DBT_SOFTWARESERIAL)
	b = transport->available();
#else
	b = VM_DEBUGGER_SOFT_TRANSPORT.available();
     7f2:	86 e3       	ldi	r24, 0x36	; 54
     7f4:	92 e0       	ldi	r25, 0x02	; 2
     7f6:	0e 94 31 01 	call	0x262	; 0x262 <HardwareSerial::available()>
_ZN16VisualMicroDebug9breakWaitEh.constprop.38():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1311
#endif

	uint8_t b;

	//break/pause until we get a command
	if (available() == 0)
     7fa:	81 11       	cpse	r24, r1
     7fc:	09 c0       	rjmp	.+18     	; 0x810 <VisualMicroDebug::breakWait(unsigned char) [clone .constprop.38]+0x2a>
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1330
		if (!UDPConnectionStarted) {
			return 'c';
		}
#endif

		return 'e';
     7fe:	85 e6       	ldi	r24, 0x65	; 101
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1437
	//sendContinuedACK(breakPointId);
	//return 'c'; //if we get here we are continuing!

	//	return '?'; //software serial rubbish detected?
	return 'e';
}
     800:	cf 91       	pop	r28
     802:	08 95       	ret
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1382
		//		while(VM_DEBUGGER_SOFT_TRANSPORT.available()>0)
		//		{
		//			b = VM_DEBUGGER_SOFT_TRANSPORT.read();
		//#endif
		//debug break commands
		switch (b)
     804:	21 37       	cpi	r18, 0x71	; 113
     806:	31 05       	cpc	r19, r1
     808:	89 f1       	breq	.+98     	; 0x86c <VisualMicroDebug::breakWait(unsigned char) [clone .constprop.38]+0x86>
     80a:	26 37       	cpi	r18, 0x76	; 118
     80c:	31 05       	cpc	r19, r1
     80e:	c1 f3       	breq	.-16     	; 0x800 <VisualMicroDebug::breakWait(unsigned char) [clone .constprop.38]+0x1a>
available():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1270
#elif defined(VMDGB_HAS_READER)
	b = reader->available();
#elif defined(VM_DBT) && (VM_DBT == VM_DBT_SOFTWARESERIAL)
	b = transport->available();
#else
	b = VM_DEBUGGER_SOFT_TRANSPORT.available();
     810:	86 e3       	ldi	r24, 0x36	; 54
     812:	92 e0       	ldi	r25, 0x02	; 2
     814:	0e 94 31 01 	call	0x262	; 0x262 <HardwareSerial::available()>
_ZN16VisualMicroDebug9breakWaitEh.constprop.38():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1364
	//doh!  better if we have any key to continue so users data doesn't get lost so much. 
	//NOTE. pause/breakpoints are best used with dedicated port!
	//while(true)
	//{

	while (available() > 0)
     818:	88 23       	and	r24, r24
     81a:	89 f3       	breq	.-30     	; 0x7fe <VisualMicroDebug::breakWait(unsigned char) [clone .constprop.38]+0x18>
read():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1222
#elif defined(VMDGB_HAS_READER)
	b = reader->getchar();
#elif defined(VM_DBT) && (VM_DBT == VM_DBT_SOFTWARESERIAL)
	b = transport->read();
#else
	b = VM_DEBUGGER_SOFT_TRANSPORT.read();
     81c:	86 e3       	ldi	r24, 0x36	; 54
     81e:	92 e0       	ldi	r25, 0x02	; 2
     820:	0e 94 0f 01 	call	0x21e	; 0x21e <HardwareSerial::read()>
_ZN16VisualMicroDebug9breakWaitEh.constprop.38():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1382
		//		while(VM_DEBUGGER_SOFT_TRANSPORT.available()>0)
		//		{
		//			b = VM_DEBUGGER_SOFT_TRANSPORT.read();
		//#endif
		//debug break commands
		switch (b)
     824:	9c 01       	movw	r18, r24
     826:	33 27       	eor	r19, r19
     828:	28 36       	cpi	r18, 0x68	; 104
     82a:	31 05       	cpc	r19, r1
     82c:	f9 f0       	breq	.+62     	; 0x86c <VisualMicroDebug::breakWait(unsigned char) [clone .constprop.38]+0x86>
     82e:	54 f7       	brge	.-44     	; 0x804 <VisualMicroDebug::breakWait(unsigned char) [clone .constprop.38]+0x1e>
     830:	28 35       	cpi	r18, 0x58	; 88
     832:	31 05       	cpc	r19, r1
     834:	e9 f0       	breq	.+58     	; 0x870 <VisualMicroDebug::breakWait(unsigned char) [clone .constprop.38]+0x8a>
     836:	23 36       	cpi	r18, 0x63	; 99
     838:	31 05       	cpc	r19, r1
     83a:	51 f7       	brne	.-44     	; 0x810 <VisualMicroDebug::breakWait(unsigned char) [clone .constprop.38]+0x2a>
sendContinuedACK():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1443
#endif


void VisualMicroDebug::sendContinuedACK(uint8_t breakPointId)
{
	outPacketStart(true);
     83c:	81 e0       	ldi	r24, 0x01	; 1
     83e:	0e 94 bd 02 	call	0x57a	; 0x57a <VisualMicroDebug::outPacketStart(bool) [clone .constprop.41]>
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1464

		//1501 - split into two because cosa doesn't support println(str)
		transport->println("_VMDPC");
	}
#else 
	VM_DEBUGGER_SOFT_TRANSPORT.print("VMDPC_");
     842:	8c e1       	ldi	r24, 0x1C	; 28
     844:	91 e0       	ldi	r25, 0x01	; 1
     846:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <Print::print(char const*) [clone .constprop.42]>
print():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:74
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long) b, base);
     84a:	6c 2f       	mov	r22, r28
     84c:	70 e0       	ldi	r23, 0x00	; 0
     84e:	90 e0       	ldi	r25, 0x00	; 0
     850:	80 e0       	ldi	r24, 0x00	; 0
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:106
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
     852:	4a e0       	ldi	r20, 0x0A	; 10
     854:	0e 94 9f 03 	call	0x73e	; 0x73e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]>
sendContinuedACK():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1469
	//todo: arduino early versions prior to 1.0 will not convert this number in the same way
	VM_DEBUGGER_SOFT_TRANSPORT.print(breakPointId);

	//1501 - split into two because cosa doesn't support println(str)
	VM_DEBUGGER_SOFT_TRANSPORT.println("_VMDPC");
     858:	83 e2       	ldi	r24, 0x23	; 35
     85a:	91 e0       	ldi	r25, 0x01	; 1
     85c:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <Print::println(char const*) [clone .constprop.47]>
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1485
	//	VM_DEBUGGER_SOFT_TRANSPORT.flush();
	//#endif

		//nb: 2560 looses some chars of 2nd and third print statements after startup. todo: look into this!
		//the following delay seems to sort it out sometimes!
	DBG_YieldAndWait(50);
     860:	62 e3       	ldi	r22, 0x32	; 50
     862:	70 e0       	ldi	r23, 0x00	; 0
     864:	80 e0       	ldi	r24, 0x00	; 0
     866:	90 e0       	ldi	r25, 0x00	; 0
     868:	0e 94 bb 02 	call	0x576	; 0x576 <VisualMicroDebug::DBG_YieldAndWait(unsigned long) [clone .constprop.51]>
_ZN16VisualMicroDebug9breakWaitEh.constprop.38():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1411
		case 'h':
			//Serial.println("Remote debug session started");
#if defined(VM_DBT) && (VM_DBT == VM_DBT_NET_UDP)
			alwaysBreak = true;
#endif
			return 'c';
     86c:	83 e6       	ldi	r24, 0x63	; 99
     86e:	c8 cf       	rjmp	.-112    	; 0x800 <VisualMicroDebug::breakWait(unsigned char) [clone .constprop.38]+0x1a>
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1401
					  //	sendContinuedACK(breakPointId);
					  //	return;

					  //switch off break until re-start. for dev/testing
		case 'X':
			alwaysBreak = false;
     870:	10 92 e9 02 	sts	0x02E9, r1	; 0x8002e9 <MicroDebug+0x16>
     874:	fb cf       	rjmp	.-10     	; 0x86c <VisualMicroDebug::breakWait(unsigned char) [clone .constprop.38]+0x86>

00000876 <VisualMicroDebug::OnBreakPointPrintBegin(unsigned char) [clone .constprop.34]>:
_ZN16VisualMicroDebug22OnBreakPointPrintBeginEh.constprop.34():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:242
			read();
		}
	}
}

void VisualMicroDebug::OnBreakPointPrintBegin(uint8_t breakpoint_id)
     876:	cf 92       	push	r12
     878:	df 92       	push	r13
     87a:	ef 92       	push	r14
     87c:	ff 92       	push	r15
     87e:	cf 93       	push	r28
     880:	df 93       	push	r29
     882:	c8 2f       	mov	r28, r24
DBG_Millis():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:172
	return RTT::millis();
}
#else
unsigned long VisualMicroDebug::DBG_Millis()
{
	return millis();
     884:	0e 94 88 02 	call	0x510	; 0x510 <millis>
     888:	6b 01       	movw	r12, r22
     88a:	7c 01       	movw	r14, r24
_ZN16VisualMicroDebug22OnBreakPointPrintBeginEh.constprop.34():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:270
	transport->print(":");
	//millis since last bp was hit
	transport->print((BreakStartMillis - BreakPrevMillis));

#else
	VM_DEBUGGER_SOFT_TRANSPORT.print("VMDPE_");
     88c:	8a e2       	ldi	r24, 0x2A	; 42
     88e:	91 e0       	ldi	r25, 0x01	; 1
     890:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <Print::print(char const*) [clone .constprop.42]>
print():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:74
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long) b, base);
     894:	6c 2f       	mov	r22, r28
     896:	70 e0       	ldi	r23, 0x00	; 0
     898:	90 e0       	ldi	r25, 0x00	; 0
     89a:	80 e0       	ldi	r24, 0x00	; 0
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:106
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
     89c:	4a e0       	ldi	r20, 0x0A	; 10
     89e:	0e 94 9f 03 	call	0x73e	; 0x73e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]>
_ZN16VisualMicroDebug22OnBreakPointPrintBeginEh.constprop.34():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:272
	VM_DEBUGGER_SOFT_TRANSPORT.print(breakpoint_id);
	VM_DEBUGGER_SOFT_TRANSPORT.print(":2:"); //header ver 2: start and last times are millis-val to reduce transmition data size
     8a2:	81 e3       	ldi	r24, 0x31	; 49
     8a4:	91 e0       	ldi	r25, 0x01	; 1
     8a6:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <Print::print(char const*) [clone .constprop.42]>
print():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:106
     8aa:	4a e0       	ldi	r20, 0x0A	; 10
     8ac:	c7 01       	movw	r24, r14
     8ae:	b6 01       	movw	r22, r12
     8b0:	0e 94 9f 03 	call	0x73e	; 0x73e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]>
_ZN16VisualMicroDebug22OnBreakPointPrintBeginEh.constprop.34():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:274
	VM_DEBUGGER_SOFT_TRANSPORT.print(m);
	VM_DEBUGGER_SOFT_TRANSPORT.print(":");
     8b4:	83 e3       	ldi	r24, 0x33	; 51
     8b6:	91 e0       	ldi	r25, 0x01	; 1
     8b8:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <Print::print(char const*) [clone .constprop.42]>
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:276
	//millis less time this point started
	VM_DEBUGGER_SOFT_TRANSPORT.print((m - BreakStartMillis));
     8bc:	c3 ed       	ldi	r28, 0xD3	; 211
     8be:	d2 e0       	ldi	r29, 0x02	; 2
     8c0:	8e 81       	ldd	r24, Y+6	; 0x06
     8c2:	9f 81       	ldd	r25, Y+7	; 0x07
     8c4:	a8 85       	ldd	r26, Y+8	; 0x08
     8c6:	b9 85       	ldd	r27, Y+9	; 0x09
     8c8:	a7 01       	movw	r20, r14
     8ca:	96 01       	movw	r18, r12
     8cc:	28 1b       	sub	r18, r24
     8ce:	39 0b       	sbc	r19, r25
     8d0:	4a 0b       	sbc	r20, r26
     8d2:	5b 0b       	sbc	r21, r27
     8d4:	ca 01       	movw	r24, r20
     8d6:	b9 01       	movw	r22, r18
print():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:106
     8d8:	4a e0       	ldi	r20, 0x0A	; 10
     8da:	0e 94 9f 03 	call	0x73e	; 0x73e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]>
_ZN16VisualMicroDebug22OnBreakPointPrintBeginEh.constprop.34():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:277
	VM_DEBUGGER_SOFT_TRANSPORT.print(":");
     8de:	83 e3       	ldi	r24, 0x33	; 51
     8e0:	91 e0       	ldi	r25, 0x01	; 1
     8e2:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <Print::print(char const*) [clone .constprop.42]>
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:279
	//millis since last bp was hit
	VM_DEBUGGER_SOFT_TRANSPORT.print((BreakStartMillis - BreakPrevMillis));
     8e6:	6e 81       	ldd	r22, Y+6	; 0x06
     8e8:	7f 81       	ldd	r23, Y+7	; 0x07
     8ea:	88 85       	ldd	r24, Y+8	; 0x08
     8ec:	99 85       	ldd	r25, Y+9	; 0x09
     8ee:	ca 84       	ldd	r12, Y+10	; 0x0a
     8f0:	db 84       	ldd	r13, Y+11	; 0x0b
     8f2:	ec 84       	ldd	r14, Y+12	; 0x0c
     8f4:	fd 84       	ldd	r15, Y+13	; 0x0d
     8f6:	6c 19       	sub	r22, r12
     8f8:	7d 09       	sbc	r23, r13
     8fa:	8e 09       	sbc	r24, r14
     8fc:	9f 09       	sbc	r25, r15
print():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:106
     8fe:	4a e0       	ldi	r20, 0x0A	; 10
_ZN16VisualMicroDebug22OnBreakPointPrintBeginEh.constprop.34():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:281
#endif
}
     900:	df 91       	pop	r29
     902:	cf 91       	pop	r28
     904:	ff 90       	pop	r15
     906:	ef 90       	pop	r14
     908:	df 90       	pop	r13
     90a:	cf 90       	pop	r12
print():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:106
     90c:	0c 94 9f 03 	jmp	0x73e	; 0x73e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]>

00000910 <VisualMicroDebug::printFreeMemory() [clone .constprop.19]>:
_ZN16VisualMicroDebug15printFreeMemoryEv.constprop.19():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1640
*/



#if (VM_DEBUG_MEM_CHECK == VM_DEBUG_ENABLE)
void VisualMicroDebug::printFreeMemory()
     910:	cf 92       	push	r12
     912:	df 92       	push	r13
     914:	ef 92       	push	r14
     916:	ff 92       	push	r15
     918:	cf 93       	push	r28
     91a:	df 93       	push	r29
     91c:	00 d0       	rcall	.+0      	; 0x91e <VisualMicroDebug::printFreeMemory() [clone .constprop.19]+0xe>
     91e:	cd b7       	in	r28, 0x3d	; 61
     920:	de b7       	in	r29, 0x3e	; 62
_VM_freeMemory():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_mem_check.c:51
}

int _VM_freeMemory() {
	int free_memory;

	if ((int)__brkval == 0) {
     922:	20 91 19 03 	lds	r18, 0x0319	; 0x800319 <__brkval>
     926:	30 91 1a 03 	lds	r19, 0x031A	; 0x80031a <__brkval+0x1>
     92a:	ce 01       	movw	r24, r28
     92c:	01 96       	adiw	r24, 0x01	; 1
     92e:	21 15       	cp	r18, r1
     930:	31 05       	cpc	r19, r1
     932:	39 f5       	brne	.+78     	; 0x982 <VisualMicroDebug::printFreeMemory() [clone .constprop.19]+0x72>
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_mem_check.c:52
		free_memory = ((int)&free_memory) - ((int)&__heap_start);
     934:	8d 51       	subi	r24, 0x1D	; 29
     936:	93 40       	sbci	r25, 0x03	; 3
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_mem_check.c:56
	}
	else {
		free_memory = ((int)&free_memory) - ((int)__brkval);
		free_memory += _VM_freeListSize();
     938:	9a 83       	std	Y+2, r25	; 0x02
     93a:	89 83       	std	Y+1, r24	; 0x01
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_mem_check.c:58
	}
	return free_memory;
     93c:	c9 80       	ldd	r12, Y+1	; 0x01
     93e:	da 80       	ldd	r13, Y+2	; 0x02
print():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:79
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
{
  return print((long) n, base);
     940:	0d 2c       	mov	r0, r13
     942:	00 0c       	add	r0, r0
     944:	ee 08       	sbc	r14, r14
     946:	ff 08       	sbc	r15, r15
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:97
    if (n < 0) {
      int t = print('-');
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
     948:	4a e0       	ldi	r20, 0x0A	; 10
     94a:	c7 01       	movw	r24, r14
     94c:	b6 01       	movw	r22, r12
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:92
size_t Print::print(long n, int base)
{
  if (base == 0) {
    return write(n);
  } else if (base == 10) {
    if (n < 0) {
     94e:	f7 fe       	sbrs	r15, 7
     950:	0d c0       	rjmp	.+26     	; 0x96c <VisualMicroDebug::printFreeMemory() [clone .constprop.19]+0x5c>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:69
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
     952:	6d e2       	ldi	r22, 0x2D	; 45
     954:	86 e3       	ldi	r24, 0x36	; 54
     956:	92 e0       	ldi	r25, 0x02	; 2
     958:	0e 94 76 01 	call	0x2ec	; 0x2ec <HardwareSerial::write(unsigned char)>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:94
  if (base == 0) {
    return write(n);
  } else if (base == 10) {
    if (n < 0) {
      int t = print('-');
      n = -n;
     95c:	66 27       	eor	r22, r22
     95e:	77 27       	eor	r23, r23
     960:	cb 01       	movw	r24, r22
     962:	6c 19       	sub	r22, r12
     964:	7d 09       	sbc	r23, r13
     966:	8e 09       	sbc	r24, r14
     968:	9f 09       	sbc	r25, r15
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:95
      return printNumber(n, 10) + t;
     96a:	4a e0       	ldi	r20, 0x0A	; 10
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:97
    }
    return printNumber(n, 10);
     96c:	0e 94 9f 03 	call	0x73e	; 0x73e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]>
_ZN16VisualMicroDebug15printFreeMemoryEv.constprop.19():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1647
#if defined(VM_DBT) && (VM_DBT == VM_DBT_SOFTWARESERIAL)
	transport->print(_VM_freeMemory());
#else
	VM_DEBUGGER_SOFT_TRANSPORT.print(_VM_freeMemory());
#endif
}
     970:	0f 90       	pop	r0
     972:	0f 90       	pop	r0
     974:	df 91       	pop	r29
     976:	cf 91       	pop	r28
     978:	ff 90       	pop	r15
     97a:	ef 90       	pop	r14
     97c:	df 90       	pop	r13
     97e:	cf 90       	pop	r12
     980:	08 95       	ret
_VM_freeMemory():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_mem_check.c:55

	if ((int)__brkval == 0) {
		free_memory = ((int)&free_memory) - ((int)&__heap_start);
	}
	else {
		free_memory = ((int)&free_memory) - ((int)__brkval);
     982:	82 1b       	sub	r24, r18
     984:	93 0b       	sbc	r25, r19
_VM_freeListSize():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_mem_check.c:40
/* Calculates the size of the free list */
int _VM_freeListSize() {
	struct __freelist* current;
	int total = 0;

	for (current = __flp; current; current = current->nx) {
     986:	e0 91 1b 03 	lds	r30, 0x031B	; 0x80031b <__flp>
     98a:	f0 91 1c 03 	lds	r31, 0x031C	; 0x80031c <__flp+0x1>
_ZN16VisualMicroDebug15printFreeMemoryEv.constprop.19():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_mem_check.c:38
#include "VM_mem_check.h"

/* Calculates the size of the free list */
int _VM_freeListSize() {
	struct __freelist* current;
	int total = 0;
     98e:	30 e0       	ldi	r19, 0x00	; 0
     990:	20 e0       	ldi	r18, 0x00	; 0
_VM_freeListSize():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_mem_check.c:40

	for (current = __flp; current; current = current->nx) {
     992:	30 97       	sbiw	r30, 0x00	; 0
     994:	19 f4       	brne	.+6      	; 0x99c <VisualMicroDebug::printFreeMemory() [clone .constprop.19]+0x8c>
_VM_freeMemory():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_mem_check.c:56
	if ((int)__brkval == 0) {
		free_memory = ((int)&free_memory) - ((int)&__heap_start);
	}
	else {
		free_memory = ((int)&free_memory) - ((int)__brkval);
		free_memory += _VM_freeListSize();
     996:	82 0f       	add	r24, r18
     998:	93 1f       	adc	r25, r19
     99a:	ce cf       	rjmp	.-100    	; 0x938 <VisualMicroDebug::printFreeMemory() [clone .constprop.19]+0x28>
_VM_freeListSize():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_mem_check.c:41
int _VM_freeListSize() {
	struct __freelist* current;
	int total = 0;

	for (current = __flp; current; current = current->nx) {
		total += 2; /* Add two bytes for the memory block's header  */
     99c:	2e 5f       	subi	r18, 0xFE	; 254
     99e:	3f 4f       	sbci	r19, 0xFF	; 255
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_mem_check.c:42
		total += (int)current->sz;
     9a0:	40 81       	ld	r20, Z
     9a2:	51 81       	ldd	r21, Z+1	; 0x01
     9a4:	24 0f       	add	r18, r20
     9a6:	35 1f       	adc	r19, r21
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_mem_check.c:40
/* Calculates the size of the free list */
int _VM_freeListSize() {
	struct __freelist* current;
	int total = 0;

	for (current = __flp; current; current = current->nx) {
     9a8:	02 80       	ldd	r0, Z+2	; 0x02
     9aa:	f3 81       	ldd	r31, Z+3	; 0x03
     9ac:	e0 2d       	mov	r30, r0
     9ae:	f1 cf       	rjmp	.-30     	; 0x992 <VisualMicroDebug::printFreeMemory() [clone .constprop.19]+0x82>

000009b0 <loop>:
loop():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:37
}

void loop()
{
  // put your main code here, to run repeatedly
}
     9b0:	cf 92       	push	r12
     9b2:	df 92       	push	r13
     9b4:	ef 92       	push	r14
     9b6:	ff 92       	push	r15
     9b8:	cf 93       	push	r28
     9ba:	df 93       	push	r29
     9bc:	0e 94 88 02 	call	0x510	; 0x510 <millis>
     9c0:	c0 90 a6 01 	lds	r12, 0x01A6	; 0x8001a6 <_VM_AUTO_REPORT_LAST_MS_>
     9c4:	d0 90 a7 01 	lds	r13, 0x01A7	; 0x8001a7 <_VM_AUTO_REPORT_LAST_MS_+0x1>
     9c8:	e0 90 a8 01 	lds	r14, 0x01A8	; 0x8001a8 <_VM_AUTO_REPORT_LAST_MS_+0x2>
     9cc:	f0 90 a9 01 	lds	r15, 0x01A9	; 0x8001a9 <_VM_AUTO_REPORT_LAST_MS_+0x3>
     9d0:	6c 19       	sub	r22, r12
     9d2:	7d 09       	sbc	r23, r13
     9d4:	8e 09       	sbc	r24, r14
     9d6:	9f 09       	sbc	r25, r15
     9d8:	66 39       	cpi	r22, 0x96	; 150
     9da:	71 05       	cpc	r23, r1
     9dc:	81 05       	cpc	r24, r1
     9de:	91 05       	cpc	r25, r1
     9e0:	08 f4       	brcc	.+2      	; 0x9e4 <loop+0x34>
     9e2:	75 c0       	rjmp	.+234    	; 0xace <loop+0x11e>
DBG_Millis():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:172
	return RTT::millis();
}
#else
unsigned long VisualMicroDebug::DBG_Millis()
{
	return millis();
     9e4:	0e 94 88 02 	call	0x510	; 0x510 <millis>
loop():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:37
     9e8:	60 93 a6 01 	sts	0x01A6, r22	; 0x8001a6 <_VM_AUTO_REPORT_LAST_MS_>
     9ec:	70 93 a7 01 	sts	0x01A7, r23	; 0x8001a7 <_VM_AUTO_REPORT_LAST_MS_+0x1>
     9f0:	80 93 a8 01 	sts	0x01A8, r24	; 0x8001a8 <_VM_AUTO_REPORT_LAST_MS_+0x2>
     9f4:	90 93 a9 01 	sts	0x01A9, r25	; 0x8001a9 <_VM_AUTO_REPORT_LAST_MS_+0x3>
     9f8:	61 e0       	ldi	r22, 0x01	; 1
     9fa:	70 e0       	ldi	r23, 0x00	; 0
     9fc:	80 e0       	ldi	r24, 0x00	; 0
     9fe:	90 e0       	ldi	r25, 0x00	; 0
     a00:	0e 94 bb 02 	call	0x576	; 0x576 <VisualMicroDebug::DBG_YieldAndWait(unsigned long) [clone .constprop.51]>
DBG_Millis():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:172
     a04:	0e 94 88 02 	call	0x510	; 0x510 <millis>
outPacketStart():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:351
			//DBG_YieldAndWait(3)
		//}
	}
	//XXX: this should really be after packet end!
	//1501 for cosa - lastPacketMS=millis();
	lastPacketMS = DBG_Millis();
     a08:	60 93 d5 02 	sts	0x02D5, r22	; 0x8002d5 <MicroDebug+0x2>
     a0c:	70 93 d6 02 	sts	0x02D6, r23	; 0x8002d6 <MicroDebug+0x3>
     a10:	80 93 d7 02 	sts	0x02D7, r24	; 0x8002d7 <MicroDebug+0x4>
     a14:	90 93 d8 02 	sts	0x02D8, r25	; 0x8002d8 <MicroDebug+0x5>
loop():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:37
     a18:	85 e3       	ldi	r24, 0x35	; 53
     a1a:	91 e0       	ldi	r25, 0x01	; 1
     a1c:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <Print::print(char const*) [clone .constprop.42]>
     a20:	8c e3       	ldi	r24, 0x3C	; 60
     a22:	91 e0       	ldi	r25, 0x01	; 1
     a24:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <Print::print(char const*) [clone .constprop.42]>
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1536

void VisualMicroDebug::printPortsDigital()
{
	uint32_t i;
	unsigned char pByte = 0;
	unsigned char bitCounter = 0;
     a28:	d0 e0       	ldi	r29, 0x00	; 0
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1535
#if VM_DEBUG_READ_DIGITAL_PORTS == VM_DEBUG_ENABLE 

void VisualMicroDebug::printPortsDigital()
{
	uint32_t i;
	unsigned char pByte = 0;
     a2a:	c0 e0       	ldi	r28, 0x00	; 0
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1539
	unsigned char bitCounter = 0;
	uint32_t v = 0;
	bool state;
	for (i = 0; i < TOTAL_DIGITAL_PINS; i++)
     a2c:	c1 2c       	mov	r12, r1
     a2e:	d1 2c       	mov	r13, r1
     a30:	76 01       	movw	r14, r12
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1541
	{
		state = false;
     a32:	20 e0       	ldi	r18, 0x00	; 0
     a34:	0c c0       	rjmp	.+24     	; 0xa4e <loop+0x9e>
printPortsDigital():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1543
		//don't bother with hardware serial
		if (i > 1)
     a36:	21 e0       	ldi	r18, 0x01	; 1
     a38:	c2 16       	cp	r12, r18
     a3a:	d1 04       	cpc	r13, r1
     a3c:	e1 04       	cpc	r14, r1
     a3e:	f1 04       	cpc	r15, r1
     a40:	c1 f3       	breq	.-16     	; 0xa32 <loop+0x82>
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1545
		{
			v = digitalRead(i);
     a42:	8c 2d       	mov	r24, r12
     a44:	0e 94 0c 02 	call	0x418	; 0x418 <digitalRead>
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1546
			if (v > 0)
     a48:	21 e0       	ldi	r18, 0x01	; 1
     a4a:	89 2b       	or	r24, r25
     a4c:	91 f3       	breq	.-28     	; 0xa32 <loop+0x82>
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1551
				state = true;
			else state = false;
		}

		pByte |= (state << bitCounter);
     a4e:	82 2f       	mov	r24, r18
     a50:	0d 2e       	mov	r0, r29
     a52:	01 c0       	rjmp	.+2      	; 0xa56 <loop+0xa6>
     a54:	88 0f       	add	r24, r24
     a56:	0a 94       	dec	r0
     a58:	ea f7       	brpl	.-6      	; 0xa54 <loop+0xa4>
     a5a:	c8 2b       	or	r28, r24
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1553

		bitCounter++;
     a5c:	df 5f       	subi	r29, 0xFF	; 255
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1555
		//NEXT BYTE
		if (bitCounter == 8 || i == TOTAL_DIGITAL_PINS - 1)
     a5e:	d8 30       	cpi	r29, 0x08	; 8
     a60:	31 f0       	breq	.+12     	; 0xa6e <loop+0xbe>
     a62:	3d e0       	ldi	r19, 0x0D	; 13
     a64:	c3 16       	cp	r12, r19
     a66:	d1 04       	cpc	r13, r1
     a68:	e1 04       	cpc	r14, r1
     a6a:	f1 04       	cpc	r15, r1
     a6c:	69 f4       	brne	.+26     	; 0xa88 <loop+0xd8>
print():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:74
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long) b, base);
     a6e:	6c 2f       	mov	r22, r28
     a70:	70 e0       	ldi	r23, 0x00	; 0
     a72:	90 e0       	ldi	r25, 0x00	; 0
     a74:	80 e0       	ldi	r24, 0x00	; 0
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:106
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
     a76:	4a e0       	ldi	r20, 0x0A	; 10
     a78:	0e 94 9f 03 	call	0x73e	; 0x73e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]>
printPortsDigital():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1563
#if defined(VM_DBT) && (VM_DBT == VM_DBT_SOFTWARESERIAL)
			transport->print(pByte);
			transport->print(":");
#else
			VM_DEBUGGER_SOFT_TRANSPORT.print(pByte);
			VM_DEBUGGER_SOFT_TRANSPORT.print(":");
     a7c:	83 e3       	ldi	r24, 0x33	; 51
     a7e:	91 e0       	ldi	r25, 0x01	; 1
     a80:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <Print::print(char const*) [clone .constprop.42]>
loop():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1565
#endif
			bitCounter = 0;
     a84:	d0 e0       	ldi	r29, 0x00	; 0
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1566
			pByte = 0;
     a86:	c0 e0       	ldi	r28, 0x00	; 0
printPortsDigital():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1570
		}


		DBG_YieldAndWait(1);
     a88:	61 e0       	ldi	r22, 0x01	; 1
     a8a:	70 e0       	ldi	r23, 0x00	; 0
     a8c:	80 e0       	ldi	r24, 0x00	; 0
     a8e:	90 e0       	ldi	r25, 0x00	; 0
     a90:	0e 94 bb 02 	call	0x576	; 0x576 <VisualMicroDebug::DBG_YieldAndWait(unsigned long) [clone .constprop.51]>
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1539
	uint32_t i;
	unsigned char pByte = 0;
	unsigned char bitCounter = 0;
	uint32_t v = 0;
	bool state;
	for (i = 0; i < TOTAL_DIGITAL_PINS; i++)
     a94:	4f ef       	ldi	r20, 0xFF	; 255
     a96:	c4 1a       	sub	r12, r20
     a98:	d4 0a       	sbc	r13, r20
     a9a:	e4 0a       	sbc	r14, r20
     a9c:	f4 0a       	sbc	r15, r20
     a9e:	5e e0       	ldi	r21, 0x0E	; 14
     aa0:	c5 16       	cp	r12, r21
     aa2:	d1 04       	cpc	r13, r1
     aa4:	e1 04       	cpc	r14, r1
     aa6:	f1 04       	cpc	r15, r1
     aa8:	31 f6       	brne	.-116    	; 0xa36 <loop+0x86>
loop():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:37
     aaa:	8c e3       	ldi	r24, 0x3C	; 60
     aac:	91 e0       	ldi	r25, 0x01	; 1
     aae:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <Print::print(char const*) [clone .constprop.42]>
     ab2:	8c e3       	ldi	r24, 0x3C	; 60
     ab4:	91 e0       	ldi	r25, 0x01	; 1
     ab6:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <Print::print(char const*) [clone .constprop.42]>
     aba:	0e 94 88 04 	call	0x910	; 0x910 <VisualMicroDebug::printFreeMemory() [clone .constprop.19]>
     abe:	8c e3       	ldi	r24, 0x3C	; 60
     ac0:	91 e0       	ldi	r25, 0x01	; 1
     ac2:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <Print::print(char const*) [clone .constprop.42]>
     ac6:	8e e3       	ldi	r24, 0x3E	; 62
     ac8:	91 e0       	ldi	r25, 0x01	; 1
     aca:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <Print::print(char const*) [clone .constprop.42]>
     ace:	0e 94 88 02 	call	0x510	; 0x510 <millis>
     ad2:	67 2b       	or	r22, r23
     ad4:	68 2b       	or	r22, r24
     ad6:	69 2b       	or	r22, r25
     ad8:	09 f4       	brne	.+2      	; 0xadc <loop+0x12c>
     ada:	58 c0       	rjmp	.+176    	; 0xb8c <loop+0x1dc>
DBG_Millis():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:172
	return RTT::millis();
}
#else
unsigned long VisualMicroDebug::DBG_Millis()
{
	return millis();
     adc:	0e 94 88 02 	call	0x510	; 0x510 <millis>
loop():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:37
     ae0:	c0 90 a2 01 	lds	r12, 0x01A2	; 0x8001a2 <__VisualMicro_DEBUG_1_HITCOUNTER__>
     ae4:	d0 90 a3 01 	lds	r13, 0x01A3	; 0x8001a3 <__VisualMicro_DEBUG_1_HITCOUNTER__+0x1>
     ae8:	e0 90 a4 01 	lds	r14, 0x01A4	; 0x8001a4 <__VisualMicro_DEBUG_1_HITCOUNTER__+0x2>
     aec:	f0 90 a5 01 	lds	r15, 0x01A5	; 0x8001a5 <__VisualMicro_DEBUG_1_HITCOUNTER__+0x3>
     af0:	6c 15       	cp	r22, r12
     af2:	7d 05       	cpc	r23, r13
     af4:	8e 05       	cpc	r24, r14
     af6:	9f 05       	cpc	r25, r15
     af8:	08 f4       	brcc	.+2      	; 0xafc <loop+0x14c>
     afa:	57 c0       	rjmp	.+174    	; 0xbaa <loop+0x1fa>
     afc:	c0 90 a2 01 	lds	r12, 0x01A2	; 0x8001a2 <__VisualMicro_DEBUG_1_HITCOUNTER__>
     b00:	d0 90 a3 01 	lds	r13, 0x01A3	; 0x8001a3 <__VisualMicro_DEBUG_1_HITCOUNTER__+0x1>
     b04:	e0 90 a4 01 	lds	r14, 0x01A4	; 0x8001a4 <__VisualMicro_DEBUG_1_HITCOUNTER__+0x2>
     b08:	f0 90 a5 01 	lds	r15, 0x01A5	; 0x8001a5 <__VisualMicro_DEBUG_1_HITCOUNTER__+0x3>
     b0c:	9b 01       	movw	r18, r22
     b0e:	ac 01       	movw	r20, r24
     b10:	2c 19       	sub	r18, r12
     b12:	3d 09       	sbc	r19, r13
     b14:	4e 09       	sbc	r20, r14
     b16:	5f 09       	sbc	r21, r15
     b18:	69 01       	movw	r12, r18
     b1a:	7a 01       	movw	r14, r20
     b1c:	3a ef       	ldi	r19, 0xFA	; 250
     b1e:	c3 16       	cp	r12, r19
     b20:	d1 04       	cpc	r13, r1
     b22:	e1 04       	cpc	r14, r1
     b24:	f1 04       	cpc	r15, r1
     b26:	d0 f1       	brcs	.+116    	; 0xb9c <loop+0x1ec>
     b28:	60 93 a2 01 	sts	0x01A2, r22	; 0x8001a2 <__VisualMicro_DEBUG_1_HITCOUNTER__>
     b2c:	70 93 a3 01 	sts	0x01A3, r23	; 0x8001a3 <__VisualMicro_DEBUG_1_HITCOUNTER__+0x1>
     b30:	80 93 a4 01 	sts	0x01A4, r24	; 0x8001a4 <__VisualMicro_DEBUG_1_HITCOUNTER__+0x2>
     b34:	90 93 a5 01 	sts	0x01A5, r25	; 0x8001a5 <__VisualMicro_DEBUG_1_HITCOUNTER__+0x3>
     b38:	0e 94 48 03 	call	0x690	; 0x690 <VisualMicroDebug::OnBreakPointBegin(unsigned long) [clone .constprop.33]>
DBG_Millis():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:172
     b3c:	0e 94 88 02 	call	0x510	; 0x510 <millis>
outPacketStart():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:351
			//DBG_YieldAndWait(3)
		//}
	}
	//XXX: this should really be after packet end!
	//1501 for cosa - lastPacketMS=millis();
	lastPacketMS = DBG_Millis();
     b40:	60 93 d5 02 	sts	0x02D5, r22	; 0x8002d5 <MicroDebug+0x2>
     b44:	70 93 d6 02 	sts	0x02D6, r23	; 0x8002d6 <MicroDebug+0x3>
     b48:	80 93 d7 02 	sts	0x02D7, r24	; 0x8002d7 <MicroDebug+0x4>
     b4c:	90 93 d8 02 	sts	0x02D8, r25	; 0x8002d8 <MicroDebug+0x5>
loop():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:37
     b50:	81 e0       	ldi	r24, 0x01	; 1
     b52:	0e 94 3b 04 	call	0x876	; 0x876 <VisualMicroDebug::OnBreakPointPrintBegin(unsigned char) [clone .constprop.34]>
     b56:	8c e3       	ldi	r24, 0x3C	; 60
     b58:	91 e0       	ldi	r25, 0x01	; 1
     b5a:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <Print::print(char const*) [clone .constprop.42]>
     b5e:	0e 94 88 02 	call	0x510	; 0x510 <millis>
print():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:106
     b62:	4a e0       	ldi	r20, 0x0A	; 10
     b64:	0e 94 9f 03 	call	0x73e	; 0x73e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]>
OnBreakPointPrintEnd():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:295
	if (RemoteIP[0] != 0)
	{
		transport->println("_VMDPE");
	}
#else
	VM_DEBUGGER_SOFT_TRANSPORT.println("_VMDPE");
     b68:	86 e4       	ldi	r24, 0x46	; 70
     b6a:	91 e0       	ldi	r25, 0x01	; 1
     b6c:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <Print::println(char const*) [clone .constprop.47]>
loop():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:37
     b70:	65 e0       	ldi	r22, 0x05	; 5
     b72:	70 e0       	ldi	r23, 0x00	; 0
     b74:	80 e0       	ldi	r24, 0x00	; 0
     b76:	90 e0       	ldi	r25, 0x00	; 0
     b78:	0e 94 bb 02 	call	0x576	; 0x576 <VisualMicroDebug::DBG_YieldAndWait(unsigned long) [clone .constprop.51]>
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:40

void vInputTask1(void *pvParameters)
{
     b7c:	df 91       	pop	r29
     b7e:	cf 91       	pop	r28
     b80:	ff 90       	pop	r15
     b82:	ef 90       	pop	r14
     b84:	df 90       	pop	r13
     b86:	cf 90       	pop	r12
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:37
}

void loop()
{
  // put your main code here, to run repeatedly
}
     b88:	0c 94 7f 03 	jmp	0x6fe	; 0x6fe <VisualMicroDebug::OnBreakPointEnd() [clone .constprop.53]>
     b8c:	0e 94 88 02 	call	0x510	; 0x510 <millis>
     b90:	62 30       	cpi	r22, 0x02	; 2
     b92:	71 05       	cpc	r23, r1
     b94:	81 05       	cpc	r24, r1
     b96:	91 05       	cpc	r25, r1
     b98:	08 f0       	brcs	.+2      	; 0xb9c <loop+0x1ec>
     b9a:	a0 cf       	rjmp	.-192    	; 0xadc <loop+0x12c>
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:40

void vInputTask1(void *pvParameters)
{
     b9c:	df 91       	pop	r29
     b9e:	cf 91       	pop	r28
     ba0:	ff 90       	pop	r15
     ba2:	ef 90       	pop	r14
     ba4:	df 90       	pop	r13
     ba6:	cf 90       	pop	r12
     ba8:	08 95       	ret
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:37
}

void loop()
{
  // put your main code here, to run repeatedly
}
     baa:	60 93 a2 01 	sts	0x01A2, r22	; 0x8001a2 <__VisualMicro_DEBUG_1_HITCOUNTER__>
     bae:	70 93 a3 01 	sts	0x01A3, r23	; 0x8001a3 <__VisualMicro_DEBUG_1_HITCOUNTER__+0x1>
     bb2:	80 93 a4 01 	sts	0x01A4, r24	; 0x8001a4 <__VisualMicro_DEBUG_1_HITCOUNTER__+0x2>
     bb6:	90 93 a5 01 	sts	0x01A5, r25	; 0x8001a5 <__VisualMicro_DEBUG_1_HITCOUNTER__+0x3>
     bba:	a0 cf       	rjmp	.-192    	; 0xafc <loop+0x14c>

00000bbc <vInputTask3(void*)>:
_Z11vInputTask3Pv():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:64
	while(true)
	{
		xEventGroupSetBits(xEventGroup, TASK3_BIT);
		vTaskDelay(xDelay500ms);	
	}
}
     bbc:	64 e0       	ldi	r22, 0x04	; 4
     bbe:	70 e0       	ldi	r23, 0x00	; 0
     bc0:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <xEventGroup>
     bc4:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <xEventGroup+0x1>
     bc8:	0e 94 bd 10 	call	0x217a	; 0x217a <xEventGroupSetBits>
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:65

     bcc:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <vTaskDelay.constprop.57>
     bd0:	f5 cf       	rjmp	.-22     	; 0xbbc <vInputTask3(void*)>

00000bd2 <vInputTask2(void*)>:
_Z11vInputTask2Pv():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:55
	while(true)
	{
		xEventGroupSetBits(xEventGroup, TASK2_BIT);
		vTaskDelay(xDelay500ms);	
	}
}
     bd2:	62 e0       	ldi	r22, 0x02	; 2
     bd4:	70 e0       	ldi	r23, 0x00	; 0
     bd6:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <xEventGroup>
     bda:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <xEventGroup+0x1>
     bde:	0e 94 bd 10 	call	0x217a	; 0x217a <xEventGroupSetBits>
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:56

     be2:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <vTaskDelay.constprop.57>
     be6:	f5 cf       	rjmp	.-22     	; 0xbd2 <vInputTask2(void*)>

00000be8 <vInputTask1(void*)>:
_Z11vInputTask1Pv():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:46
	while(true)
	{
		xEventGroupSetBits(xEventGroup, TASK1_BIT);	
		vTaskDelay(xDelay500ms);
	}
}
     be8:	61 e0       	ldi	r22, 0x01	; 1
     bea:	70 e0       	ldi	r23, 0x00	; 0
     bec:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <xEventGroup>
     bf0:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <xEventGroup+0x1>
     bf4:	0e 94 bd 10 	call	0x217a	; 0x217a <xEventGroupSetBits>
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:47

     bf8:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <vTaskDelay.constprop.57>
     bfc:	f5 cf       	rjmp	.-22     	; 0xbe8 <vInputTask1(void*)>

00000bfe <vOutputTask(void*)>:
_Z11vOutputTaskPv():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:71
void vOutputTask(void *pvParameters)
{
	const EventBits_t xBitsToWaitFor = (TASK1_BIT | TASK2_BIT | TASK3_BIT);
	EventBits_t xEventGroupValue;
	
	while (true)
     bfe:	0e 94 48 03 	call	0x690	; 0x690 <VisualMicroDebug::OnBreakPointBegin(unsigned long) [clone .constprop.33]>
     c02:	65 e0       	ldi	r22, 0x05	; 5
     c04:	70 e0       	ldi	r23, 0x00	; 0
     c06:	80 e0       	ldi	r24, 0x00	; 0
     c08:	90 e0       	ldi	r25, 0x00	; 0
     c0a:	0e 94 bb 02 	call	0x576	; 0x576 <VisualMicroDebug::DBG_YieldAndWait(unsigned long) [clone .constprop.51]>
     c0e:	6a e0       	ldi	r22, 0x0A	; 10
     c10:	70 e0       	ldi	r23, 0x00	; 0
     c12:	80 e0       	ldi	r24, 0x00	; 0
     c14:	90 e0       	ldi	r25, 0x00	; 0
     c16:	0e 94 bb 02 	call	0x576	; 0x576 <VisualMicroDebug::DBG_YieldAndWait(unsigned long) [clone .constprop.51]>
     c1a:	85 e6       	ldi	r24, 0x65	; 101
     c1c:	80 93 ea 02 	sts	0x02EA, r24	; 0x8002ea <MicroDebug+0x17>
     c20:	80 91 ea 02 	lds	r24, 0x02EA	; 0x8002ea <MicroDebug+0x17>
     c24:	83 36       	cpi	r24, 0x63	; 99
     c26:	09 f4       	brne	.+2      	; 0xc2a <vOutputTask(void*)+0x2c>
     c28:	4d c0       	rjmp	.+154    	; 0xcc4 <vOutputTask(void*)+0xc6>
     c2a:	85 36       	cpi	r24, 0x65	; 101
     c2c:	09 f0       	breq	.+2      	; 0xc30 <vOutputTask(void*)+0x32>
     c2e:	40 c0       	rjmp	.+128    	; 0xcb0 <vOutputTask(void*)+0xb2>
     c30:	80 91 e5 02 	lds	r24, 0x02E5	; 0x8002e5 <MicroDebug+0x12>
     c34:	90 91 e6 02 	lds	r25, 0x02E6	; 0x8002e6 <MicroDebug+0x13>
     c38:	a0 91 e7 02 	lds	r26, 0x02E7	; 0x8002e7 <MicroDebug+0x14>
     c3c:	b0 91 e8 02 	lds	r27, 0x02E8	; 0x8002e8 <MicroDebug+0x15>
     c40:	01 96       	adiw	r24, 0x01	; 1
     c42:	a1 1d       	adc	r26, r1
     c44:	b1 1d       	adc	r27, r1
     c46:	80 93 e5 02 	sts	0x02E5, r24	; 0x8002e5 <MicroDebug+0x12>
     c4a:	90 93 e6 02 	sts	0x02E6, r25	; 0x8002e6 <MicroDebug+0x13>
     c4e:	a0 93 e7 02 	sts	0x02E7, r26	; 0x8002e7 <MicroDebug+0x14>
     c52:	b0 93 e8 02 	sts	0x02E8, r27	; 0x8002e8 <MicroDebug+0x15>
     c56:	40 91 e1 02 	lds	r20, 0x02E1	; 0x8002e1 <MicroDebug+0xe>
     c5a:	50 91 e2 02 	lds	r21, 0x02E2	; 0x8002e2 <MicroDebug+0xf>
     c5e:	60 91 e3 02 	lds	r22, 0x02E3	; 0x8002e3 <MicroDebug+0x10>
     c62:	70 91 e4 02 	lds	r23, 0x02E4	; 0x8002e4 <MicroDebug+0x11>
     c66:	45 2b       	or	r20, r21
     c68:	46 2b       	or	r20, r22
     c6a:	47 2b       	or	r20, r23
     c6c:	21 f4       	brne	.+8      	; 0xc76 <vOutputTask(void*)+0x78>
     c6e:	89 2b       	or	r24, r25
     c70:	8a 2b       	or	r24, r26
     c72:	8b 2b       	or	r24, r27
     c74:	e9 f4       	brne	.+58     	; 0xcb0 <vOutputTask(void*)+0xb2>
     c76:	80 e0       	ldi	r24, 0x00	; 0
     c78:	0e 94 bd 02 	call	0x57a	; 0x57a <VisualMicroDebug::outPacketStart(bool) [clone .constprop.41]>
     c7c:	88 23       	and	r24, r24
     c7e:	91 f0       	breq	.+36     	; 0xca4 <vOutputTask(void*)+0xa6>
     c80:	86 e0       	ldi	r24, 0x06	; 6
     c82:	0e 94 3b 04 	call	0x876	; 0x876 <VisualMicroDebug::OnBreakPointPrintBegin(unsigned char) [clone .constprop.34]>
     c86:	8c e3       	ldi	r24, 0x3C	; 60
     c88:	91 e0       	ldi	r25, 0x01	; 1
     c8a:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <Print::print(char const*) [clone .constprop.42]>
print():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:106
     c8e:	4a e0       	ldi	r20, 0x0A	; 10
     c90:	67 e0       	ldi	r22, 0x07	; 7
     c92:	70 e0       	ldi	r23, 0x00	; 0
     c94:	80 e0       	ldi	r24, 0x00	; 0
     c96:	90 e0       	ldi	r25, 0x00	; 0
     c98:	0e 94 9f 03 	call	0x73e	; 0x73e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]>
OnBreakPointPrintEnd():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:295
     c9c:	86 e4       	ldi	r24, 0x46	; 70
     c9e:	91 e0       	ldi	r25, 0x01	; 1
     ca0:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <Print::println(char const*) [clone .constprop.47]>
_Z11vOutputTaskPv():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:71
     ca4:	64 ef       	ldi	r22, 0xF4	; 244
     ca6:	71 e0       	ldi	r23, 0x01	; 1
     ca8:	80 e0       	ldi	r24, 0x00	; 0
     caa:	90 e0       	ldi	r25, 0x00	; 0
     cac:	0e 94 94 02 	call	0x528	; 0x528 <VisualMicroDebug::DBG_YieldAndWait(unsigned long, bool) [clone .constprop.52]>
     cb0:	6a e0       	ldi	r22, 0x0A	; 10
     cb2:	70 e0       	ldi	r23, 0x00	; 0
     cb4:	80 e0       	ldi	r24, 0x00	; 0
     cb6:	90 e0       	ldi	r25, 0x00	; 0
     cb8:	0e 94 bb 02 	call	0x576	; 0x576 <VisualMicroDebug::DBG_YieldAndWait(unsigned long) [clone .constprop.51]>
     cbc:	86 e0       	ldi	r24, 0x06	; 6
     cbe:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <VisualMicroDebug::breakWait(unsigned char) [clone .constprop.38]>
     cc2:	ac cf       	rjmp	.-168    	; 0xc1c <vOutputTask(void*)+0x1e>
     cc4:	0e 94 7f 03 	call	0x6fe	; 0x6fe <VisualMicroDebug::OnBreakPointEnd() [clone .constprop.53]>
vTaskPlaceOnUnorderedEventList():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3115
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     cc8:	97 e0       	ldi	r25, 0x07	; 7
     cca:	89 2e       	mov	r8, r25
     ccc:	95 e8       	ldi	r25, 0x85	; 133
     cce:	99 2e       	mov	r9, r25
uxTaskResetEventItemValue():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:4658

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     cd0:	04 e0       	ldi	r16, 0x04	; 4
     cd2:	10 e0       	ldi	r17, 0x00	; 0
_Z11vOutputTaskPv():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:76
	{
		xEventGroupValue = xEventGroupWaitBits(xEventGroup, xBitsToWaitFor, pdTRUE, pdTRUE, portMAX_DELAY);
		
		if((xEventGroupValue & TASK1_BIT) !=0)
		{
     cd4:	25 e6       	ldi	r18, 0x65	; 101
     cd6:	b2 2e       	mov	r11, r18
     cd8:	c0 91 aa 01 	lds	r28, 0x01AA	; 0x8001aa <xEventGroup>
     cdc:	d0 91 ab 01 	lds	r29, 0x01AB	; 0x8001ab <xEventGroup+0x1>
xEventGroupWaitBits():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:337
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
     ce0:	0e 94 17 0b 	call	0x162e	; 0x162e <vTaskSuspendAll>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:339
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     ce4:	c8 80       	ld	r12, Y
     ce6:	d9 80       	ldd	r13, Y+1	; 0x01
prvTestWaitCondition():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:709
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     ce8:	c6 01       	movw	r24, r12
     cea:	87 70       	andi	r24, 0x07	; 7
     cec:	99 27       	eor	r25, r25
     cee:	07 97       	sbiw	r24, 0x07	; 7
     cf0:	09 f4       	brne	.+2      	; 0xcf4 <vOutputTask(void*)+0xf6>
     cf2:	d5 c0       	rjmp	.+426    	; 0xe9e <vOutputTask(void*)+0x2a0>
vTaskPlaceOnUnorderedEventList():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3115
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     cf4:	e0 91 9e 01 	lds	r30, 0x019E	; 0x80019e <__data_end>
     cf8:	f0 91 9f 01 	lds	r31, 0x019F	; 0x80019f <__data_end+0x1>
     cfc:	95 86       	std	Z+13, r9	; 0x0d
     cfe:	84 86       	std	Z+12, r8	; 0x0c
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3122
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     d00:	eb 81       	ldd	r30, Y+3	; 0x03
     d02:	fc 81       	ldd	r31, Y+4	; 0x04
     d04:	a0 91 9e 01 	lds	r26, 0x019E	; 0x80019e <__data_end>
     d08:	b0 91 9f 01 	lds	r27, 0x019F	; 0x80019f <__data_end+0x1>
     d0c:	1f 96       	adiw	r26, 0x0f	; 15
     d0e:	fc 93       	st	X, r31
     d10:	ee 93       	st	-X, r30
     d12:	1e 97       	sbiw	r26, 0x0e	; 14
     d14:	a0 91 9e 01 	lds	r26, 0x019E	; 0x80019e <__data_end>
     d18:	b0 91 9f 01 	lds	r27, 0x019F	; 0x80019f <__data_end+0x1>
     d1c:	84 81       	ldd	r24, Z+4	; 0x04
     d1e:	95 81       	ldd	r25, Z+5	; 0x05
     d20:	51 96       	adiw	r26, 0x11	; 17
     d22:	9c 93       	st	X, r25
     d24:	8e 93       	st	-X, r24
     d26:	50 97       	sbiw	r26, 0x10	; 16
     d28:	80 91 9e 01 	lds	r24, 0x019E	; 0x80019e <__data_end>
     d2c:	90 91 9f 01 	lds	r25, 0x019F	; 0x80019f <__data_end+0x1>
     d30:	a4 81       	ldd	r26, Z+4	; 0x04
     d32:	b5 81       	ldd	r27, Z+5	; 0x05
     d34:	0c 96       	adiw	r24, 0x0c	; 12
     d36:	13 96       	adiw	r26, 0x03	; 3
     d38:	9c 93       	st	X, r25
     d3a:	8e 93       	st	-X, r24
     d3c:	12 97       	sbiw	r26, 0x02	; 2
     d3e:	80 91 9e 01 	lds	r24, 0x019E	; 0x80019e <__data_end>
     d42:	90 91 9f 01 	lds	r25, 0x019F	; 0x80019f <__data_end+0x1>
     d46:	0c 96       	adiw	r24, 0x0c	; 12
     d48:	95 83       	std	Z+5, r25	; 0x05
     d4a:	84 83       	std	Z+4, r24	; 0x04
     d4c:	e0 91 9e 01 	lds	r30, 0x019E	; 0x80019e <__data_end>
     d50:	f0 91 9f 01 	lds	r31, 0x019F	; 0x80019f <__data_end+0x1>
xEventGroupWaitBits():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:395
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     d54:	ce 01       	movw	r24, r28
     d56:	02 96       	adiw	r24, 0x02	; 2
vTaskPlaceOnUnorderedEventList():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3122
     d58:	95 8b       	std	Z+21, r25	; 0x15
     d5a:	84 8b       	std	Z+20, r24	; 0x14
     d5c:	8a 81       	ldd	r24, Y+2	; 0x02
     d5e:	8f 5f       	subi	r24, 0xFF	; 255
     d60:	8a 83       	std	Y+2, r24	; 0x02
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3124

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     d62:	61 e0       	ldi	r22, 0x01	; 1
     d64:	8f ef       	ldi	r24, 0xFF	; 255
     d66:	9f ef       	ldi	r25, 0xFF	; 255
     d68:	0e 94 ee 0b 	call	0x17dc	; 0x17dc <prvAddCurrentTaskToDelayedList>
_Z11vOutputTaskPv():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:400

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
     d6c:	d1 2c       	mov	r13, r1
     d6e:	c1 2c       	mov	r12, r1
vTaskPlaceOnUnorderedEventList():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3124
     d70:	66 24       	eor	r6, r6
     d72:	6a 94       	dec	r6
     d74:	76 2c       	mov	r7, r6
xEventGroupWaitBits():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:405

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
     d76:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <xTaskResumeAll>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:407

    if( xTicksToWait != ( TickType_t ) 0 )
     d7a:	67 28       	or	r6, r7
     d7c:	61 f1       	breq	.+88     	; 0xdd6 <vOutputTask(void*)+0x1d8>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:409
    {
        if( xAlreadyYielded == pdFALSE )
     d7e:	81 11       	cpse	r24, r1
     d80:	02 c0       	rjmp	.+4      	; 0xd86 <vOutputTask(void*)+0x188>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:411
        {
            portYIELD_WITHIN_API();
     d82:	0e 94 7e 0c 	call	0x18fc	; 0x18fc <vPortYield>
uxTaskResetEventItemValue():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:4654

TickType_t uxTaskResetEventItemValue( void )
{
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
     d86:	e0 91 9e 01 	lds	r30, 0x019E	; 0x80019e <__data_end>
     d8a:	f0 91 9f 01 	lds	r31, 0x019F	; 0x80019f <__data_end+0x1>
     d8e:	c4 84       	ldd	r12, Z+12	; 0x0c
     d90:	d5 84       	ldd	r13, Z+13	; 0x0d
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:4658

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     d92:	a0 91 9e 01 	lds	r26, 0x019E	; 0x80019e <__data_end>
     d96:	b0 91 9f 01 	lds	r27, 0x019F	; 0x80019f <__data_end+0x1>
     d9a:	e0 91 9e 01 	lds	r30, 0x019E	; 0x80019e <__data_end>
     d9e:	f0 91 9f 01 	lds	r31, 0x019F	; 0x80019f <__data_end+0x1>
     da2:	56 96       	adiw	r26, 0x16	; 22
     da4:	8c 91       	ld	r24, X
     da6:	98 01       	movw	r18, r16
     da8:	28 1b       	sub	r18, r24
     daa:	31 09       	sbc	r19, r1
     dac:	35 87       	std	Z+13, r19	; 0x0d
     dae:	24 87       	std	Z+12, r18	; 0x0c
xEventGroupWaitBits():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:424
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     db0:	d1 fc       	sbrc	r13, 1
     db2:	10 c0       	rjmp	.+32     	; 0xdd4 <vOutputTask(void*)+0x1d6>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:426
        {
            taskENTER_CRITICAL();
     db4:	0f b6       	in	r0, 0x3f	; 63
     db6:	f8 94       	cli
     db8:	0f 92       	push	r0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:429
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
     dba:	c8 80       	ld	r12, Y
     dbc:	d9 80       	ldd	r13, Y+1	; 0x01
prvTestWaitCondition():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:709
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     dbe:	c6 01       	movw	r24, r12
     dc0:	87 70       	andi	r24, 0x07	; 7
     dc2:	99 27       	eor	r25, r25
     dc4:	07 97       	sbiw	r24, 0x07	; 7
     dc6:	21 f4       	brne	.+8      	; 0xdd0 <vOutputTask(void*)+0x1d2>
xEventGroupWaitBits():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:437
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
                {
                    if( xClearOnExit != pdFALSE )
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     dc8:	c6 01       	movw	r24, r12
     dca:	88 7f       	andi	r24, 0xF8	; 248
     dcc:	99 83       	std	Y+1, r25	; 0x01
     dce:	88 83       	st	Y, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:451
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
            }
            taskEXIT_CRITICAL();
     dd0:	0f 90       	pop	r0
     dd2:	0f be       	out	0x3f, r0	; 63
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:459
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     dd4:	dd 24       	eor	r13, r13
_Z11vOutputTaskPv():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:76
     dd6:	0e 94 48 03 	call	0x690	; 0x690 <VisualMicroDebug::OnBreakPointBegin(unsigned long) [clone .constprop.33]>
     dda:	65 e0       	ldi	r22, 0x05	; 5
     ddc:	70 e0       	ldi	r23, 0x00	; 0
     dde:	80 e0       	ldi	r24, 0x00	; 0
     de0:	90 e0       	ldi	r25, 0x00	; 0
     de2:	0e 94 bb 02 	call	0x576	; 0x576 <VisualMicroDebug::DBG_YieldAndWait(unsigned long) [clone .constprop.51]>
     de6:	6a e0       	ldi	r22, 0x0A	; 10
     de8:	70 e0       	ldi	r23, 0x00	; 0
     dea:	80 e0       	ldi	r24, 0x00	; 0
     dec:	90 e0       	ldi	r25, 0x00	; 0
     dee:	0e 94 bb 02 	call	0x576	; 0x576 <VisualMicroDebug::DBG_YieldAndWait(unsigned long) [clone .constprop.51]>
     df2:	b0 92 ea 02 	sts	0x02EA, r11	; 0x8002ea <MicroDebug+0x17>
print():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:84
  return print((long) n, base);
}

size_t Print::print(unsigned int n, int base)
{
  return print((unsigned long) n, base);
     df6:	26 01       	movw	r4, r12
     df8:	71 2c       	mov	r7, r1
     dfa:	61 2c       	mov	r6, r1
_Z11vOutputTaskPv():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:76
     dfc:	80 91 ea 02 	lds	r24, 0x02EA	; 0x8002ea <MicroDebug+0x17>
     e00:	83 36       	cpi	r24, 0x63	; 99
     e02:	09 f4       	brne	.+2      	; 0xe06 <vOutputTask(void*)+0x208>
     e04:	53 c0       	rjmp	.+166    	; 0xeac <vOutputTask(void*)+0x2ae>
     e06:	85 36       	cpi	r24, 0x65	; 101
     e08:	f1 f5       	brne	.+124    	; 0xe86 <vOutputTask(void*)+0x288>
     e0a:	80 91 e5 02 	lds	r24, 0x02E5	; 0x8002e5 <MicroDebug+0x12>
     e0e:	90 91 e6 02 	lds	r25, 0x02E6	; 0x8002e6 <MicroDebug+0x13>
     e12:	a0 91 e7 02 	lds	r26, 0x02E7	; 0x8002e7 <MicroDebug+0x14>
     e16:	b0 91 e8 02 	lds	r27, 0x02E8	; 0x8002e8 <MicroDebug+0x15>
     e1a:	01 96       	adiw	r24, 0x01	; 1
     e1c:	a1 1d       	adc	r26, r1
     e1e:	b1 1d       	adc	r27, r1
     e20:	80 93 e5 02 	sts	0x02E5, r24	; 0x8002e5 <MicroDebug+0x12>
     e24:	90 93 e6 02 	sts	0x02E6, r25	; 0x8002e6 <MicroDebug+0x13>
     e28:	a0 93 e7 02 	sts	0x02E7, r26	; 0x8002e7 <MicroDebug+0x14>
     e2c:	b0 93 e8 02 	sts	0x02E8, r27	; 0x8002e8 <MicroDebug+0x15>
     e30:	40 91 e1 02 	lds	r20, 0x02E1	; 0x8002e1 <MicroDebug+0xe>
     e34:	50 91 e2 02 	lds	r21, 0x02E2	; 0x8002e2 <MicroDebug+0xf>
     e38:	60 91 e3 02 	lds	r22, 0x02E3	; 0x8002e3 <MicroDebug+0x10>
     e3c:	70 91 e4 02 	lds	r23, 0x02E4	; 0x8002e4 <MicroDebug+0x11>
     e40:	45 2b       	or	r20, r21
     e42:	46 2b       	or	r20, r22
     e44:	47 2b       	or	r20, r23
     e46:	21 f4       	brne	.+8      	; 0xe50 <vOutputTask(void*)+0x252>
     e48:	89 2b       	or	r24, r25
     e4a:	8a 2b       	or	r24, r26
     e4c:	8b 2b       	or	r24, r27
     e4e:	d9 f4       	brne	.+54     	; 0xe86 <vOutputTask(void*)+0x288>
     e50:	80 e0       	ldi	r24, 0x00	; 0
     e52:	0e 94 bd 02 	call	0x57a	; 0x57a <VisualMicroDebug::outPacketStart(bool) [clone .constprop.41]>
     e56:	88 23       	and	r24, r24
     e58:	81 f0       	breq	.+32     	; 0xe7a <vOutputTask(void*)+0x27c>
     e5a:	85 e0       	ldi	r24, 0x05	; 5
     e5c:	0e 94 3b 04 	call	0x876	; 0x876 <VisualMicroDebug::OnBreakPointPrintBegin(unsigned char) [clone .constprop.34]>
     e60:	8c e3       	ldi	r24, 0x3C	; 60
     e62:	91 e0       	ldi	r25, 0x01	; 1
     e64:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <Print::print(char const*) [clone .constprop.42]>
print():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:106
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
     e68:	4a e0       	ldi	r20, 0x0A	; 10
     e6a:	c3 01       	movw	r24, r6
     e6c:	b2 01       	movw	r22, r4
     e6e:	0e 94 9f 03 	call	0x73e	; 0x73e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]>
OnBreakPointPrintEnd():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:295
     e72:	86 e4       	ldi	r24, 0x46	; 70
     e74:	91 e0       	ldi	r25, 0x01	; 1
     e76:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <Print::println(char const*) [clone .constprop.47]>
_Z11vOutputTaskPv():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:76
     e7a:	64 ef       	ldi	r22, 0xF4	; 244
     e7c:	71 e0       	ldi	r23, 0x01	; 1
     e7e:	80 e0       	ldi	r24, 0x00	; 0
     e80:	90 e0       	ldi	r25, 0x00	; 0
     e82:	0e 94 94 02 	call	0x528	; 0x528 <VisualMicroDebug::DBG_YieldAndWait(unsigned long, bool) [clone .constprop.52]>
     e86:	6a e0       	ldi	r22, 0x0A	; 10
     e88:	70 e0       	ldi	r23, 0x00	; 0
     e8a:	80 e0       	ldi	r24, 0x00	; 0
     e8c:	90 e0       	ldi	r25, 0x00	; 0
     e8e:	0e 94 bb 02 	call	0x576	; 0x576 <VisualMicroDebug::DBG_YieldAndWait(unsigned long) [clone .constprop.51]>
     e92:	85 e0       	ldi	r24, 0x05	; 5
     e94:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <VisualMicroDebug::breakWait(unsigned char) [clone .constprop.38]>
     e98:	80 93 ea 02 	sts	0x02EA, r24	; 0x8002ea <MicroDebug+0x17>
     e9c:	af cf       	rjmp	.-162    	; 0xdfc <vOutputTask(void*)+0x1fe>
xEventGroupWaitBits():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:354
            xTicksToWait = ( TickType_t ) 0;

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     e9e:	c6 01       	movw	r24, r12
     ea0:	88 7f       	andi	r24, 0xF8	; 248
     ea2:	99 83       	std	Y+1, r25	; 0x01
     ea4:	88 83       	st	Y, r24
_Z11vOutputTaskPv():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:349
        if( xWaitConditionMet != pdFALSE )
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
            xTicksToWait = ( TickType_t ) 0;
     ea6:	71 2c       	mov	r7, r1
     ea8:	61 2c       	mov	r6, r1
     eaa:	65 cf       	rjmp	.-310    	; 0xd76 <vOutputTask(void*)+0x178>
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:76
     eac:	0e 94 7f 03 	call	0x6fe	; 0x6fe <VisualMicroDebug::OnBreakPointEnd() [clone .constprop.53]>
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:78
			digitalWrite(RED, digitalRead(RED) ^ 1);
		}
     eb0:	c0 fe       	sbrs	r12, 0
     eb2:	6e c0       	rjmp	.+220    	; 0xf90 <vOutputTask(void*)+0x392>
     eb4:	0e 94 48 03 	call	0x690	; 0x690 <VisualMicroDebug::OnBreakPointBegin(unsigned long) [clone .constprop.33]>
     eb8:	65 e0       	ldi	r22, 0x05	; 5
     eba:	70 e0       	ldi	r23, 0x00	; 0
     ebc:	80 e0       	ldi	r24, 0x00	; 0
     ebe:	90 e0       	ldi	r25, 0x00	; 0
     ec0:	0e 94 bb 02 	call	0x576	; 0x576 <VisualMicroDebug::DBG_YieldAndWait(unsigned long) [clone .constprop.51]>
     ec4:	6a e0       	ldi	r22, 0x0A	; 10
     ec6:	70 e0       	ldi	r23, 0x00	; 0
     ec8:	80 e0       	ldi	r24, 0x00	; 0
     eca:	90 e0       	ldi	r25, 0x00	; 0
     ecc:	0e 94 bb 02 	call	0x576	; 0x576 <VisualMicroDebug::DBG_YieldAndWait(unsigned long) [clone .constprop.51]>
     ed0:	b0 92 ea 02 	sts	0x02EA, r11	; 0x8002ea <MicroDebug+0x17>
     ed4:	80 91 ea 02 	lds	r24, 0x02EA	; 0x8002ea <MicroDebug+0x17>
     ed8:	83 36       	cpi	r24, 0x63	; 99
     eda:	09 f4       	brne	.+2      	; 0xede <vOutputTask(void*)+0x2e0>
     edc:	4f c0       	rjmp	.+158    	; 0xf7c <vOutputTask(void*)+0x37e>
     ede:	85 36       	cpi	r24, 0x65	; 101
     ee0:	09 f0       	breq	.+2      	; 0xee4 <vOutputTask(void*)+0x2e6>
     ee2:	40 c0       	rjmp	.+128    	; 0xf64 <vOutputTask(void*)+0x366>
     ee4:	80 91 e5 02 	lds	r24, 0x02E5	; 0x8002e5 <MicroDebug+0x12>
     ee8:	90 91 e6 02 	lds	r25, 0x02E6	; 0x8002e6 <MicroDebug+0x13>
     eec:	a0 91 e7 02 	lds	r26, 0x02E7	; 0x8002e7 <MicroDebug+0x14>
     ef0:	b0 91 e8 02 	lds	r27, 0x02E8	; 0x8002e8 <MicroDebug+0x15>
     ef4:	01 96       	adiw	r24, 0x01	; 1
     ef6:	a1 1d       	adc	r26, r1
     ef8:	b1 1d       	adc	r27, r1
     efa:	80 93 e5 02 	sts	0x02E5, r24	; 0x8002e5 <MicroDebug+0x12>
     efe:	90 93 e6 02 	sts	0x02E6, r25	; 0x8002e6 <MicroDebug+0x13>
     f02:	a0 93 e7 02 	sts	0x02E7, r26	; 0x8002e7 <MicroDebug+0x14>
     f06:	b0 93 e8 02 	sts	0x02E8, r27	; 0x8002e8 <MicroDebug+0x15>
     f0a:	40 91 e1 02 	lds	r20, 0x02E1	; 0x8002e1 <MicroDebug+0xe>
     f0e:	50 91 e2 02 	lds	r21, 0x02E2	; 0x8002e2 <MicroDebug+0xf>
     f12:	60 91 e3 02 	lds	r22, 0x02E3	; 0x8002e3 <MicroDebug+0x10>
     f16:	70 91 e4 02 	lds	r23, 0x02E4	; 0x8002e4 <MicroDebug+0x11>
     f1a:	45 2b       	or	r20, r21
     f1c:	46 2b       	or	r20, r22
     f1e:	47 2b       	or	r20, r23
     f20:	21 f4       	brne	.+8      	; 0xf2a <vOutputTask(void*)+0x32c>
     f22:	89 2b       	or	r24, r25
     f24:	8a 2b       	or	r24, r26
     f26:	8b 2b       	or	r24, r27
     f28:	e9 f4       	brne	.+58     	; 0xf64 <vOutputTask(void*)+0x366>
     f2a:	80 e0       	ldi	r24, 0x00	; 0
     f2c:	0e 94 bd 02 	call	0x57a	; 0x57a <VisualMicroDebug::outPacketStart(bool) [clone .constprop.41]>
     f30:	88 23       	and	r24, r24
     f32:	91 f0       	breq	.+36     	; 0xf58 <vOutputTask(void*)+0x35a>
     f34:	82 e0       	ldi	r24, 0x02	; 2
     f36:	0e 94 3b 04 	call	0x876	; 0x876 <VisualMicroDebug::OnBreakPointPrintBegin(unsigned char) [clone .constprop.34]>
     f3a:	8c e3       	ldi	r24, 0x3C	; 60
     f3c:	91 e0       	ldi	r25, 0x01	; 1
     f3e:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <Print::print(char const*) [clone .constprop.42]>
print():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:106
     f42:	4a e0       	ldi	r20, 0x0A	; 10
     f44:	61 e0       	ldi	r22, 0x01	; 1
     f46:	70 e0       	ldi	r23, 0x00	; 0
     f48:	80 e0       	ldi	r24, 0x00	; 0
     f4a:	90 e0       	ldi	r25, 0x00	; 0
     f4c:	0e 94 9f 03 	call	0x73e	; 0x73e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]>
OnBreakPointPrintEnd():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:295
     f50:	86 e4       	ldi	r24, 0x46	; 70
     f52:	91 e0       	ldi	r25, 0x01	; 1
     f54:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <Print::println(char const*) [clone .constprop.47]>
_Z11vOutputTaskPv():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:78
     f58:	64 ef       	ldi	r22, 0xF4	; 244
     f5a:	71 e0       	ldi	r23, 0x01	; 1
     f5c:	80 e0       	ldi	r24, 0x00	; 0
     f5e:	90 e0       	ldi	r25, 0x00	; 0
     f60:	0e 94 94 02 	call	0x528	; 0x528 <VisualMicroDebug::DBG_YieldAndWait(unsigned long, bool) [clone .constprop.52]>
     f64:	6a e0       	ldi	r22, 0x0A	; 10
     f66:	70 e0       	ldi	r23, 0x00	; 0
     f68:	80 e0       	ldi	r24, 0x00	; 0
     f6a:	90 e0       	ldi	r25, 0x00	; 0
     f6c:	0e 94 bb 02 	call	0x576	; 0x576 <VisualMicroDebug::DBG_YieldAndWait(unsigned long) [clone .constprop.51]>
     f70:	82 e0       	ldi	r24, 0x02	; 2
     f72:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <VisualMicroDebug::breakWait(unsigned char) [clone .constprop.38]>
     f76:	80 93 ea 02 	sts	0x02EA, r24	; 0x8002ea <MicroDebug+0x17>
     f7a:	ac cf       	rjmp	.-168    	; 0xed4 <vOutputTask(void*)+0x2d6>
     f7c:	0e 94 7f 03 	call	0x6fe	; 0x6fe <VisualMicroDebug::OnBreakPointEnd() [clone .constprop.53]>
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:80
		
	    if((xEventGroupValue & TASK2_BIT) != 0)
     f80:	86 e0       	ldi	r24, 0x06	; 6
     f82:	0e 94 0c 02 	call	0x418	; 0x418 <digitalRead>
     f86:	61 e0       	ldi	r22, 0x01	; 1
     f88:	68 27       	eor	r22, r24
     f8a:	86 e0       	ldi	r24, 0x06	; 6
     f8c:	0e 94 35 02 	call	0x46a	; 0x46a <digitalWrite>
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:83
		{
			digitalWrite(YELLOW, digitalRead(YELLOW) ^ 1);
		}
     f90:	c1 fe       	sbrs	r12, 1
     f92:	6e c0       	rjmp	.+220    	; 0x1070 <vOutputTask(void*)+0x472>
     f94:	0e 94 48 03 	call	0x690	; 0x690 <VisualMicroDebug::OnBreakPointBegin(unsigned long) [clone .constprop.33]>
     f98:	65 e0       	ldi	r22, 0x05	; 5
     f9a:	70 e0       	ldi	r23, 0x00	; 0
     f9c:	80 e0       	ldi	r24, 0x00	; 0
     f9e:	90 e0       	ldi	r25, 0x00	; 0
     fa0:	0e 94 bb 02 	call	0x576	; 0x576 <VisualMicroDebug::DBG_YieldAndWait(unsigned long) [clone .constprop.51]>
     fa4:	6a e0       	ldi	r22, 0x0A	; 10
     fa6:	70 e0       	ldi	r23, 0x00	; 0
     fa8:	80 e0       	ldi	r24, 0x00	; 0
     faa:	90 e0       	ldi	r25, 0x00	; 0
     fac:	0e 94 bb 02 	call	0x576	; 0x576 <VisualMicroDebug::DBG_YieldAndWait(unsigned long) [clone .constprop.51]>
     fb0:	b0 92 ea 02 	sts	0x02EA, r11	; 0x8002ea <MicroDebug+0x17>
print():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:84
  return print((long) n, base);
}

size_t Print::print(unsigned int n, int base)
{
  return print((unsigned long) n, base);
     fb4:	26 01       	movw	r4, r12
     fb6:	71 2c       	mov	r7, r1
     fb8:	61 2c       	mov	r6, r1
_Z11vOutputTaskPv():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:83
     fba:	80 91 ea 02 	lds	r24, 0x02EA	; 0x8002ea <MicroDebug+0x17>
     fbe:	83 36       	cpi	r24, 0x63	; 99
     fc0:	09 f4       	brne	.+2      	; 0xfc4 <vOutputTask(void*)+0x3c6>
     fc2:	4c c0       	rjmp	.+152    	; 0x105c <vOutputTask(void*)+0x45e>
     fc4:	85 36       	cpi	r24, 0x65	; 101
     fc6:	f1 f5       	brne	.+124    	; 0x1044 <vOutputTask(void*)+0x446>
     fc8:	80 91 e5 02 	lds	r24, 0x02E5	; 0x8002e5 <MicroDebug+0x12>
     fcc:	90 91 e6 02 	lds	r25, 0x02E6	; 0x8002e6 <MicroDebug+0x13>
     fd0:	a0 91 e7 02 	lds	r26, 0x02E7	; 0x8002e7 <MicroDebug+0x14>
     fd4:	b0 91 e8 02 	lds	r27, 0x02E8	; 0x8002e8 <MicroDebug+0x15>
     fd8:	01 96       	adiw	r24, 0x01	; 1
     fda:	a1 1d       	adc	r26, r1
     fdc:	b1 1d       	adc	r27, r1
     fde:	80 93 e5 02 	sts	0x02E5, r24	; 0x8002e5 <MicroDebug+0x12>
     fe2:	90 93 e6 02 	sts	0x02E6, r25	; 0x8002e6 <MicroDebug+0x13>
     fe6:	a0 93 e7 02 	sts	0x02E7, r26	; 0x8002e7 <MicroDebug+0x14>
     fea:	b0 93 e8 02 	sts	0x02E8, r27	; 0x8002e8 <MicroDebug+0x15>
     fee:	40 91 e1 02 	lds	r20, 0x02E1	; 0x8002e1 <MicroDebug+0xe>
     ff2:	50 91 e2 02 	lds	r21, 0x02E2	; 0x8002e2 <MicroDebug+0xf>
     ff6:	60 91 e3 02 	lds	r22, 0x02E3	; 0x8002e3 <MicroDebug+0x10>
     ffa:	70 91 e4 02 	lds	r23, 0x02E4	; 0x8002e4 <MicroDebug+0x11>
     ffe:	45 2b       	or	r20, r21
    1000:	46 2b       	or	r20, r22
    1002:	47 2b       	or	r20, r23
    1004:	21 f4       	brne	.+8      	; 0x100e <vOutputTask(void*)+0x410>
    1006:	89 2b       	or	r24, r25
    1008:	8a 2b       	or	r24, r26
    100a:	8b 2b       	or	r24, r27
    100c:	d9 f4       	brne	.+54     	; 0x1044 <vOutputTask(void*)+0x446>
    100e:	80 e0       	ldi	r24, 0x00	; 0
    1010:	0e 94 bd 02 	call	0x57a	; 0x57a <VisualMicroDebug::outPacketStart(bool) [clone .constprop.41]>
    1014:	88 23       	and	r24, r24
    1016:	81 f0       	breq	.+32     	; 0x1038 <vOutputTask(void*)+0x43a>
    1018:	84 e0       	ldi	r24, 0x04	; 4
    101a:	0e 94 3b 04 	call	0x876	; 0x876 <VisualMicroDebug::OnBreakPointPrintBegin(unsigned char) [clone .constprop.34]>
    101e:	8c e3       	ldi	r24, 0x3C	; 60
    1020:	91 e0       	ldi	r25, 0x01	; 1
    1022:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <Print::print(char const*) [clone .constprop.42]>
print():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:106
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
    1026:	4a e0       	ldi	r20, 0x0A	; 10
    1028:	c3 01       	movw	r24, r6
    102a:	b2 01       	movw	r22, r4
    102c:	0e 94 9f 03 	call	0x73e	; 0x73e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]>
OnBreakPointPrintEnd():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:295
    1030:	86 e4       	ldi	r24, 0x46	; 70
    1032:	91 e0       	ldi	r25, 0x01	; 1
    1034:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <Print::println(char const*) [clone .constprop.47]>
_Z11vOutputTaskPv():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:83
    1038:	64 ef       	ldi	r22, 0xF4	; 244
    103a:	71 e0       	ldi	r23, 0x01	; 1
    103c:	80 e0       	ldi	r24, 0x00	; 0
    103e:	90 e0       	ldi	r25, 0x00	; 0
    1040:	0e 94 94 02 	call	0x528	; 0x528 <VisualMicroDebug::DBG_YieldAndWait(unsigned long, bool) [clone .constprop.52]>
    1044:	6a e0       	ldi	r22, 0x0A	; 10
    1046:	70 e0       	ldi	r23, 0x00	; 0
    1048:	80 e0       	ldi	r24, 0x00	; 0
    104a:	90 e0       	ldi	r25, 0x00	; 0
    104c:	0e 94 bb 02 	call	0x576	; 0x576 <VisualMicroDebug::DBG_YieldAndWait(unsigned long) [clone .constprop.51]>
    1050:	84 e0       	ldi	r24, 0x04	; 4
    1052:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <VisualMicroDebug::breakWait(unsigned char) [clone .constprop.38]>
    1056:	80 93 ea 02 	sts	0x02EA, r24	; 0x8002ea <MicroDebug+0x17>
    105a:	af cf       	rjmp	.-162    	; 0xfba <vOutputTask(void*)+0x3bc>
    105c:	0e 94 7f 03 	call	0x6fe	; 0x6fe <VisualMicroDebug::OnBreakPointEnd() [clone .constprop.53]>
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:85
		
	    if((xEventGroupValue & TASK3_BIT) != 0)
    1060:	87 e0       	ldi	r24, 0x07	; 7
    1062:	0e 94 0c 02 	call	0x418	; 0x418 <digitalRead>
    1066:	61 e0       	ldi	r22, 0x01	; 1
    1068:	68 27       	eor	r22, r24
    106a:	87 e0       	ldi	r24, 0x07	; 7
    106c:	0e 94 35 02 	call	0x46a	; 0x46a <digitalWrite>
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:88
		{
			digitalWrite(BLUE, digitalRead(BLUE) ^ 1);
		}	
    1070:	c2 fe       	sbrs	r12, 2
    1072:	32 ce       	rjmp	.-924    	; 0xcd8 <vOutputTask(void*)+0xda>
    1074:	0e 94 48 03 	call	0x690	; 0x690 <VisualMicroDebug::OnBreakPointBegin(unsigned long) [clone .constprop.33]>
    1078:	65 e0       	ldi	r22, 0x05	; 5
    107a:	70 e0       	ldi	r23, 0x00	; 0
    107c:	80 e0       	ldi	r24, 0x00	; 0
    107e:	90 e0       	ldi	r25, 0x00	; 0
    1080:	0e 94 bb 02 	call	0x576	; 0x576 <VisualMicroDebug::DBG_YieldAndWait(unsigned long) [clone .constprop.51]>
    1084:	6a e0       	ldi	r22, 0x0A	; 10
    1086:	70 e0       	ldi	r23, 0x00	; 0
    1088:	80 e0       	ldi	r24, 0x00	; 0
    108a:	90 e0       	ldi	r25, 0x00	; 0
    108c:	0e 94 bb 02 	call	0x576	; 0x576 <VisualMicroDebug::DBG_YieldAndWait(unsigned long) [clone .constprop.51]>
    1090:	b0 92 ea 02 	sts	0x02EA, r11	; 0x8002ea <MicroDebug+0x17>
print():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:84
  return print((long) n, base);
}

size_t Print::print(unsigned int n, int base)
{
  return print((unsigned long) n, base);
    1094:	f1 2c       	mov	r15, r1
    1096:	e1 2c       	mov	r14, r1
_Z11vOutputTaskPv():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:88
    1098:	80 91 ea 02 	lds	r24, 0x02EA	; 0x8002ea <MicroDebug+0x17>
    109c:	83 36       	cpi	r24, 0x63	; 99
    109e:	09 f4       	brne	.+2      	; 0x10a2 <vOutputTask(void*)+0x4a4>
    10a0:	4c c0       	rjmp	.+152    	; 0x113a <vOutputTask(void*)+0x53c>
    10a2:	85 36       	cpi	r24, 0x65	; 101
    10a4:	f1 f5       	brne	.+124    	; 0x1122 <vOutputTask(void*)+0x524>
    10a6:	80 91 e5 02 	lds	r24, 0x02E5	; 0x8002e5 <MicroDebug+0x12>
    10aa:	90 91 e6 02 	lds	r25, 0x02E6	; 0x8002e6 <MicroDebug+0x13>
    10ae:	a0 91 e7 02 	lds	r26, 0x02E7	; 0x8002e7 <MicroDebug+0x14>
    10b2:	b0 91 e8 02 	lds	r27, 0x02E8	; 0x8002e8 <MicroDebug+0x15>
    10b6:	01 96       	adiw	r24, 0x01	; 1
    10b8:	a1 1d       	adc	r26, r1
    10ba:	b1 1d       	adc	r27, r1
    10bc:	80 93 e5 02 	sts	0x02E5, r24	; 0x8002e5 <MicroDebug+0x12>
    10c0:	90 93 e6 02 	sts	0x02E6, r25	; 0x8002e6 <MicroDebug+0x13>
    10c4:	a0 93 e7 02 	sts	0x02E7, r26	; 0x8002e7 <MicroDebug+0x14>
    10c8:	b0 93 e8 02 	sts	0x02E8, r27	; 0x8002e8 <MicroDebug+0x15>
    10cc:	40 91 e1 02 	lds	r20, 0x02E1	; 0x8002e1 <MicroDebug+0xe>
    10d0:	50 91 e2 02 	lds	r21, 0x02E2	; 0x8002e2 <MicroDebug+0xf>
    10d4:	60 91 e3 02 	lds	r22, 0x02E3	; 0x8002e3 <MicroDebug+0x10>
    10d8:	70 91 e4 02 	lds	r23, 0x02E4	; 0x8002e4 <MicroDebug+0x11>
    10dc:	45 2b       	or	r20, r21
    10de:	46 2b       	or	r20, r22
    10e0:	47 2b       	or	r20, r23
    10e2:	21 f4       	brne	.+8      	; 0x10ec <vOutputTask(void*)+0x4ee>
    10e4:	89 2b       	or	r24, r25
    10e6:	8a 2b       	or	r24, r26
    10e8:	8b 2b       	or	r24, r27
    10ea:	d9 f4       	brne	.+54     	; 0x1122 <vOutputTask(void*)+0x524>
    10ec:	80 e0       	ldi	r24, 0x00	; 0
    10ee:	0e 94 bd 02 	call	0x57a	; 0x57a <VisualMicroDebug::outPacketStart(bool) [clone .constprop.41]>
    10f2:	88 23       	and	r24, r24
    10f4:	81 f0       	breq	.+32     	; 0x1116 <vOutputTask(void*)+0x518>
    10f6:	83 e0       	ldi	r24, 0x03	; 3
    10f8:	0e 94 3b 04 	call	0x876	; 0x876 <VisualMicroDebug::OnBreakPointPrintBegin(unsigned char) [clone .constprop.34]>
    10fc:	8c e3       	ldi	r24, 0x3C	; 60
    10fe:	91 e0       	ldi	r25, 0x01	; 1
    1100:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <Print::print(char const*) [clone .constprop.42]>
print():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/Print.cpp:106
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
    1104:	4a e0       	ldi	r20, 0x0A	; 10
    1106:	c7 01       	movw	r24, r14
    1108:	b6 01       	movw	r22, r12
    110a:	0e 94 9f 03 	call	0x73e	; 0x73e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]>
OnBreakPointPrintEnd():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:295
    110e:	86 e4       	ldi	r24, 0x46	; 70
    1110:	91 e0       	ldi	r25, 0x01	; 1
    1112:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <Print::println(char const*) [clone .constprop.47]>
_Z11vOutputTaskPv():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:88
    1116:	64 ef       	ldi	r22, 0xF4	; 244
    1118:	71 e0       	ldi	r23, 0x01	; 1
    111a:	80 e0       	ldi	r24, 0x00	; 0
    111c:	90 e0       	ldi	r25, 0x00	; 0
    111e:	0e 94 94 02 	call	0x528	; 0x528 <VisualMicroDebug::DBG_YieldAndWait(unsigned long, bool) [clone .constprop.52]>
    1122:	6a e0       	ldi	r22, 0x0A	; 10
    1124:	70 e0       	ldi	r23, 0x00	; 0
    1126:	80 e0       	ldi	r24, 0x00	; 0
    1128:	90 e0       	ldi	r25, 0x00	; 0
    112a:	0e 94 bb 02 	call	0x576	; 0x576 <VisualMicroDebug::DBG_YieldAndWait(unsigned long) [clone .constprop.51]>
    112e:	83 e0       	ldi	r24, 0x03	; 3
    1130:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <VisualMicroDebug::breakWait(unsigned char) [clone .constprop.38]>
    1134:	80 93 ea 02 	sts	0x02EA, r24	; 0x8002ea <MicroDebug+0x17>
    1138:	af cf       	rjmp	.-162    	; 0x1098 <vOutputTask(void*)+0x49a>
    113a:	0e 94 7f 03 	call	0x6fe	; 0x6fe <VisualMicroDebug::OnBreakPointEnd() [clone .constprop.53]>
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:90
	}
}
    113e:	88 e0       	ldi	r24, 0x08	; 8
    1140:	0e 94 0c 02 	call	0x418	; 0x418 <digitalRead>
    1144:	61 e0       	ldi	r22, 0x01	; 1
    1146:	68 27       	eor	r22, r24
    1148:	88 e0       	ldi	r24, 0x08	; 8
    114a:	0e 94 35 02 	call	0x46a	; 0x46a <digitalWrite>
    114e:	c4 cd       	rjmp	.-1144   	; 0xcd8 <vOutputTask(void*)+0xda>

00001150 <setup>:
setup():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:19
const TickType_t xDelay500ms = pdMS_TO_TICKS(500);

void setup()
{
  // put your setup code here, to run once:
  Serial.begin(9600);
    1150:	8f 92       	push	r8
    1152:	9f 92       	push	r9
    1154:	af 92       	push	r10
    1156:	bf 92       	push	r11
    1158:	cf 92       	push	r12
    115a:	df 92       	push	r13
    115c:	ef 92       	push	r14
    115e:	ff 92       	push	r15
    1160:	0f 93       	push	r16
    1162:	1f 93       	push	r17
    1164:	cf 93       	push	r28
    1166:	df 93       	push	r29
init():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1067
	vmdebug.init();
	vmdebug.stats();
#endif


	baudRate = 0L; //gets a value later if required, only used by cosa for a re-begin!
    1168:	10 92 15 03 	sts	0x0315, r1	; 0x800315 <MicroDebug+0x42>
    116c:	10 92 16 03 	sts	0x0316, r1	; 0x800316 <MicroDebug+0x43>
    1170:	10 92 17 03 	sts	0x0317, r1	; 0x800317 <MicroDebug+0x44>
    1174:	10 92 18 03 	sts	0x0318, r1	; 0x800318 <MicroDebug+0x45>
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1069

	lastPacketMS = 0L;
    1178:	10 92 d5 02 	sts	0x02D5, r1	; 0x8002d5 <MicroDebug+0x2>
    117c:	10 92 d6 02 	sts	0x02D6, r1	; 0x8002d6 <MicroDebug+0x3>
    1180:	10 92 d7 02 	sts	0x02D7, r1	; 0x8002d7 <MicroDebug+0x4>
    1184:	10 92 d8 02 	sts	0x02D8, r1	; 0x8002d8 <MicroDebug+0x5>
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1074

	//note: a delay at start causes esp8266 wifi to fail to connect!!
	//		the delay can also be switched off via board/platform.txt property=
	if (delayMs > 0)
		DBG_YieldAndWait(delayMs);
    1188:	68 eb       	ldi	r22, 0xB8	; 184
    118a:	7b e0       	ldi	r23, 0x0B	; 11
    118c:	80 e0       	ldi	r24, 0x00	; 0
    118e:	90 e0       	ldi	r25, 0x00	; 0
    1190:	0e 94 bb 02 	call	0x576	; 0x576 <VisualMicroDebug::DBG_YieldAndWait(unsigned long) [clone .constprop.51]>
delay():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:108
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
}

void delay(unsigned long ms)
{
	uint32_t start = micros();
    1194:	0e 94 63 02 	call	0x4c6	; 0x4c6 <micros>
    1198:	4b 01       	movw	r8, r22
    119a:	5c 01       	movw	r10, r24
    119c:	88 ee       	ldi	r24, 0xE8	; 232
    119e:	c8 2e       	mov	r12, r24
    11a0:	83 e0       	ldi	r24, 0x03	; 3
    11a2:	d8 2e       	mov	r13, r24
    11a4:	e1 2c       	mov	r14, r1
    11a6:	f1 2c       	mov	r15, r1
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:112

	while (ms > 0) {
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
    11a8:	0e 94 63 02 	call	0x4c6	; 0x4c6 <micros>
    11ac:	68 19       	sub	r22, r8
    11ae:	79 09       	sbc	r23, r9
    11b0:	8a 09       	sbc	r24, r10
    11b2:	9b 09       	sbc	r25, r11
    11b4:	68 3e       	cpi	r22, 0xE8	; 232
    11b6:	73 40       	sbci	r23, 0x03	; 3
    11b8:	81 05       	cpc	r24, r1
    11ba:	91 05       	cpc	r25, r1
    11bc:	a8 f3       	brcs	.-22     	; 0x11a8 <setup+0x58>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:113
			ms--;
    11be:	21 e0       	ldi	r18, 0x01	; 1
    11c0:	c2 1a       	sub	r12, r18
    11c2:	d1 08       	sbc	r13, r1
    11c4:	e1 08       	sbc	r14, r1
    11c6:	f1 08       	sbc	r15, r1
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:114
			start += 1000;
    11c8:	88 ee       	ldi	r24, 0xE8	; 232
    11ca:	88 0e       	add	r8, r24
    11cc:	83 e0       	ldi	r24, 0x03	; 3
    11ce:	98 1e       	adc	r9, r24
    11d0:	a1 1c       	adc	r10, r1
    11d2:	b1 1c       	adc	r11, r1
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:112
{
	uint32_t start = micros();

	while (ms > 0) {
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
    11d4:	c1 14       	cp	r12, r1
    11d6:	d1 04       	cpc	r13, r1
    11d8:	e1 04       	cpc	r14, r1
    11da:	f1 04       	cpc	r15, r1
    11dc:	29 f7       	brne	.-54     	; 0x11a8 <setup+0x58>
begin():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.h:121
  public:
    inline HardwareSerial(
      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
      volatile uint8_t *ucsrc, volatile uint8_t *udr);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
    11de:	0e 94 8c 00 	call	0x118	; 0x118 <HardwareSerial::begin(unsigned long, unsigned char) [clone .constprop.29]>
DBG_Millis():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:172
	return RTT::millis();
}
#else
unsigned long VisualMicroDebug::DBG_Millis()
{
	return millis();
    11e2:	0e 94 88 02 	call	0x510	; 0x510 <millis>
outPacketStart():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:351
			//DBG_YieldAndWait(3)
		//}
	}
	//XXX: this should really be after packet end!
	//1501 for cosa - lastPacketMS=millis();
	lastPacketMS = DBG_Millis();
    11e6:	60 93 d5 02 	sts	0x02D5, r22	; 0x8002d5 <MicroDebug+0x2>
    11ea:	70 93 d6 02 	sts	0x02D6, r23	; 0x8002d6 <MicroDebug+0x3>
    11ee:	80 93 d7 02 	sts	0x02D7, r24	; 0x8002d7 <MicroDebug+0x4>
    11f2:	90 93 d8 02 	sts	0x02D8, r25	; 0x8002d8 <MicroDebug+0x5>
setup():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:19
    11f6:	8d e4       	ldi	r24, 0x4D	; 77
    11f8:	91 e0       	ldi	r25, 0x01	; 1
    11fa:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <Print::print(char const*) [clone .constprop.42]>
    11fe:	6a e0       	ldi	r22, 0x0A	; 10
    1200:	70 e0       	ldi	r23, 0x00	; 0
    1202:	80 e0       	ldi	r24, 0x00	; 0
    1204:	90 e0       	ldi	r25, 0x00	; 0
    1206:	0e 94 bb 02 	call	0x576	; 0x576 <VisualMicroDebug::DBG_YieldAndWait(unsigned long) [clone .constprop.51]>
start():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:1197
		while (breakWait(0) != 'c') {
			DBG_YieldAndWait(1);
		}
		//breakWait(0);
	}
	alwaysBreak = _alwaysBreak;
    120a:	81 e0       	ldi	r24, 0x01	; 1
    120c:	80 93 e9 02 	sts	0x02E9, r24	; 0x8002e9 <MicroDebug+0x16>
DBG_Millis():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:172
	return RTT::millis();
}
#else
unsigned long VisualMicroDebug::DBG_Millis()
{
	return millis();
    1210:	0e 94 88 02 	call	0x510	; 0x510 <millis>
outPacketStart():
C:\Program Files (x86)\Atmel\Studio\7.0\Extensions\snwin3sc.pmp\Micro Platforms\default\debuggers\VM_DBG/VM_DBG.cpp:351
			//DBG_YieldAndWait(3)
		//}
	}
	//XXX: this should really be after packet end!
	//1501 for cosa - lastPacketMS=millis();
	lastPacketMS = DBG_Millis();
    1214:	60 93 d5 02 	sts	0x02D5, r22	; 0x8002d5 <MicroDebug+0x2>
    1218:	70 93 d6 02 	sts	0x02D6, r23	; 0x8002d6 <MicroDebug+0x3>
    121c:	80 93 d7 02 	sts	0x02D7, r24	; 0x8002d7 <MicroDebug+0x4>
    1220:	90 93 d8 02 	sts	0x02D8, r25	; 0x8002d8 <MicroDebug+0x5>
setup():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:19
    1224:	85 e3       	ldi	r24, 0x35	; 53
    1226:	91 e0       	ldi	r25, 0x01	; 1
    1228:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <Print::print(char const*) [clone .constprop.42]>
    122c:	8c e3       	ldi	r24, 0x3C	; 60
    122e:	91 e0       	ldi	r25, 0x01	; 1
    1230:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <Print::print(char const*) [clone .constprop.42]>
    1234:	8c e3       	ldi	r24, 0x3C	; 60
    1236:	91 e0       	ldi	r25, 0x01	; 1
    1238:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <Print::print(char const*) [clone .constprop.42]>
    123c:	8c e3       	ldi	r24, 0x3C	; 60
    123e:	91 e0       	ldi	r25, 0x01	; 1
    1240:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <Print::print(char const*) [clone .constprop.42]>
    1244:	0e 94 88 04 	call	0x910	; 0x910 <VisualMicroDebug::printFreeMemory() [clone .constprop.19]>
    1248:	8c e3       	ldi	r24, 0x3C	; 60
    124a:	91 e0       	ldi	r25, 0x01	; 1
    124c:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <Print::print(char const*) [clone .constprop.42]>
    1250:	8e e3       	ldi	r24, 0x3E	; 62
    1252:	91 e0       	ldi	r25, 0x01	; 1
    1254:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <Print::print(char const*) [clone .constprop.42]>
begin():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.h:121
    1258:	0e 94 8c 00 	call	0x118	; 0x118 <HardwareSerial::begin(unsigned long, unsigned char) [clone .constprop.29]>
setup():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:24

  pinMode(RED, OUTPUT);
  pinMode(YELLOW, OUTPUT);
  pinMode(BLUE, OUTPUT);
  
    125c:	86 e0       	ldi	r24, 0x06	; 6
    125e:	0e 94 b4 00 	call	0x168	; 0x168 <pinMode.constprop.24>
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:25
  xEventGroup = xEventGroupCreate();
    1262:	87 e0       	ldi	r24, 0x07	; 7
    1264:	0e 94 b4 00 	call	0x168	; 0x168 <pinMode.constprop.24>
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:26
  
    1268:	88 e0       	ldi	r24, 0x08	; 8
    126a:	0e 94 b4 00 	call	0x168	; 0x168 <pinMode.constprop.24>
xEventGroupCreate():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:163
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    126e:	8b e0       	ldi	r24, 0x0B	; 11
    1270:	90 e0       	ldi	r25, 0x00	; 0
    1272:	0e 94 84 15 	call	0x2b08	; 0x2b08 <pvPortMalloc>
    1276:	ec 01       	movw	r28, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:165

        if( pxEventBits != NULL )
    1278:	00 97       	sbiw	r24, 0x00	; 0
    127a:	31 f0       	breq	.+12     	; 0x1288 <setup+0x138>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:167
        {
            pxEventBits->uxEventBits = 0;
    127c:	fc 01       	movw	r30, r24
    127e:	11 92       	st	Z+, r1
    1280:	11 92       	st	Z+, r1
    1282:	cf 01       	movw	r24, r30
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:168
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    1284:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <vListInitialise>
setup():
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:28
  xTaskCreate(vInputTask1, "Input Task 1", 100, NULL, 1, NULL);
  xTaskCreate(vInputTask2, "Input Task 2", 100, NULL, 1, NULL);
    1288:	d0 93 ab 01 	sts	0x01AB, r29	; 0x8001ab <xEventGroup+0x1>
    128c:	c0 93 aa 01 	sts	0x01AA, r28	; 0x8001aa <xEventGroup>
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:30
  xTaskCreate(vInputTask3, "Input Task 3", 100, NULL, 1, NULL);
  xTaskCreate(vOutputTask, "Output Task", 100, NULL, 1, NULL);
    1290:	10 e0       	ldi	r17, 0x00	; 0
    1292:	00 e0       	ldi	r16, 0x00	; 0
    1294:	21 e0       	ldi	r18, 0x01	; 1
    1296:	44 e6       	ldi	r20, 0x64	; 100
    1298:	50 e0       	ldi	r21, 0x00	; 0
    129a:	6e e5       	ldi	r22, 0x5E	; 94
    129c:	71 e0       	ldi	r23, 0x01	; 1
    129e:	84 ef       	ldi	r24, 0xF4	; 244
    12a0:	95 e0       	ldi	r25, 0x05	; 5
    12a2:	0e 94 a2 15 	call	0x2b44	; 0x2b44 <xTaskCreate.constprop.25>
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:31
  
    12a6:	21 e0       	ldi	r18, 0x01	; 1
    12a8:	44 e6       	ldi	r20, 0x64	; 100
    12aa:	50 e0       	ldi	r21, 0x00	; 0
    12ac:	6b e6       	ldi	r22, 0x6B	; 107
    12ae:	71 e0       	ldi	r23, 0x01	; 1
    12b0:	89 ee       	ldi	r24, 0xE9	; 233
    12b2:	95 e0       	ldi	r25, 0x05	; 5
    12b4:	0e 94 a2 15 	call	0x2b44	; 0x2b44 <xTaskCreate.constprop.25>
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:32
}
    12b8:	21 e0       	ldi	r18, 0x01	; 1
    12ba:	44 e6       	ldi	r20, 0x64	; 100
    12bc:	50 e0       	ldi	r21, 0x00	; 0
    12be:	68 e7       	ldi	r22, 0x78	; 120
    12c0:	71 e0       	ldi	r23, 0x01	; 1
    12c2:	8e ed       	ldi	r24, 0xDE	; 222
    12c4:	95 e0       	ldi	r25, 0x05	; 5
    12c6:	0e 94 a2 15 	call	0x2b44	; 0x2b44 <xTaskCreate.constprop.25>
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:33

    12ca:	21 e0       	ldi	r18, 0x01	; 1
    12cc:	44 e6       	ldi	r20, 0x64	; 100
    12ce:	50 e0       	ldi	r21, 0x00	; 0
    12d0:	65 e8       	ldi	r22, 0x85	; 133
    12d2:	71 e0       	ldi	r23, 0x01	; 1
    12d4:	8f ef       	ldi	r24, 0xFF	; 255
    12d6:	95 e0       	ldi	r25, 0x05	; 5
    12d8:	0e 94 a2 15 	call	0x2b44	; 0x2b44 <xTaskCreate.constprop.25>
G:\freeRTOS\11_event_groups\event_group_3_tasks/event_group_3_tasks.ino:35
void loop()
{
    12dc:	df 91       	pop	r29
    12de:	cf 91       	pop	r28
    12e0:	1f 91       	pop	r17
    12e2:	0f 91       	pop	r16
    12e4:	ff 90       	pop	r15
    12e6:	ef 90       	pop	r14
    12e8:	df 90       	pop	r13
    12ea:	cf 90       	pop	r12
    12ec:	bf 90       	pop	r11
    12ee:	af 90       	pop	r10
    12f0:	9f 90       	pop	r9
    12f2:	8f 90       	pop	r8
    12f4:	08 95       	ret

000012f6 <__vector_19>:
__vector_19():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial0.cpp:63
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
    12f6:	1f 92       	push	r1
    12f8:	0f 92       	push	r0
    12fa:	0f b6       	in	r0, 0x3f	; 63
    12fc:	0f 92       	push	r0
    12fe:	11 24       	eor	r1, r1
    1300:	2f 93       	push	r18
    1302:	3f 93       	push	r19
    1304:	4f 93       	push	r20
    1306:	5f 93       	push	r21
    1308:	6f 93       	push	r22
    130a:	7f 93       	push	r23
    130c:	8f 93       	push	r24
    130e:	9f 93       	push	r25
    1310:	af 93       	push	r26
    1312:	bf 93       	push	r27
    1314:	ef 93       	push	r30
    1316:	ff 93       	push	r31
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial0.cpp:64
  Serial._tx_udr_empty_irq();
    1318:	86 e3       	ldi	r24, 0x36	; 54
    131a:	92 e0       	ldi	r25, 0x02	; 2
    131c:	0e 94 54 01 	call	0x2a8	; 0x2a8 <HardwareSerial::_tx_udr_empty_irq()>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial0.cpp:65
}
    1320:	ff 91       	pop	r31
    1322:	ef 91       	pop	r30
    1324:	bf 91       	pop	r27
    1326:	af 91       	pop	r26
    1328:	9f 91       	pop	r25
    132a:	8f 91       	pop	r24
    132c:	7f 91       	pop	r23
    132e:	6f 91       	pop	r22
    1330:	5f 91       	pop	r21
    1332:	4f 91       	pop	r20
    1334:	3f 91       	pop	r19
    1336:	2f 91       	pop	r18
    1338:	0f 90       	pop	r0
    133a:	0f be       	out	0x3f, r0	; 63
    133c:	0f 90       	pop	r0
    133e:	1f 90       	pop	r1
    1340:	18 95       	reti

00001342 <__vector_18>:
__vector_18():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial0.cpp:48
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
    1342:	1f 92       	push	r1
    1344:	0f 92       	push	r0
    1346:	0f b6       	in	r0, 0x3f	; 63
    1348:	0f 92       	push	r0
    134a:	11 24       	eor	r1, r1
    134c:	2f 93       	push	r18
    134e:	8f 93       	push	r24
    1350:	9f 93       	push	r25
    1352:	ef 93       	push	r30
    1354:	ff 93       	push	r31
_rx_complete_irq():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial_private.h:103

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
    1356:	e0 91 46 02 	lds	r30, 0x0246	; 0x800246 <Serial+0x10>
    135a:	f0 91 47 02 	lds	r31, 0x0247	; 0x800247 <Serial+0x11>
    135e:	80 81       	ld	r24, Z
    1360:	e0 91 4c 02 	lds	r30, 0x024C	; 0x80024c <Serial+0x16>
    1364:	f0 91 4d 02 	lds	r31, 0x024D	; 0x80024d <Serial+0x17>
    1368:	82 fd       	sbrc	r24, 2
    136a:	1b c0       	rjmp	.+54     	; 0x13a2 <__vector_18+0x60>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial_private.h:106
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
    136c:	90 81       	ld	r25, Z
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial_private.h:107
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
    136e:	80 91 4f 02 	lds	r24, 0x024F	; 0x80024f <Serial+0x19>
    1372:	8f 5f       	subi	r24, 0xFF	; 255
    1374:	8f 73       	andi	r24, 0x3F	; 63
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial_private.h:113

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
    1376:	20 91 50 02 	lds	r18, 0x0250	; 0x800250 <Serial+0x1a>
    137a:	82 17       	cp	r24, r18
    137c:	41 f0       	breq	.+16     	; 0x138e <__vector_18+0x4c>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial_private.h:114
      _rx_buffer[_rx_buffer_head] = c;
    137e:	e0 91 4f 02 	lds	r30, 0x024F	; 0x80024f <Serial+0x19>
    1382:	f0 e0       	ldi	r31, 0x00	; 0
    1384:	ea 5c       	subi	r30, 0xCA	; 202
    1386:	fd 4f       	sbci	r31, 0xFD	; 253
    1388:	95 8f       	std	Z+29, r25	; 0x1d
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial_private.h:115
      _rx_buffer_head = i;
    138a:	80 93 4f 02 	sts	0x024F, r24	; 0x80024f <Serial+0x19>
__vector_18():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial0.cpp:50
    Serial._rx_complete_irq();
  }
    138e:	ff 91       	pop	r31
    1390:	ef 91       	pop	r30
    1392:	9f 91       	pop	r25
    1394:	8f 91       	pop	r24
    1396:	2f 91       	pop	r18
    1398:	0f 90       	pop	r0
    139a:	0f be       	out	0x3f, r0	; 63
    139c:	0f 90       	pop	r0
    139e:	1f 90       	pop	r1
    13a0:	18 95       	reti
_rx_complete_irq():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial_private.h:119
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
    13a2:	80 81       	ld	r24, Z
    13a4:	f4 cf       	rjmp	.-24     	; 0x138e <__vector_18+0x4c>

000013a6 <__vector_16>:
__vector_16():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:47
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
    13a6:	1f 92       	push	r1
    13a8:	0f 92       	push	r0
    13aa:	0f b6       	in	r0, 0x3f	; 63
    13ac:	0f 92       	push	r0
    13ae:	11 24       	eor	r1, r1
    13b0:	2f 93       	push	r18
    13b2:	3f 93       	push	r19
    13b4:	8f 93       	push	r24
    13b6:	9f 93       	push	r25
    13b8:	af 93       	push	r26
    13ba:	bf 93       	push	r27
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:50
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
    13bc:	80 91 b3 01 	lds	r24, 0x01B3	; 0x8001b3 <timer0_millis>
    13c0:	90 91 b4 01 	lds	r25, 0x01B4	; 0x8001b4 <timer0_millis+0x1>
    13c4:	a0 91 b5 01 	lds	r26, 0x01B5	; 0x8001b5 <timer0_millis+0x2>
    13c8:	b0 91 b6 01 	lds	r27, 0x01B6	; 0x8001b6 <timer0_millis+0x3>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:51
	unsigned char f = timer0_fract;
    13cc:	30 91 b2 01 	lds	r19, 0x01B2	; 0x8001b2 <timer0_fract>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:54

	m += MILLIS_INC;
	f += FRACT_INC;
    13d0:	23 e0       	ldi	r18, 0x03	; 3
    13d2:	23 0f       	add	r18, r19
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:55
	if (f >= FRACT_MAX) {
    13d4:	2d 37       	cpi	r18, 0x7D	; 125
    13d6:	58 f5       	brcc	.+86     	; 0x142e <__vector_16+0x88>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:53
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
    13d8:	01 96       	adiw	r24, 0x01	; 1
    13da:	a1 1d       	adc	r26, r1
    13dc:	b1 1d       	adc	r27, r1
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:60
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
		m += 1;
	}

	timer0_fract = f;
    13de:	20 93 b2 01 	sts	0x01B2, r18	; 0x8001b2 <timer0_fract>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:61
	timer0_millis = m;
    13e2:	80 93 b3 01 	sts	0x01B3, r24	; 0x8001b3 <timer0_millis>
    13e6:	90 93 b4 01 	sts	0x01B4, r25	; 0x8001b4 <timer0_millis+0x1>
    13ea:	a0 93 b5 01 	sts	0x01B5, r26	; 0x8001b5 <timer0_millis+0x2>
    13ee:	b0 93 b6 01 	sts	0x01B6, r27	; 0x8001b6 <timer0_millis+0x3>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:62
	timer0_overflow_count++;
    13f2:	80 91 b7 01 	lds	r24, 0x01B7	; 0x8001b7 <timer0_overflow_count>
    13f6:	90 91 b8 01 	lds	r25, 0x01B8	; 0x8001b8 <timer0_overflow_count+0x1>
    13fa:	a0 91 b9 01 	lds	r26, 0x01B9	; 0x8001b9 <timer0_overflow_count+0x2>
    13fe:	b0 91 ba 01 	lds	r27, 0x01BA	; 0x8001ba <timer0_overflow_count+0x3>
    1402:	01 96       	adiw	r24, 0x01	; 1
    1404:	a1 1d       	adc	r26, r1
    1406:	b1 1d       	adc	r27, r1
    1408:	80 93 b7 01 	sts	0x01B7, r24	; 0x8001b7 <timer0_overflow_count>
    140c:	90 93 b8 01 	sts	0x01B8, r25	; 0x8001b8 <timer0_overflow_count+0x1>
    1410:	a0 93 b9 01 	sts	0x01B9, r26	; 0x8001b9 <timer0_overflow_count+0x2>
    1414:	b0 93 ba 01 	sts	0x01BA, r27	; 0x8001ba <timer0_overflow_count+0x3>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:63
}
    1418:	bf 91       	pop	r27
    141a:	af 91       	pop	r26
    141c:	9f 91       	pop	r25
    141e:	8f 91       	pop	r24
    1420:	3f 91       	pop	r19
    1422:	2f 91       	pop	r18
    1424:	0f 90       	pop	r0
    1426:	0f be       	out	0x3f, r0	; 63
    1428:	0f 90       	pop	r0
    142a:	1f 90       	pop	r1
    142c:	18 95       	reti
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:56
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
    142e:	26 e8       	ldi	r18, 0x86	; 134
    1430:	23 0f       	add	r18, r19
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:57
		m += 1;
    1432:	02 96       	adiw	r24, 0x02	; 2
    1434:	a1 1d       	adc	r26, r1
    1436:	b1 1d       	adc	r27, r1
    1438:	d2 cf       	rjmp	.-92     	; 0x13de <__vector_16+0x38>

0000143a <prvResetNextTaskUnblockTime>:
prvResetNextTaskUnblockTime():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3989
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    143a:	e0 91 df 01 	lds	r30, 0x01DF	; 0x8001df <pxDelayedTaskList>
    143e:	f0 91 e0 01 	lds	r31, 0x01E0	; 0x8001e0 <pxDelayedTaskList+0x1>
    1442:	80 81       	ld	r24, Z
    1444:	81 11       	cpse	r24, r1
    1446:	07 c0       	rjmp	.+14     	; 0x1456 <prvResetNextTaskUnblockTime+0x1c>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3995
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    1448:	8f ef       	ldi	r24, 0xFF	; 255
    144a:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:4003
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    144c:	90 93 d4 01 	sts	0x01D4, r25	; 0x8001d4 <xNextTaskUnblockTime+0x1>
    1450:	80 93 d3 01 	sts	0x01D3, r24	; 0x8001d3 <xNextTaskUnblockTime>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:4005
    }
}
    1454:	08 95       	ret
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:4003
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    1456:	e0 91 df 01 	lds	r30, 0x01DF	; 0x8001df <pxDelayedTaskList>
    145a:	f0 91 e0 01 	lds	r31, 0x01E0	; 0x8001e0 <pxDelayedTaskList+0x1>
    145e:	05 80       	ldd	r0, Z+5	; 0x05
    1460:	f6 81       	ldd	r31, Z+6	; 0x06
    1462:	e0 2d       	mov	r30, r0
    1464:	80 81       	ld	r24, Z
    1466:	91 81       	ldd	r25, Z+1	; 0x01
    1468:	f1 cf       	rjmp	.-30     	; 0x144c <prvResetNextTaskUnblockTime+0x12>

0000146a <xTaskCheckForTimeOut>:
xTaskCheckForTimeOut():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3302
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    146a:	fc 01       	movw	r30, r24
    146c:	db 01       	movw	r26, r22
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3308
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    146e:	0f b6       	in	r0, 0x3f	; 63
    1470:	f8 94       	cli
    1472:	0f 92       	push	r0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3311
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    1474:	40 91 da 01 	lds	r20, 0x01DA	; 0x8001da <xTickCount>
    1478:	50 91 db 01 	lds	r21, 0x01DB	; 0x8001db <xTickCount+0x1>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3326
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
    147c:	2d 91       	ld	r18, X+
    147e:	3c 91       	ld	r19, X
    1480:	11 97       	sbiw	r26, 0x01	; 1
    1482:	2f 3f       	cpi	r18, 0xFF	; 255
    1484:	32 07       	cpc	r19, r18
    1486:	11 f1       	breq	.+68     	; 0x14cc <xTaskCheckForTimeOut+0x62>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3312

    taskENTER_CRITICAL();
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1488:	81 81       	ldd	r24, Z+1	; 0x01
    148a:	92 81       	ldd	r25, Z+2	; 0x02
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3336
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    148c:	60 91 dc 01 	lds	r22, 0x01DC	; 0x8001dc <xNumOfOverflows>
    1490:	70 81       	ld	r23, Z
    1492:	76 17       	cp	r23, r22
    1494:	49 f0       	breq	.+18     	; 0x14a8 <xTaskCheckForTimeOut+0x3e>
    1496:	48 17       	cp	r20, r24
    1498:	59 07       	cpc	r21, r25
    149a:	30 f0       	brcs	.+12     	; 0x14a8 <xTaskCheckForTimeOut+0x3e>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3344
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
    149c:	1d 92       	st	X+, r1
    149e:	1c 92       	st	X, r1
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3343
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    14a0:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3359
        {
            *pxTicksToWait = ( TickType_t ) 0;
            xReturn = pdTRUE;
        }
    }
    taskEXIT_CRITICAL();
    14a2:	0f 90       	pop	r0
    14a4:	0f be       	out	0x3f, r0	; 63
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3362

    return xReturn;
}
    14a6:	08 95       	ret
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3312

    taskENTER_CRITICAL();
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    14a8:	48 1b       	sub	r20, r24
    14aa:	59 0b       	sbc	r21, r25
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3346
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    14ac:	42 17       	cp	r20, r18
    14ae:	53 07       	cpc	r21, r19
    14b0:	a8 f7       	brcc	.-22     	; 0x149c <xTaskCheckForTimeOut+0x32>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3349
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    14b2:	24 1b       	sub	r18, r20
    14b4:	35 0b       	sbc	r19, r21
    14b6:	2d 93       	st	X+, r18
    14b8:	3c 93       	st	X, r19
vTaskInternalSetTimeOutState():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3295
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    14ba:	80 91 dc 01 	lds	r24, 0x01DC	; 0x8001dc <xNumOfOverflows>
    14be:	80 83       	st	Z, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3296
    pxTimeOut->xTimeOnEntering = xTickCount;
    14c0:	80 91 da 01 	lds	r24, 0x01DA	; 0x8001da <xTickCount>
    14c4:	90 91 db 01 	lds	r25, 0x01DB	; 0x8001db <xTickCount+0x1>
    14c8:	92 83       	std	Z+2, r25	; 0x02
    14ca:	81 83       	std	Z+1, r24	; 0x01
xTaskCheckForTimeOut():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3331
            if( *pxTicksToWait == portMAX_DELAY )
            {
                /* If INCLUDE_vTaskSuspend is set to 1 and the block time
                 * specified is the maximum block time then the task should block
                 * indefinitely, and therefore never time out. */
                xReturn = pdFALSE;
    14cc:	80 e0       	ldi	r24, 0x00	; 0
    14ce:	e9 cf       	rjmp	.-46     	; 0x14a2 <xTaskCheckForTimeOut+0x38>

000014d0 <xTaskRemoveFromEventList>:
xTaskRemoveFromEventList():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3164

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    14d0:	cf 93       	push	r28
    14d2:	df 93       	push	r29
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3181
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    14d4:	dc 01       	movw	r26, r24
    14d6:	15 96       	adiw	r26, 0x05	; 5
    14d8:	ed 91       	ld	r30, X+
    14da:	fc 91       	ld	r31, X
    14dc:	06 80       	ldd	r0, Z+6	; 0x06
    14de:	f7 81       	ldd	r31, Z+7	; 0x07
    14e0:	e0 2d       	mov	r30, r0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3183
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    14e2:	a4 89       	ldd	r26, Z+20	; 0x14
    14e4:	b5 89       	ldd	r27, Z+21	; 0x15
    14e6:	86 85       	ldd	r24, Z+14	; 0x0e
    14e8:	97 85       	ldd	r25, Z+15	; 0x0f
    14ea:	20 89       	ldd	r18, Z+16	; 0x10
    14ec:	31 89       	ldd	r19, Z+17	; 0x11
    14ee:	ec 01       	movw	r28, r24
    14f0:	3d 83       	std	Y+5, r19	; 0x05
    14f2:	2c 83       	std	Y+4, r18	; 0x04
    14f4:	c0 89       	ldd	r28, Z+16	; 0x10
    14f6:	d1 89       	ldd	r29, Z+17	; 0x11
    14f8:	9b 83       	std	Y+3, r25	; 0x03
    14fa:	8a 83       	std	Y+2, r24	; 0x02
    14fc:	cf 01       	movw	r24, r30
    14fe:	0c 96       	adiw	r24, 0x0c	; 12
    1500:	11 96       	adiw	r26, 0x01	; 1
    1502:	2d 91       	ld	r18, X+
    1504:	3c 91       	ld	r19, X
    1506:	12 97       	sbiw	r26, 0x02	; 2
    1508:	28 17       	cp	r18, r24
    150a:	39 07       	cpc	r19, r25
    150c:	21 f4       	brne	.+8      	; 0x1516 <xTaskRemoveFromEventList+0x46>
    150e:	12 96       	adiw	r26, 0x02	; 2
    1510:	dc 93       	st	X, r29
    1512:	ce 93       	st	-X, r28
    1514:	11 97       	sbiw	r26, 0x01	; 1
    1516:	15 8a       	std	Z+21, r1	; 0x15
    1518:	14 8a       	std	Z+20, r1	; 0x14
    151a:	2c 91       	ld	r18, X
    151c:	21 50       	subi	r18, 0x01	; 1
    151e:	2c 93       	st	X, r18
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3185

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1520:	20 91 d7 01 	lds	r18, 0x01D7	; 0x8001d7 <uxSchedulerSuspended>
    1524:	21 11       	cpse	r18, r1
    1526:	57 c0       	rjmp	.+174    	; 0x15d6 <xTaskRemoveFromEventList+0x106>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3187
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    1528:	a2 85       	ldd	r26, Z+10	; 0x0a
    152a:	b3 85       	ldd	r27, Z+11	; 0x0b
    152c:	84 81       	ldd	r24, Z+4	; 0x04
    152e:	95 81       	ldd	r25, Z+5	; 0x05
    1530:	26 81       	ldd	r18, Z+6	; 0x06
    1532:	37 81       	ldd	r19, Z+7	; 0x07
    1534:	ec 01       	movw	r28, r24
    1536:	3d 83       	std	Y+5, r19	; 0x05
    1538:	2c 83       	std	Y+4, r18	; 0x04
    153a:	c6 81       	ldd	r28, Z+6	; 0x06
    153c:	d7 81       	ldd	r29, Z+7	; 0x07
    153e:	9b 83       	std	Y+3, r25	; 0x03
    1540:	8a 83       	std	Y+2, r24	; 0x02
    1542:	cf 01       	movw	r24, r30
    1544:	02 96       	adiw	r24, 0x02	; 2
    1546:	11 96       	adiw	r26, 0x01	; 1
    1548:	2d 91       	ld	r18, X+
    154a:	3c 91       	ld	r19, X
    154c:	12 97       	sbiw	r26, 0x02	; 2
    154e:	28 17       	cp	r18, r24
    1550:	39 07       	cpc	r19, r25
    1552:	21 f4       	brne	.+8      	; 0x155c <xTaskRemoveFromEventList+0x8c>
    1554:	12 96       	adiw	r26, 0x02	; 2
    1556:	dc 93       	st	X, r29
    1558:	ce 93       	st	-X, r28
    155a:	11 97       	sbiw	r26, 0x01	; 1
    155c:	13 86       	std	Z+11, r1	; 0x0b
    155e:	12 86       	std	Z+10, r1	; 0x0a
    1560:	2c 91       	ld	r18, X
    1562:	21 50       	subi	r18, 0x01	; 1
    1564:	2c 93       	st	X, r18
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3188
        prvAddTaskToReadyList( pxUnblockedTCB );
    1566:	c6 89       	ldd	r28, Z+22	; 0x16
    1568:	20 91 32 02 	lds	r18, 0x0232	; 0x800232 <uxTopReadyPriority>
    156c:	2c 17       	cp	r18, r28
    156e:	10 f4       	brcc	.+4      	; 0x1574 <xTaskRemoveFromEventList+0xa4>
    1570:	c0 93 32 02 	sts	0x0232, r28	; 0x800232 <uxTopReadyPriority>
    1574:	29 e0       	ldi	r18, 0x09	; 9
    1576:	2c 9f       	mul	r18, r28
    1578:	e0 01       	movw	r28, r0
    157a:	11 24       	eor	r1, r1
    157c:	c2 5f       	subi	r28, 0xF2	; 242
    157e:	dd 4f       	sbci	r29, 0xFD	; 253
    1580:	09 80       	ldd	r0, Y+1	; 0x01
    1582:	da 81       	ldd	r29, Y+2	; 0x02
    1584:	c0 2d       	mov	r28, r0
    1586:	d5 83       	std	Z+5, r29	; 0x05
    1588:	c4 83       	std	Z+4, r28	; 0x04
    158a:	4c 81       	ldd	r20, Y+4	; 0x04
    158c:	5d 81       	ldd	r21, Y+5	; 0x05
    158e:	57 83       	std	Z+7, r21	; 0x07
    1590:	46 83       	std	Z+6, r20	; 0x06
    1592:	ac 81       	ldd	r26, Y+4	; 0x04
    1594:	bd 81       	ldd	r27, Y+5	; 0x05
    1596:	13 96       	adiw	r26, 0x03	; 3
    1598:	9c 93       	st	X, r25
    159a:	8e 93       	st	-X, r24
    159c:	12 97       	sbiw	r26, 0x02	; 2
    159e:	9d 83       	std	Y+5, r25	; 0x05
    15a0:	8c 83       	std	Y+4, r24	; 0x04
    15a2:	a6 89       	ldd	r26, Z+22	; 0x16
    15a4:	a2 9f       	mul	r26, r18
    15a6:	d0 01       	movw	r26, r0
    15a8:	11 24       	eor	r1, r1
    15aa:	a2 5f       	subi	r26, 0xF2	; 242
    15ac:	bd 4f       	sbci	r27, 0xFD	; 253
    15ae:	b3 87       	std	Z+11, r27	; 0x0b
    15b0:	a2 87       	std	Z+10, r26	; 0x0a
    15b2:	8c 91       	ld	r24, X
    15b4:	8f 5f       	subi	r24, 0xFF	; 255
    15b6:	8c 93       	st	X, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3211
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    15b8:	a0 91 9e 01 	lds	r26, 0x019E	; 0x80019e <__data_end>
    15bc:	b0 91 9f 01 	lds	r27, 0x019F	; 0x80019f <__data_end+0x1>
    15c0:	96 89       	ldd	r25, Z+22	; 0x16
    15c2:	56 96       	adiw	r26, 0x16	; 22
    15c4:	8c 91       	ld	r24, X
    15c6:	89 17       	cp	r24, r25
    15c8:	30 f5       	brcc	.+76     	; 0x1616 <xTaskRemoveFromEventList+0x146>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3220
         * it should force a context switch now. */
        xReturn = pdTRUE;

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    15ca:	81 e0       	ldi	r24, 0x01	; 1
    15cc:	80 93 ae 01 	sts	0x01AE, r24	; 0x8001ae <xYieldPending>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3228
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
    15d0:	df 91       	pop	r29
    15d2:	cf 91       	pop	r28
    15d4:	08 95       	ret
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3208
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    15d6:	a0 91 f4 01 	lds	r26, 0x01F4	; 0x8001f4 <xPendingReadyList+0x1>
    15da:	b0 91 f5 01 	lds	r27, 0x01F5	; 0x8001f5 <xPendingReadyList+0x2>
    15de:	b7 87       	std	Z+15, r27	; 0x0f
    15e0:	a6 87       	std	Z+14, r26	; 0x0e
    15e2:	14 96       	adiw	r26, 0x04	; 4
    15e4:	2d 91       	ld	r18, X+
    15e6:	3c 91       	ld	r19, X
    15e8:	15 97       	sbiw	r26, 0x05	; 5
    15ea:	31 8b       	std	Z+17, r19	; 0x11
    15ec:	20 8b       	std	Z+16, r18	; 0x10
    15ee:	14 96       	adiw	r26, 0x04	; 4
    15f0:	cd 91       	ld	r28, X+
    15f2:	dc 91       	ld	r29, X
    15f4:	15 97       	sbiw	r26, 0x05	; 5
    15f6:	9b 83       	std	Y+3, r25	; 0x03
    15f8:	8a 83       	std	Y+2, r24	; 0x02
    15fa:	15 96       	adiw	r26, 0x05	; 5
    15fc:	9c 93       	st	X, r25
    15fe:	8e 93       	st	-X, r24
    1600:	14 97       	sbiw	r26, 0x04	; 4
    1602:	83 ef       	ldi	r24, 0xF3	; 243
    1604:	91 e0       	ldi	r25, 0x01	; 1
    1606:	95 8b       	std	Z+21, r25	; 0x15
    1608:	84 8b       	std	Z+20, r24	; 0x14
    160a:	80 91 f3 01 	lds	r24, 0x01F3	; 0x8001f3 <xPendingReadyList>
    160e:	8f 5f       	subi	r24, 0xFF	; 255
    1610:	80 93 f3 01 	sts	0x01F3, r24	; 0x8001f3 <xPendingReadyList>
    1614:	d1 cf       	rjmp	.-94     	; 0x15b8 <xTaskRemoveFromEventList+0xe8>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3224
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    }
    else
    {
        xReturn = pdFALSE;
    1616:	80 e0       	ldi	r24, 0x00	; 0
    1618:	db cf       	rjmp	.-74     	; 0x15d0 <xTaskRemoveFromEventList+0x100>

0000161a <xTaskGetTickCount>:
xTaskGetTickCount():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2324
TickType_t xTaskGetTickCount( void )
{
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    161a:	0f b6       	in	r0, 0x3f	; 63
    161c:	f8 94       	cli
    161e:	0f 92       	push	r0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2326
    {
        xTicks = xTickCount;
    1620:	80 91 da 01 	lds	r24, 0x01DA	; 0x8001da <xTickCount>
    1624:	90 91 db 01 	lds	r25, 0x01DB	; 0x8001db <xTickCount+0x1>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2328
    }
    portTICK_TYPE_EXIT_CRITICAL();
    1628:	0f 90       	pop	r0
    162a:	0f be       	out	0x3f, r0	; 63
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2331

    return xTicks;
}
    162c:	08 95       	ret

0000162e <vTaskSuspendAll>:
vTaskSuspendAll():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2136
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    162e:	80 91 d7 01 	lds	r24, 0x01D7	; 0x8001d7 <uxSchedulerSuspended>
    1632:	8f 5f       	subi	r24, 0xFF	; 255
    1634:	80 93 d7 01 	sts	0x01D7, r24	; 0x8001d7 <uxSchedulerSuspended>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2141

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    1638:	08 95       	ret

0000163a <prvIsQueueEmpty>:
prvIsQueueEmpty():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2350

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    163a:	0f b6       	in	r0, 0x3f	; 63
    163c:	f8 94       	cli
    163e:	0f 92       	push	r0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2352
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1640:	fc 01       	movw	r30, r24
    1642:	92 8d       	ldd	r25, Z+26	; 0x1a
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2361
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    1644:	0f 90       	pop	r0
    1646:	0f be       	out	0x3f, r0	; 63
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2352
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1648:	81 e0       	ldi	r24, 0x01	; 1
    164a:	91 11       	cpse	r25, r1
    164c:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2364
        }
    }
    taskEXIT_CRITICAL();

    return xReturn;
}
    164e:	08 95       	ret

00001650 <prvUnlockQueue>:
prvUnlockQueue():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2227
    }
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1650:	ef 92       	push	r14
    1652:	ff 92       	push	r15
    1654:	0f 93       	push	r16
    1656:	1f 93       	push	r17
    1658:	cf 93       	push	r28
    165a:	df 93       	push	r29
    165c:	ec 01       	movw	r28, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2234

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    165e:	0f b6       	in	r0, 0x3f	; 63
    1660:	f8 94       	cli
    1662:	0f 92       	push	r0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2236
    {
        int8_t cTxLock = pxQueue->cTxLock;
    1664:	1e 8d       	ldd	r17, Y+30	; 0x1e
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2289
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1666:	7c 01       	movw	r14, r24
    1668:	81 e1       	ldi	r24, 0x11	; 17
    166a:	e8 0e       	add	r14, r24
    166c:	f1 1c       	adc	r15, r1
vTaskMissedYield():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3367
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    xYieldPending = pdTRUE;
    166e:	01 e0       	ldi	r16, 0x01	; 1
prvUnlockQueue():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2239
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    1670:	11 16       	cp	r1, r17
    1672:	d4 f0       	brlt	.+52     	; 0x16a8 <prvUnlockQueue+0x58>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2310
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    1674:	8f ef       	ldi	r24, 0xFF	; 255
    1676:	8e 8f       	std	Y+30, r24	; 0x1e
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2312
    }
    taskEXIT_CRITICAL();
    1678:	0f 90       	pop	r0
    167a:	0f be       	out	0x3f, r0	; 63
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2315

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    167c:	0f b6       	in	r0, 0x3f	; 63
    167e:	f8 94       	cli
    1680:	0f 92       	push	r0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2317
    {
        int8_t cRxLock = pxQueue->cRxLock;
    1682:	1d 8d       	ldd	r17, Y+29	; 0x1d
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2323

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1684:	7e 01       	movw	r14, r28
    1686:	88 e0       	ldi	r24, 0x08	; 8
    1688:	e8 0e       	add	r14, r24
    168a:	f1 1c       	adc	r15, r1
vTaskMissedYield():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3367
    168c:	01 e0       	ldi	r16, 0x01	; 1
prvUnlockQueue():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2319
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    168e:	11 16       	cp	r1, r17
    1690:	b4 f0       	brlt	.+44     	; 0x16be <prvUnlockQueue+0x6e>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2340
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    1692:	8f ef       	ldi	r24, 0xFF	; 255
    1694:	8d 8f       	std	Y+29, r24	; 0x1d
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2342
    }
    taskEXIT_CRITICAL();
    1696:	0f 90       	pop	r0
    1698:	0f be       	out	0x3f, r0	; 63
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2343
}
    169a:	df 91       	pop	r29
    169c:	cf 91       	pop	r28
    169e:	1f 91       	pop	r17
    16a0:	0f 91       	pop	r16
    16a2:	ff 90       	pop	r15
    16a4:	ef 90       	pop	r14
    16a6:	08 95       	ret
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2287
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    16a8:	89 89       	ldd	r24, Y+17	; 0x11
    16aa:	88 23       	and	r24, r24
    16ac:	19 f3       	breq	.-58     	; 0x1674 <prvUnlockQueue+0x24>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2289
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    16ae:	c7 01       	movw	r24, r14
    16b0:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <xTaskRemoveFromEventList>
    16b4:	81 11       	cpse	r24, r1
vTaskMissedYield():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3367
    16b6:	00 93 ae 01 	sts	0x01AE, r16	; 0x8001ae <xYieldPending>
    16ba:	11 50       	subi	r17, 0x01	; 1
    16bc:	d9 cf       	rjmp	.-78     	; 0x1670 <prvUnlockQueue+0x20>
prvUnlockQueue():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2321
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16be:	88 85       	ldd	r24, Y+8	; 0x08
    16c0:	88 23       	and	r24, r24
    16c2:	39 f3       	breq	.-50     	; 0x1692 <prvUnlockQueue+0x42>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2323
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    16c4:	c7 01       	movw	r24, r14
    16c6:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <xTaskRemoveFromEventList>
    16ca:	81 11       	cpse	r24, r1
vTaskMissedYield():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3367
    16cc:	00 93 ae 01 	sts	0x01AE, r16	; 0x8001ae <xYieldPending>
    16d0:	11 50       	subi	r17, 0x01	; 1
    16d2:	dd cf       	rjmp	.-70     	; 0x168e <prvUnlockQueue+0x3e>

000016d4 <uxListRemove>:
uxListRemove():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:184
    ( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    16d4:	cf 93       	push	r28
    16d6:	df 93       	push	r29
    16d8:	fc 01       	movw	r30, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:187
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    16da:	a0 85       	ldd	r26, Z+8	; 0x08
    16dc:	b1 85       	ldd	r27, Z+9	; 0x09
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:189

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    16de:	82 81       	ldd	r24, Z+2	; 0x02
    16e0:	93 81       	ldd	r25, Z+3	; 0x03
    16e2:	24 81       	ldd	r18, Z+4	; 0x04
    16e4:	35 81       	ldd	r19, Z+5	; 0x05
    16e6:	ec 01       	movw	r28, r24
    16e8:	3d 83       	std	Y+5, r19	; 0x05
    16ea:	2c 83       	std	Y+4, r18	; 0x04
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:190
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    16ec:	c4 81       	ldd	r28, Z+4	; 0x04
    16ee:	d5 81       	ldd	r29, Z+5	; 0x05
    16f0:	9b 83       	std	Y+3, r25	; 0x03
    16f2:	8a 83       	std	Y+2, r24	; 0x02
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:196

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    16f4:	11 96       	adiw	r26, 0x01	; 1
    16f6:	8d 91       	ld	r24, X+
    16f8:	9c 91       	ld	r25, X
    16fa:	12 97       	sbiw	r26, 0x02	; 2
    16fc:	8e 17       	cp	r24, r30
    16fe:	9f 07       	cpc	r25, r31
    1700:	21 f4       	brne	.+8      	; 0x170a <uxListRemove+0x36>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:198
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    1702:	12 96       	adiw	r26, 0x02	; 2
    1704:	dc 93       	st	X, r29
    1706:	ce 93       	st	-X, r28
    1708:	11 97       	sbiw	r26, 0x01	; 1
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:205
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    170a:	11 86       	std	Z+9, r1	; 0x09
    170c:	10 86       	std	Z+8, r1	; 0x08
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:206
    ( pxList->uxNumberOfItems )--;
    170e:	8c 91       	ld	r24, X
    1710:	81 50       	subi	r24, 0x01	; 1
    1712:	8c 93       	st	X, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:208

    return pxList->uxNumberOfItems;
    1714:	8c 91       	ld	r24, X
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:209
}
    1716:	df 91       	pop	r29
    1718:	cf 91       	pop	r28
    171a:	08 95       	ret

0000171c <vListInsert>:
vListInsert():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:117
}
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    171c:	0f 93       	push	r16
    171e:	1f 93       	push	r17
    1720:	cf 93       	push	r28
    1722:	df 93       	push	r29
    1724:	8c 01       	movw	r16, r24
    1726:	fb 01       	movw	r30, r22
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:119
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1728:	80 81       	ld	r24, Z
    172a:	91 81       	ldd	r25, Z+1	; 0x01
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:163
        *   4) Using a queue or semaphore before it has been initialised or
        *      before the scheduler has been started (are interrupts firing
        *      before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    172c:	d8 01       	movw	r26, r16
    172e:	13 96       	adiw	r26, 0x03	; 3
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:135
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    1730:	8f 3f       	cpi	r24, 0xFF	; 255
    1732:	98 07       	cpc	r25, r24
    1734:	f1 f4       	brne	.+60     	; 0x1772 <vListInsert+0x56>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:137
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    1736:	e8 01       	movw	r28, r16
    1738:	af 81       	ldd	r26, Y+7	; 0x07
    173a:	b8 85       	ldd	r27, Y+8	; 0x08
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:170
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    173c:	12 96       	adiw	r26, 0x02	; 2
    173e:	8d 91       	ld	r24, X+
    1740:	9c 91       	ld	r25, X
    1742:	13 97       	sbiw	r26, 0x03	; 3
    1744:	93 83       	std	Z+3, r25	; 0x03
    1746:	82 83       	std	Z+2, r24	; 0x02
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:171
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1748:	ec 01       	movw	r28, r24
    174a:	fd 83       	std	Y+5, r31	; 0x05
    174c:	ec 83       	std	Y+4, r30	; 0x04
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:172
    pxNewListItem->pxPrevious = pxIterator;
    174e:	b5 83       	std	Z+5, r27	; 0x05
    1750:	a4 83       	std	Z+4, r26	; 0x04
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:173
    pxIterator->pxNext = pxNewListItem;
    1752:	13 96       	adiw	r26, 0x03	; 3
    1754:	fc 93       	st	X, r31
    1756:	ee 93       	st	-X, r30
    1758:	12 97       	sbiw	r26, 0x02	; 2
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:177

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    175a:	11 87       	std	Z+9, r17	; 0x09
    175c:	00 87       	std	Z+8, r16	; 0x08
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:179

    ( pxList->uxNumberOfItems )++;
    175e:	f8 01       	movw	r30, r16
    1760:	80 81       	ld	r24, Z
    1762:	8f 5f       	subi	r24, 0xFF	; 255
    1764:	80 83       	st	Z, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:180
}
    1766:	df 91       	pop	r29
    1768:	cf 91       	pop	r28
    176a:	1f 91       	pop	r17
    176c:	0f 91       	pop	r16
    176e:	08 95       	ret
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:163
        *   4) Using a queue or semaphore before it has been initialised or
        *      before the scheduler has been started (are interrupts firing
        *      before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1770:	d9 01       	movw	r26, r18
    1772:	12 96       	adiw	r26, 0x02	; 2
    1774:	2d 91       	ld	r18, X+
    1776:	3c 91       	ld	r19, X
    1778:	13 97       	sbiw	r26, 0x03	; 3
    177a:	e9 01       	movw	r28, r18
    177c:	48 81       	ld	r20, Y
    177e:	59 81       	ldd	r21, Y+1	; 0x01
    1780:	84 17       	cp	r24, r20
    1782:	95 07       	cpc	r25, r21
    1784:	a8 f7       	brcc	.-22     	; 0x1770 <vListInsert+0x54>
    1786:	da cf       	rjmp	.-76     	; 0x173c <vListInsert+0x20>

00001788 <prvInsertTimerInActiveList>:
prvInsertTimerInActiveList():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:699

    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
    1788:	fc 01       	movw	r30, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:702
        BaseType_t xProcessTimerNow = pdFALSE;

        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    178a:	73 83       	std	Z+3, r23	; 0x03
    178c:	62 83       	std	Z+2, r22	; 0x02
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:703
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    178e:	91 87       	std	Z+9, r25	; 0x09
    1790:	80 87       	std	Z+8, r24	; 0x08
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:705

        if( xNextExpiryTime <= xTimeNow )
    1792:	46 17       	cp	r20, r22
    1794:	57 07       	cpc	r21, r23
    1796:	90 f0       	brcs	.+36     	; 0x17bc <prvInsertTimerInActiveList+0x34>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:709
        {
            /* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1798:	42 1b       	sub	r20, r18
    179a:	53 0b       	sbc	r21, r19
    179c:	84 85       	ldd	r24, Z+12	; 0x0c
    179e:	95 85       	ldd	r25, Z+13	; 0x0d
    17a0:	48 17       	cp	r20, r24
    17a2:	59 07       	cpc	r21, r25
    17a4:	c8 f4       	brcc	.+50     	; 0x17d8 <prvInsertTimerInActiveList+0x50>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:717
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
            }
            else
            {
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    17a6:	bf 01       	movw	r22, r30
    17a8:	6e 5f       	subi	r22, 0xFE	; 254
    17aa:	7f 4f       	sbci	r23, 0xFF	; 255
    17ac:	80 91 bb 01 	lds	r24, 0x01BB	; 0x8001bb <pxOverflowTimerList>
    17b0:	90 91 bc 01 	lds	r25, 0x01BC	; 0x8001bc <pxOverflowTimerList+0x1>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:731
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
            }
            else
            {
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    17b4:	0e 94 8e 0b 	call	0x171c	; 0x171c <vListInsert>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:700
    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
        BaseType_t xProcessTimerNow = pdFALSE;
    17b8:	80 e0       	ldi	r24, 0x00	; 0
    17ba:	08 95       	ret
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:722
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
            }
        }
        else
        {
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    17bc:	42 17       	cp	r20, r18
    17be:	53 07       	cpc	r21, r19
    17c0:	18 f4       	brcc	.+6      	; 0x17c8 <prvInsertTimerInActiveList+0x40>
    17c2:	62 17       	cp	r22, r18
    17c4:	73 07       	cpc	r23, r19
    17c6:	40 f4       	brcc	.+16     	; 0x17d8 <prvInsertTimerInActiveList+0x50>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:731
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
            }
            else
            {
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    17c8:	bf 01       	movw	r22, r30
    17ca:	6e 5f       	subi	r22, 0xFE	; 254
    17cc:	7f 4f       	sbci	r23, 0xFF	; 255
    17ce:	80 91 bd 01 	lds	r24, 0x01BD	; 0x8001bd <pxCurrentTimerList>
    17d2:	90 91 be 01 	lds	r25, 0x01BE	; 0x8001be <pxCurrentTimerList+0x1>
    17d6:	ee cf       	rjmp	.-36     	; 0x17b4 <prvInsertTimerInActiveList+0x2c>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:713
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
            {
                /* The time between a command being issued and the command being
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
    17d8:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:736
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
            }
        }

        return xProcessTimerNow;
    }
    17da:	08 95       	ret

000017dc <prvAddCurrentTaskToDelayedList>:
prvAddCurrentTaskToDelayedList():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:5264
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    17dc:	ff 92       	push	r15
    17de:	0f 93       	push	r16
    17e0:	1f 93       	push	r17
    17e2:	cf 93       	push	r28
    17e4:	df 93       	push	r29
    17e6:	ec 01       	movw	r28, r24
    17e8:	f6 2e       	mov	r15, r22
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:5266
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    17ea:	00 91 da 01 	lds	r16, 0x01DA	; 0x8001da <xTickCount>
    17ee:	10 91 db 01 	lds	r17, 0x01DB	; 0x8001db <xTickCount+0x1>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:5279
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    17f2:	80 91 9e 01 	lds	r24, 0x019E	; 0x80019e <__data_end>
    17f6:	90 91 9f 01 	lds	r25, 0x019F	; 0x80019f <__data_end+0x1>
    17fa:	02 96       	adiw	r24, 0x02	; 2
    17fc:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uxListRemove>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:5292
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    1800:	cf 3f       	cpi	r28, 0xFF	; 255
    1802:	dc 07       	cpc	r29, r28
    1804:	e9 f5       	brne	.+122    	; 0x1880 <prvAddCurrentTaskToDelayedList+0xa4>
    1806:	ff 20       	and	r15, r15
    1808:	d9 f1       	breq	.+118    	; 0x1880 <prvAddCurrentTaskToDelayedList+0xa4>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:5297
            {
                /* Add the task to the suspended task list instead of a delayed task
                 * list to ensure it is not woken by a timing event.  It will block
                 * indefinitely. */
                listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    180a:	e0 91 e2 01 	lds	r30, 0x01E2	; 0x8001e2 <xSuspendedTaskList+0x1>
    180e:	f0 91 e3 01 	lds	r31, 0x01E3	; 0x8001e3 <xSuspendedTaskList+0x2>
    1812:	a0 91 9e 01 	lds	r26, 0x019E	; 0x80019e <__data_end>
    1816:	b0 91 9f 01 	lds	r27, 0x019F	; 0x80019f <__data_end+0x1>
    181a:	15 96       	adiw	r26, 0x05	; 5
    181c:	fc 93       	st	X, r31
    181e:	ee 93       	st	-X, r30
    1820:	14 97       	sbiw	r26, 0x04	; 4
    1822:	a0 91 9e 01 	lds	r26, 0x019E	; 0x80019e <__data_end>
    1826:	b0 91 9f 01 	lds	r27, 0x019F	; 0x80019f <__data_end+0x1>
    182a:	84 81       	ldd	r24, Z+4	; 0x04
    182c:	95 81       	ldd	r25, Z+5	; 0x05
    182e:	17 96       	adiw	r26, 0x07	; 7
    1830:	9c 93       	st	X, r25
    1832:	8e 93       	st	-X, r24
    1834:	16 97       	sbiw	r26, 0x06	; 6
    1836:	80 91 9e 01 	lds	r24, 0x019E	; 0x80019e <__data_end>
    183a:	90 91 9f 01 	lds	r25, 0x019F	; 0x80019f <__data_end+0x1>
    183e:	a4 81       	ldd	r26, Z+4	; 0x04
    1840:	b5 81       	ldd	r27, Z+5	; 0x05
    1842:	02 96       	adiw	r24, 0x02	; 2
    1844:	13 96       	adiw	r26, 0x03	; 3
    1846:	9c 93       	st	X, r25
    1848:	8e 93       	st	-X, r24
    184a:	12 97       	sbiw	r26, 0x02	; 2
    184c:	80 91 9e 01 	lds	r24, 0x019E	; 0x80019e <__data_end>
    1850:	90 91 9f 01 	lds	r25, 0x019F	; 0x80019f <__data_end+0x1>
    1854:	02 96       	adiw	r24, 0x02	; 2
    1856:	95 83       	std	Z+5, r25	; 0x05
    1858:	84 83       	std	Z+4, r24	; 0x04
    185a:	e0 91 9e 01 	lds	r30, 0x019E	; 0x80019e <__data_end>
    185e:	f0 91 9f 01 	lds	r31, 0x019F	; 0x80019f <__data_end+0x1>
    1862:	81 ee       	ldi	r24, 0xE1	; 225
    1864:	91 e0       	ldi	r25, 0x01	; 1
    1866:	93 87       	std	Z+11, r25	; 0x0b
    1868:	82 87       	std	Z+10, r24	; 0x0a
    186a:	80 91 e1 01 	lds	r24, 0x01E1	; 0x8001e1 <xSuspendedTaskList>
    186e:	8f 5f       	subi	r24, 0xFF	; 255
    1870:	80 93 e1 01 	sts	0x01E1, r24	; 0x8001e1 <xSuspendedTaskList>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:5372

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
    1874:	df 91       	pop	r29
    1876:	cf 91       	pop	r28
    1878:	1f 91       	pop	r17
    187a:	0f 91       	pop	r16
    187c:	ff 90       	pop	r15
    187e:	08 95       	ret
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:5304
            else
            {
                /* Calculate the time at which the task should be woken if the event
                 * does not occur.  This may overflow but this doesn't matter, the
                 * kernel will manage it correctly. */
                xTimeToWake = xConstTickCount + xTicksToWait;
    1880:	c0 0f       	add	r28, r16
    1882:	d1 1f       	adc	r29, r17
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:5307

                /* The list item will be inserted in wake time order. */
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    1884:	e0 91 9e 01 	lds	r30, 0x019E	; 0x80019e <__data_end>
    1888:	f0 91 9f 01 	lds	r31, 0x019F	; 0x80019f <__data_end+0x1>
    188c:	d3 83       	std	Z+3, r29	; 0x03
    188e:	c2 83       	std	Z+2, r28	; 0x02
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:5313

                if( xTimeToWake < xConstTickCount )
                {
                    /* Wake time has overflowed.  Place this item in the overflow
                     * list. */
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1890:	60 91 9e 01 	lds	r22, 0x019E	; 0x80019e <__data_end>
    1894:	70 91 9f 01 	lds	r23, 0x019F	; 0x80019f <__data_end+0x1>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:5309
                xTimeToWake = xConstTickCount + xTicksToWait;

                /* The list item will be inserted in wake time order. */
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

                if( xTimeToWake < xConstTickCount )
    1898:	c0 17       	cp	r28, r16
    189a:	d1 07       	cpc	r29, r17
    189c:	68 f4       	brcc	.+26     	; 0x18b8 <prvAddCurrentTaskToDelayedList+0xdc>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:5313
                {
                    /* Wake time has overflowed.  Place this item in the overflow
                     * list. */
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    189e:	80 91 dd 01 	lds	r24, 0x01DD	; 0x8001dd <pxOverflowDelayedTaskList>
    18a2:	90 91 de 01 	lds	r25, 0x01DE	; 0x8001de <pxOverflowDelayedTaskList+0x1>
    18a6:	6e 5f       	subi	r22, 0xFE	; 254
    18a8:	7f 4f       	sbci	r23, 0xFF	; 255
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:5372

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
    18aa:	df 91       	pop	r29
    18ac:	cf 91       	pop	r28
    18ae:	1f 91       	pop	r17
    18b0:	0f 91       	pop	r16
    18b2:	ff 90       	pop	r15
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:5313

                if( xTimeToWake < xConstTickCount )
                {
                    /* Wake time has overflowed.  Place this item in the overflow
                     * list. */
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    18b4:	0c 94 8e 0b 	jmp	0x171c	; 0x171c <vListInsert>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:5319
                }
                else
                {
                    /* The wake time has not overflowed, so the current block list
                     * is used. */
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    18b8:	80 91 df 01 	lds	r24, 0x01DF	; 0x8001df <pxDelayedTaskList>
    18bc:	90 91 e0 01 	lds	r25, 0x01E0	; 0x8001e0 <pxDelayedTaskList+0x1>
    18c0:	6e 5f       	subi	r22, 0xFE	; 254
    18c2:	7f 4f       	sbci	r23, 0xFF	; 255
    18c4:	0e 94 8e 0b 	call	0x171c	; 0x171c <vListInsert>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:5324

                    /* If the task entering the blocked state was placed at the
                     * head of the list of blocked tasks then xNextTaskUnblockTime
                     * needs to be updated too. */
                    if( xTimeToWake < xNextTaskUnblockTime )
    18c8:	80 91 d3 01 	lds	r24, 0x01D3	; 0x8001d3 <xNextTaskUnblockTime>
    18cc:	90 91 d4 01 	lds	r25, 0x01D4	; 0x8001d4 <xNextTaskUnblockTime+0x1>
    18d0:	c8 17       	cp	r28, r24
    18d2:	d9 07       	cpc	r29, r25
    18d4:	78 f6       	brcc	.-98     	; 0x1874 <prvAddCurrentTaskToDelayedList+0x98>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:5326
                    {
                        xNextTaskUnblockTime = xTimeToWake;
    18d6:	d0 93 d4 01 	sts	0x01D4, r29	; 0x8001d4 <xNextTaskUnblockTime+0x1>
    18da:	c0 93 d3 01 	sts	0x01D3, r28	; 0x8001d3 <xNextTaskUnblockTime>
    18de:	ca cf       	rjmp	.-108    	; 0x1874 <prvAddCurrentTaskToDelayedList+0x98>

000018e0 <vListInitialise>:
vListInitialise():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:49
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    18e0:	fc 01       	movw	r30, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:53
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    18e2:	03 96       	adiw	r24, 0x03	; 3
    18e4:	92 83       	std	Z+2, r25	; 0x02
    18e6:	81 83       	std	Z+1, r24	; 0x01
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:57

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    18e8:	2f ef       	ldi	r18, 0xFF	; 255
    18ea:	3f ef       	ldi	r19, 0xFF	; 255
    18ec:	34 83       	std	Z+4, r19	; 0x04
    18ee:	23 83       	std	Z+3, r18	; 0x03
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:61

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    18f0:	96 83       	std	Z+6, r25	; 0x06
    18f2:	85 83       	std	Z+5, r24	; 0x05
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:62
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    18f4:	90 87       	std	Z+8, r25	; 0x08
    18f6:	87 83       	std	Z+7, r24	; 0x07
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:64

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    18f8:	10 82       	st	Z, r1
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:70

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    18fa:	08 95       	ret

000018fc <vPortYield>:
vPortYield():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/port.c:625
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    18fc:	0f 92       	push	r0
    18fe:	0f b6       	in	r0, 0x3f	; 63
    1900:	f8 94       	cli
    1902:	0f 92       	push	r0
    1904:	1f 92       	push	r1
    1906:	11 24       	eor	r1, r1
    1908:	2f 92       	push	r2
    190a:	3f 92       	push	r3
    190c:	4f 92       	push	r4
    190e:	5f 92       	push	r5
    1910:	6f 92       	push	r6
    1912:	7f 92       	push	r7
    1914:	8f 92       	push	r8
    1916:	9f 92       	push	r9
    1918:	af 92       	push	r10
    191a:	bf 92       	push	r11
    191c:	cf 92       	push	r12
    191e:	df 92       	push	r13
    1920:	ef 92       	push	r14
    1922:	ff 92       	push	r15
    1924:	0f 93       	push	r16
    1926:	1f 93       	push	r17
    1928:	2f 93       	push	r18
    192a:	3f 93       	push	r19
    192c:	4f 93       	push	r20
    192e:	5f 93       	push	r21
    1930:	6f 93       	push	r22
    1932:	7f 93       	push	r23
    1934:	8f 93       	push	r24
    1936:	9f 93       	push	r25
    1938:	af 93       	push	r26
    193a:	bf 93       	push	r27
    193c:	cf 93       	push	r28
    193e:	df 93       	push	r29
    1940:	ef 93       	push	r30
    1942:	ff 93       	push	r31
    1944:	a0 91 9e 01 	lds	r26, 0x019E	; 0x80019e <__data_end>
    1948:	b0 91 9f 01 	lds	r27, 0x019F	; 0x80019f <__data_end+0x1>
    194c:	0d b6       	in	r0, 0x3d	; 61
    194e:	0d 92       	st	X+, r0
    1950:	0e b6       	in	r0, 0x3e	; 62
    1952:	0d 92       	st	X+, r0
vTaskSwitchContext():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3010
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    1954:	80 91 d7 01 	lds	r24, 0x01D7	; 0x8001d7 <uxSchedulerSuspended>
    1958:	88 23       	and	r24, r24
    195a:	21 f0       	breq	.+8      	; 0x1964 <vPortYield+0x68>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3014
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    195c:	81 e0       	ldi	r24, 0x01	; 1
    195e:	80 93 ae 01 	sts	0x01AE, r24	; 0x8001ae <xYieldPending>
    1962:	5f c0       	rjmp	.+190    	; 0x1a22 <vPortYield+0x126>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3018
    }
    else
    {
        xYieldPending = pdFALSE;
    1964:	10 92 ae 01 	sts	0x01AE, r1	; 0x8001ae <xYieldPending>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3050
                ulTaskSwitchedInTime = ulTotalRunTime;
            }
        #endif /* configGENERATE_RUN_TIME_STATS */

        /* Check for stack overflow, if configured. */
        taskCHECK_FOR_STACK_OVERFLOW();
    1968:	a0 91 9e 01 	lds	r26, 0x019E	; 0x80019e <__data_end>
    196c:	b0 91 9f 01 	lds	r27, 0x019F	; 0x80019f <__data_end+0x1>
    1970:	e0 91 9e 01 	lds	r30, 0x019E	; 0x80019e <__data_end>
    1974:	f0 91 9f 01 	lds	r31, 0x019F	; 0x80019f <__data_end+0x1>
    1978:	2d 91       	ld	r18, X+
    197a:	3c 91       	ld	r19, X
    197c:	87 89       	ldd	r24, Z+23	; 0x17
    197e:	90 8d       	ldd	r25, Z+24	; 0x18
    1980:	82 17       	cp	r24, r18
    1982:	93 07       	cpc	r25, r19
    1984:	a8 f0       	brcs	.+42     	; 0x19b0 <vPortYield+0xb4>
    1986:	80 91 9e 01 	lds	r24, 0x019E	; 0x80019e <__data_end>
    198a:	90 91 9f 01 	lds	r25, 0x019F	; 0x80019f <__data_end+0x1>
    198e:	80 91 9e 01 	lds	r24, 0x019E	; 0x80019e <__data_end>
    1992:	90 91 9f 01 	lds	r25, 0x019F	; 0x80019f <__data_end+0x1>
prvSetMainLedOn():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/variantHooks.cpp:101
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    1996:	25 9a       	sbi	0x04, 5	; 4
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/variantHooks.cpp:102
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
    1998:	2d 9a       	sbi	0x05, 5	; 5
_delay_ms():
c:\program files (x86)\arduino\hardware\tools\avr\avr\include\util/delay.h:187
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    199a:	2f ef       	ldi	r18, 0xFF	; 255
    199c:	87 ea       	ldi	r24, 0xA7	; 167
    199e:	91 e6       	ldi	r25, 0x61	; 97
    19a0:	21 50       	subi	r18, 0x01	; 1
    19a2:	80 40       	sbci	r24, 0x00	; 0
    19a4:	90 40       	sbci	r25, 0x00	; 0
    19a6:	e1 f7       	brne	.-8      	; 0x19a0 <vPortYield+0xa4>
    19a8:	00 c0       	rjmp	.+0      	; 0x19aa <vPortYield+0xae>
    19aa:	00 00       	nop
prvBlinkMainLed():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/variantHooks.cpp:125

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle.
    19ac:	1d 9a       	sbi	0x03, 5	; 3
    19ae:	f5 cf       	rjmp	.-22     	; 0x199a <vPortYield+0x9e>
vTaskSwitchContext():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3061
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    19b0:	20 91 32 02 	lds	r18, 0x0232	; 0x800232 <uxTopReadyPriority>
    19b4:	89 e0       	ldi	r24, 0x09	; 9
    19b6:	01 c0       	rjmp	.+2      	; 0x19ba <vPortYield+0xbe>
    19b8:	21 50       	subi	r18, 0x01	; 1
    19ba:	42 2f       	mov	r20, r18
    19bc:	50 e0       	ldi	r21, 0x00	; 0
    19be:	84 9f       	mul	r24, r20
    19c0:	f0 01       	movw	r30, r0
    19c2:	85 9f       	mul	r24, r21
    19c4:	f0 0d       	add	r31, r0
    19c6:	11 24       	eor	r1, r1
    19c8:	e2 5f       	subi	r30, 0xF2	; 242
    19ca:	fd 4f       	sbci	r31, 0xFD	; 253
    19cc:	90 81       	ld	r25, Z
    19ce:	99 23       	and	r25, r25
    19d0:	99 f3       	breq	.-26     	; 0x19b8 <vPortYield+0xbc>
    19d2:	a1 81       	ldd	r26, Z+1	; 0x01
    19d4:	b2 81       	ldd	r27, Z+2	; 0x02
    19d6:	12 96       	adiw	r26, 0x02	; 2
    19d8:	0d 90       	ld	r0, X+
    19da:	bc 91       	ld	r27, X
    19dc:	a0 2d       	mov	r26, r0
    19de:	b2 83       	std	Z+2, r27	; 0x02
    19e0:	a1 83       	std	Z+1, r26	; 0x01
    19e2:	28 9f       	mul	r18, r24
    19e4:	c0 01       	movw	r24, r0
    19e6:	11 24       	eor	r1, r1
    19e8:	8f 5e       	subi	r24, 0xEF	; 239
    19ea:	9d 4f       	sbci	r25, 0xFD	; 253
    19ec:	a8 17       	cp	r26, r24
    19ee:	b9 07       	cpc	r27, r25
    19f0:	29 f4       	brne	.+10     	; 0x19fc <vPortYield+0x100>
    19f2:	12 96       	adiw	r26, 0x02	; 2
    19f4:	8d 91       	ld	r24, X+
    19f6:	9c 91       	ld	r25, X
    19f8:	92 83       	std	Z+2, r25	; 0x02
    19fa:	81 83       	std	Z+1, r24	; 0x01
    19fc:	89 e0       	ldi	r24, 0x09	; 9
    19fe:	84 9f       	mul	r24, r20
    1a00:	f0 01       	movw	r30, r0
    1a02:	85 9f       	mul	r24, r21
    1a04:	f0 0d       	add	r31, r0
    1a06:	11 24       	eor	r1, r1
    1a08:	e2 5f       	subi	r30, 0xF2	; 242
    1a0a:	fd 4f       	sbci	r31, 0xFD	; 253
    1a0c:	01 80       	ldd	r0, Z+1	; 0x01
    1a0e:	f2 81       	ldd	r31, Z+2	; 0x02
    1a10:	e0 2d       	mov	r30, r0
    1a12:	86 81       	ldd	r24, Z+6	; 0x06
    1a14:	97 81       	ldd	r25, Z+7	; 0x07
    1a16:	90 93 9f 01 	sts	0x019F, r25	; 0x80019f <__data_end+0x1>
    1a1a:	80 93 9e 01 	sts	0x019E, r24	; 0x80019e <__data_end>
    1a1e:	20 93 32 02 	sts	0x0232, r18	; 0x800232 <uxTopReadyPriority>
vPortYield():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/port.c:627
    vTaskSwitchContext();
    portRESTORE_CONTEXT();
    1a22:	a0 91 9e 01 	lds	r26, 0x019E	; 0x80019e <__data_end>
    1a26:	b0 91 9f 01 	lds	r27, 0x019F	; 0x80019f <__data_end+0x1>
    1a2a:	cd 91       	ld	r28, X+
    1a2c:	cd bf       	out	0x3d, r28	; 61
    1a2e:	dd 91       	ld	r29, X+
    1a30:	de bf       	out	0x3e, r29	; 62
    1a32:	ff 91       	pop	r31
    1a34:	ef 91       	pop	r30
    1a36:	df 91       	pop	r29
    1a38:	cf 91       	pop	r28
    1a3a:	bf 91       	pop	r27
    1a3c:	af 91       	pop	r26
    1a3e:	9f 91       	pop	r25
    1a40:	8f 91       	pop	r24
    1a42:	7f 91       	pop	r23
    1a44:	6f 91       	pop	r22
    1a46:	5f 91       	pop	r21
    1a48:	4f 91       	pop	r20
    1a4a:	3f 91       	pop	r19
    1a4c:	2f 91       	pop	r18
    1a4e:	1f 91       	pop	r17
    1a50:	0f 91       	pop	r16
    1a52:	ff 90       	pop	r15
    1a54:	ef 90       	pop	r14
    1a56:	df 90       	pop	r13
    1a58:	cf 90       	pop	r12
    1a5a:	bf 90       	pop	r11
    1a5c:	af 90       	pop	r10
    1a5e:	9f 90       	pop	r9
    1a60:	8f 90       	pop	r8
    1a62:	7f 90       	pop	r7
    1a64:	6f 90       	pop	r6
    1a66:	5f 90       	pop	r5
    1a68:	4f 90       	pop	r4
    1a6a:	3f 90       	pop	r3
    1a6c:	2f 90       	pop	r2
    1a6e:	1f 90       	pop	r1
    1a70:	0f 90       	pop	r0
    1a72:	0f be       	out	0x3f, r0	; 63
    1a74:	0f 90       	pop	r0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/port.c:629

    __asm__ __volatile__ ( "ret" );
    1a76:	08 95       	ret

00001a78 <xTaskResumeAll>:
xTaskResumeAll():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2208

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    1a78:	8f 92       	push	r8
    1a7a:	9f 92       	push	r9
    1a7c:	bf 92       	push	r11
    1a7e:	cf 92       	push	r12
    1a80:	df 92       	push	r13
    1a82:	ef 92       	push	r14
    1a84:	ff 92       	push	r15
    1a86:	0f 93       	push	r16
    1a88:	1f 93       	push	r17
    1a8a:	cf 93       	push	r28
    1a8c:	df 93       	push	r29
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2221
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    1a8e:	0f b6       	in	r0, 0x3f	; 63
    1a90:	f8 94       	cli
    1a92:	0f 92       	push	r0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2223
    {
        --uxSchedulerSuspended;
    1a94:	80 91 d7 01 	lds	r24, 0x01D7	; 0x8001d7 <uxSchedulerSuspended>
    1a98:	81 50       	subi	r24, 0x01	; 1
    1a9a:	80 93 d7 01 	sts	0x01D7, r24	; 0x8001d7 <uxSchedulerSuspended>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2225

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1a9e:	80 91 d7 01 	lds	r24, 0x01D7	; 0x8001d7 <uxSchedulerSuspended>
    1aa2:	88 23       	and	r24, r24
    1aa4:	79 f0       	breq	.+30     	; 0x1ac4 <xTaskResumeAll+0x4c>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2210
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    TCB_t * pxTCB = NULL;
    BaseType_t xAlreadyYielded = pdFALSE;
    1aa6:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2313
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    1aa8:	0f 90       	pop	r0
    1aaa:	0f be       	out	0x3f, r0	; 63
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2316

    return xAlreadyYielded;
}
    1aac:	df 91       	pop	r29
    1aae:	cf 91       	pop	r28
    1ab0:	1f 91       	pop	r17
    1ab2:	0f 91       	pop	r16
    1ab4:	ff 90       	pop	r15
    1ab6:	ef 90       	pop	r14
    1ab8:	df 90       	pop	r13
    1aba:	cf 90       	pop	r12
    1abc:	bf 90       	pop	r11
    1abe:	9f 90       	pop	r9
    1ac0:	8f 90       	pop	r8
    1ac2:	08 95       	ret
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2227
    {
        --uxSchedulerSuspended;

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    1ac4:	80 91 35 02 	lds	r24, 0x0235	; 0x800235 <uxCurrentNumberOfTasks>
    1ac8:	88 23       	and	r24, r24
    1aca:	69 f3       	breq	.-38     	; 0x1aa6 <xTaskResumeAll+0x2e>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2233
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1acc:	e0 90 f8 01 	lds	r14, 0x01F8	; 0x8001f8 <xPendingReadyList+0x5>
    1ad0:	f0 90 f9 01 	lds	r15, 0x01F9	; 0x8001f9 <xPendingReadyList+0x6>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2209
#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    TCB_t * pxTCB = NULL;
    1ad4:	f0 e0       	ldi	r31, 0x00	; 0
    1ad6:	e0 e0       	ldi	r30, 0x00	; 0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2237
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
                    prvAddTaskToReadyList( pxTCB );
    1ad8:	39 e0       	ldi	r19, 0x09	; 9
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2243

                    /* If the moved task has a priority higher than the current
                     * task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
                    {
                        xYieldPending = pdTRUE;
    1ada:	41 e0       	ldi	r20, 0x01	; 1
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2231
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    1adc:	80 91 f3 01 	lds	r24, 0x01F3	; 0x8001f3 <xPendingReadyList>
    1ae0:	81 11       	cpse	r24, r1
    1ae2:	5e c0       	rjmp	.+188    	; 0x1ba0 <xTaskResumeAll+0x128>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2251
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    1ae4:	ef 2b       	or	r30, r31
    1ae6:	11 f0       	breq	.+4      	; 0x1aec <xTaskResumeAll+0x74>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2259
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    1ae8:	0e 94 1d 0a 	call	0x143a	; 0x143a <prvResetNextTaskUnblockTime>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2267
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    1aec:	e0 90 ac 01 	lds	r14, 0x01AC	; 0x8001ac <xPendedTicks>
    1af0:	f0 90 ad 01 	lds	r15, 0x01AD	; 0x8001ad <xPendedTicks+0x1>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2269

                    if( xPendedCounts > ( TickType_t ) 0U )
    1af4:	e1 14       	cp	r14, r1
    1af6:	f1 04       	cpc	r15, r1
    1af8:	09 f4       	brne	.+2      	; 0x1afc <xTaskResumeAll+0x84>
    1afa:	7d c1       	rjmp	.+762    	; 0x1df6 <xTaskResumeAll+0x37e>
xTaskIncrementTick():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2840
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    1afc:	89 e0       	ldi	r24, 0x09	; 9
    1afe:	d8 2e       	mov	r13, r24
xTaskResumeAll():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2275
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
                            {
                                xYieldPending = pdTRUE;
    1b00:	cc 24       	eor	r12, r12
    1b02:	c3 94       	inc	r12
xTaskIncrementTick():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2768
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1b04:	0f ef       	ldi	r16, 0xFF	; 255
    1b06:	1f ef       	ldi	r17, 0xFF	; 255
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2734
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1b08:	80 91 d7 01 	lds	r24, 0x01D7	; 0x8001d7 <uxSchedulerSuspended>
    1b0c:	81 11       	cpse	r24, r1
    1b0e:	61 c1       	rjmp	.+706    	; 0x1dd2 <xTaskResumeAll+0x35a>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2738
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    1b10:	c0 91 da 01 	lds	r28, 0x01DA	; 0x8001da <xTickCount>
    1b14:	d0 91 db 01 	lds	r29, 0x01DB	; 0x8001db <xTickCount+0x1>
    1b18:	4e 01       	movw	r8, r28
    1b1a:	8f ef       	ldi	r24, 0xFF	; 255
    1b1c:	88 1a       	sub	r8, r24
    1b1e:	98 0a       	sbc	r9, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2742

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    1b20:	90 92 db 01 	sts	0x01DB, r9	; 0x8001db <xTickCount+0x1>
    1b24:	80 92 da 01 	sts	0x01DA, r8	; 0x8001da <xTickCount>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2744

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    1b28:	81 14       	cp	r8, r1
    1b2a:	91 04       	cpc	r9, r1
    1b2c:	b9 f4       	brne	.+46     	; 0x1b5c <xTaskResumeAll+0xe4>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2746
        {
            taskSWITCH_DELAYED_LISTS();
    1b2e:	80 91 df 01 	lds	r24, 0x01DF	; 0x8001df <pxDelayedTaskList>
    1b32:	90 91 e0 01 	lds	r25, 0x01E0	; 0x8001e0 <pxDelayedTaskList+0x1>
    1b36:	20 91 dd 01 	lds	r18, 0x01DD	; 0x8001dd <pxOverflowDelayedTaskList>
    1b3a:	30 91 de 01 	lds	r19, 0x01DE	; 0x8001de <pxOverflowDelayedTaskList+0x1>
    1b3e:	30 93 e0 01 	sts	0x01E0, r19	; 0x8001e0 <pxDelayedTaskList+0x1>
    1b42:	20 93 df 01 	sts	0x01DF, r18	; 0x8001df <pxDelayedTaskList>
    1b46:	90 93 de 01 	sts	0x01DE, r25	; 0x8001de <pxOverflowDelayedTaskList+0x1>
    1b4a:	80 93 dd 01 	sts	0x01DD, r24	; 0x8001dd <pxOverflowDelayedTaskList>
    1b4e:	80 91 dc 01 	lds	r24, 0x01DC	; 0x8001dc <xNumOfOverflows>
    1b52:	8f 5f       	subi	r24, 0xFF	; 255
    1b54:	80 93 dc 01 	sts	0x01DC, r24	; 0x8001dc <xNumOfOverflows>
    1b58:	0e 94 1d 0a 	call	0x143a	; 0x143a <prvResetNextTaskUnblockTime>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2757

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    1b5c:	80 91 d3 01 	lds	r24, 0x01D3	; 0x8001d3 <xNextTaskUnblockTime>
    1b60:	90 91 d4 01 	lds	r25, 0x01D4	; 0x8001d4 <xNextTaskUnblockTime+0x1>
xTaskResumeAll():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2727

BaseType_t xTaskIncrementTick( void )
{
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    1b64:	b1 2c       	mov	r11, r1
xTaskIncrementTick():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2757

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    1b66:	88 16       	cp	r8, r24
    1b68:	99 06       	cpc	r9, r25
    1b6a:	08 f0       	brcs	.+2      	; 0x1b6e <xTaskResumeAll+0xf6>
    1b6c:	26 c1       	rjmp	.+588    	; 0x1dba <xTaskResumeAll+0x342>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2840
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    1b6e:	e0 91 9e 01 	lds	r30, 0x019E	; 0x80019e <__data_end>
    1b72:	f0 91 9f 01 	lds	r31, 0x019F	; 0x80019f <__data_end+0x1>
    1b76:	e6 89       	ldd	r30, Z+22	; 0x16
    1b78:	de 9e       	mul	r13, r30
    1b7a:	f0 01       	movw	r30, r0
    1b7c:	11 24       	eor	r1, r1
    1b7e:	e2 5f       	subi	r30, 0xF2	; 242
    1b80:	fd 4f       	sbci	r31, 0xFD	; 253
    1b82:	80 81       	ld	r24, Z
    1b84:	82 30       	cpi	r24, 0x02	; 2
    1b86:	10 f0       	brcs	.+4      	; 0x1b8c <xTaskResumeAll+0x114>
xTaskResumeAll():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2842
                {
                    xSwitchRequired = pdTRUE;
    1b88:	bb 24       	eor	r11, r11
    1b8a:	b3 94       	inc	r11
xTaskIncrementTick():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2868
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
    1b8c:	80 91 ae 01 	lds	r24, 0x01AE	; 0x8001ae <xYieldPending>
    1b90:	81 11       	cpse	r24, r1
    1b92:	03 c0       	rjmp	.+6      	; 0x1b9a <xTaskResumeAll+0x122>
xTaskResumeAll():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2273

                    if( xPendedCounts > ( TickType_t ) 0U )
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    1b94:	bb 20       	and	r11, r11
    1b96:	09 f4       	brne	.+2      	; 0x1b9a <xTaskResumeAll+0x122>
    1b98:	25 c1       	rjmp	.+586    	; 0x1de4 <xTaskResumeAll+0x36c>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2275
                            {
                                xYieldPending = pdTRUE;
    1b9a:	c0 92 ae 01 	sts	0x01AE, r12	; 0x8001ae <xYieldPending>
    1b9e:	22 c1       	rjmp	.+580    	; 0x1de4 <xTaskResumeAll+0x36c>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2233
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1ba0:	d7 01       	movw	r26, r14
    1ba2:	16 96       	adiw	r26, 0x06	; 6
    1ba4:	ed 91       	ld	r30, X+
    1ba6:	fc 91       	ld	r31, X
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2234
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    1ba8:	a4 89       	ldd	r26, Z+20	; 0x14
    1baa:	b5 89       	ldd	r27, Z+21	; 0x15
    1bac:	66 85       	ldd	r22, Z+14	; 0x0e
    1bae:	77 85       	ldd	r23, Z+15	; 0x0f
    1bb0:	80 89       	ldd	r24, Z+16	; 0x10
    1bb2:	91 89       	ldd	r25, Z+17	; 0x11
    1bb4:	eb 01       	movw	r28, r22
    1bb6:	9d 83       	std	Y+5, r25	; 0x05
    1bb8:	8c 83       	std	Y+4, r24	; 0x04
    1bba:	80 89       	ldd	r24, Z+16	; 0x10
    1bbc:	91 89       	ldd	r25, Z+17	; 0x11
    1bbe:	ec 01       	movw	r28, r24
    1bc0:	7b 83       	std	Y+3, r23	; 0x03
    1bc2:	6a 83       	std	Y+2, r22	; 0x02
    1bc4:	bf 01       	movw	r22, r30
    1bc6:	64 5f       	subi	r22, 0xF4	; 244
    1bc8:	7f 4f       	sbci	r23, 0xFF	; 255
    1bca:	11 96       	adiw	r26, 0x01	; 1
    1bcc:	0d 91       	ld	r16, X+
    1bce:	1c 91       	ld	r17, X
    1bd0:	12 97       	sbiw	r26, 0x02	; 2
    1bd2:	06 17       	cp	r16, r22
    1bd4:	17 07       	cpc	r17, r23
    1bd6:	21 f4       	brne	.+8      	; 0x1be0 <xTaskResumeAll+0x168>
    1bd8:	12 96       	adiw	r26, 0x02	; 2
    1bda:	9c 93       	st	X, r25
    1bdc:	8e 93       	st	-X, r24
    1bde:	11 97       	sbiw	r26, 0x01	; 1
    1be0:	15 8a       	std	Z+21, r1	; 0x15
    1be2:	14 8a       	std	Z+20, r1	; 0x14
    1be4:	8c 91       	ld	r24, X
    1be6:	81 50       	subi	r24, 0x01	; 1
    1be8:	8c 93       	st	X, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2236
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    1bea:	a2 85       	ldd	r26, Z+10	; 0x0a
    1bec:	b3 85       	ldd	r27, Z+11	; 0x0b
    1bee:	84 81       	ldd	r24, Z+4	; 0x04
    1bf0:	95 81       	ldd	r25, Z+5	; 0x05
    1bf2:	66 81       	ldd	r22, Z+6	; 0x06
    1bf4:	77 81       	ldd	r23, Z+7	; 0x07
    1bf6:	ec 01       	movw	r28, r24
    1bf8:	7d 83       	std	Y+5, r23	; 0x05
    1bfa:	6c 83       	std	Y+4, r22	; 0x04
    1bfc:	66 81       	ldd	r22, Z+6	; 0x06
    1bfe:	77 81       	ldd	r23, Z+7	; 0x07
    1c00:	eb 01       	movw	r28, r22
    1c02:	9b 83       	std	Y+3, r25	; 0x03
    1c04:	8a 83       	std	Y+2, r24	; 0x02
    1c06:	cf 01       	movw	r24, r30
    1c08:	02 96       	adiw	r24, 0x02	; 2
    1c0a:	11 96       	adiw	r26, 0x01	; 1
    1c0c:	0d 91       	ld	r16, X+
    1c0e:	1c 91       	ld	r17, X
    1c10:	12 97       	sbiw	r26, 0x02	; 2
    1c12:	08 17       	cp	r16, r24
    1c14:	19 07       	cpc	r17, r25
    1c16:	21 f4       	brne	.+8      	; 0x1c20 <xTaskResumeAll+0x1a8>
    1c18:	12 96       	adiw	r26, 0x02	; 2
    1c1a:	7c 93       	st	X, r23
    1c1c:	6e 93       	st	-X, r22
    1c1e:	11 97       	sbiw	r26, 0x01	; 1
    1c20:	13 86       	std	Z+11, r1	; 0x0b
    1c22:	12 86       	std	Z+10, r1	; 0x0a
    1c24:	2c 91       	ld	r18, X
    1c26:	21 50       	subi	r18, 0x01	; 1
    1c28:	2c 93       	st	X, r18
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2237
                    prvAddTaskToReadyList( pxTCB );
    1c2a:	a6 89       	ldd	r26, Z+22	; 0x16
    1c2c:	20 91 32 02 	lds	r18, 0x0232	; 0x800232 <uxTopReadyPriority>
    1c30:	2a 17       	cp	r18, r26
    1c32:	10 f4       	brcc	.+4      	; 0x1c38 <xTaskResumeAll+0x1c0>
    1c34:	a0 93 32 02 	sts	0x0232, r26	; 0x800232 <uxTopReadyPriority>
    1c38:	3a 9f       	mul	r19, r26
    1c3a:	d0 01       	movw	r26, r0
    1c3c:	11 24       	eor	r1, r1
    1c3e:	a2 5f       	subi	r26, 0xF2	; 242
    1c40:	bd 4f       	sbci	r27, 0xFD	; 253
    1c42:	11 96       	adiw	r26, 0x01	; 1
    1c44:	0d 90       	ld	r0, X+
    1c46:	bc 91       	ld	r27, X
    1c48:	a0 2d       	mov	r26, r0
    1c4a:	b5 83       	std	Z+5, r27	; 0x05
    1c4c:	a4 83       	std	Z+4, r26	; 0x04
    1c4e:	14 96       	adiw	r26, 0x04	; 4
    1c50:	6d 91       	ld	r22, X+
    1c52:	7c 91       	ld	r23, X
    1c54:	15 97       	sbiw	r26, 0x05	; 5
    1c56:	77 83       	std	Z+7, r23	; 0x07
    1c58:	66 83       	std	Z+6, r22	; 0x06
    1c5a:	14 96       	adiw	r26, 0x04	; 4
    1c5c:	6d 91       	ld	r22, X+
    1c5e:	7c 91       	ld	r23, X
    1c60:	15 97       	sbiw	r26, 0x05	; 5
    1c62:	eb 01       	movw	r28, r22
    1c64:	9b 83       	std	Y+3, r25	; 0x03
    1c66:	8a 83       	std	Y+2, r24	; 0x02
    1c68:	15 96       	adiw	r26, 0x05	; 5
    1c6a:	9c 93       	st	X, r25
    1c6c:	8e 93       	st	-X, r24
    1c6e:	14 97       	sbiw	r26, 0x04	; 4
    1c70:	96 89       	ldd	r25, Z+22	; 0x16
    1c72:	93 9f       	mul	r25, r19
    1c74:	d0 01       	movw	r26, r0
    1c76:	11 24       	eor	r1, r1
    1c78:	a2 5f       	subi	r26, 0xF2	; 242
    1c7a:	bd 4f       	sbci	r27, 0xFD	; 253
    1c7c:	b3 87       	std	Z+11, r27	; 0x0b
    1c7e:	a2 87       	std	Z+10, r26	; 0x0a
    1c80:	8c 91       	ld	r24, X
    1c82:	8f 5f       	subi	r24, 0xFF	; 255
    1c84:	8c 93       	st	X, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2241

                    /* If the moved task has a priority higher than the current
                     * task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1c86:	a0 91 9e 01 	lds	r26, 0x019E	; 0x80019e <__data_end>
    1c8a:	b0 91 9f 01 	lds	r27, 0x019F	; 0x80019f <__data_end+0x1>
    1c8e:	56 96       	adiw	r26, 0x16	; 22
    1c90:	8c 91       	ld	r24, X
    1c92:	98 17       	cp	r25, r24
    1c94:	08 f4       	brcc	.+2      	; 0x1c98 <xTaskResumeAll+0x220>
    1c96:	22 cf       	rjmp	.-444    	; 0x1adc <xTaskResumeAll+0x64>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2243
                    {
                        xYieldPending = pdTRUE;
    1c98:	40 93 ae 01 	sts	0x01AE, r20	; 0x8001ae <xYieldPending>
    1c9c:	1f cf       	rjmp	.-450    	; 0x1adc <xTaskResumeAll+0x64>
xTaskIncrementTick():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2777
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1c9e:	e0 91 df 01 	lds	r30, 0x01DF	; 0x8001df <pxDelayedTaskList>
    1ca2:	f0 91 e0 01 	lds	r31, 0x01E0	; 0x8001e0 <pxDelayedTaskList+0x1>
    1ca6:	05 80       	ldd	r0, Z+5	; 0x05
    1ca8:	f6 81       	ldd	r31, Z+6	; 0x06
    1caa:	e0 2d       	mov	r30, r0
    1cac:	06 80       	ldd	r0, Z+6	; 0x06
    1cae:	f7 81       	ldd	r31, Z+7	; 0x07
    1cb0:	e0 2d       	mov	r30, r0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2778
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    1cb2:	82 81       	ldd	r24, Z+2	; 0x02
    1cb4:	93 81       	ldd	r25, Z+3	; 0x03
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2780

                    if( xConstTickCount < xItemValue )
    1cb6:	88 16       	cp	r8, r24
    1cb8:	99 06       	cpc	r9, r25
    1cba:	28 f4       	brcc	.+10     	; 0x1cc6 <xTaskResumeAll+0x24e>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2787
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    1cbc:	90 93 d4 01 	sts	0x01D4, r25	; 0x8001d4 <xNextTaskUnblockTime+0x1>
    1cc0:	80 93 d3 01 	sts	0x01D3, r24	; 0x8001d3 <xNextTaskUnblockTime>
    1cc4:	54 cf       	rjmp	.-344    	; 0x1b6e <xTaskResumeAll+0xf6>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2796
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    1cc6:	c2 85       	ldd	r28, Z+10	; 0x0a
    1cc8:	d3 85       	ldd	r29, Z+11	; 0x0b
    1cca:	84 81       	ldd	r24, Z+4	; 0x04
    1ccc:	95 81       	ldd	r25, Z+5	; 0x05
    1cce:	26 81       	ldd	r18, Z+6	; 0x06
    1cd0:	37 81       	ldd	r19, Z+7	; 0x07
    1cd2:	dc 01       	movw	r26, r24
    1cd4:	15 96       	adiw	r26, 0x05	; 5
    1cd6:	3c 93       	st	X, r19
    1cd8:	2e 93       	st	-X, r18
    1cda:	14 97       	sbiw	r26, 0x04	; 4
    1cdc:	26 81       	ldd	r18, Z+6	; 0x06
    1cde:	37 81       	ldd	r19, Z+7	; 0x07
    1ce0:	d9 01       	movw	r26, r18
    1ce2:	13 96       	adiw	r26, 0x03	; 3
    1ce4:	9c 93       	st	X, r25
    1ce6:	8e 93       	st	-X, r24
    1ce8:	12 97       	sbiw	r26, 0x02	; 2
    1cea:	cf 01       	movw	r24, r30
    1cec:	02 96       	adiw	r24, 0x02	; 2
    1cee:	49 81       	ldd	r20, Y+1	; 0x01
    1cf0:	5a 81       	ldd	r21, Y+2	; 0x02
    1cf2:	48 17       	cp	r20, r24
    1cf4:	59 07       	cpc	r21, r25
    1cf6:	11 f4       	brne	.+4      	; 0x1cfc <xTaskResumeAll+0x284>
    1cf8:	3a 83       	std	Y+2, r19	; 0x02
    1cfa:	29 83       	std	Y+1, r18	; 0x01
    1cfc:	13 86       	std	Z+11, r1	; 0x0b
    1cfe:	12 86       	std	Z+10, r1	; 0x0a
    1d00:	28 81       	ld	r18, Y
    1d02:	21 50       	subi	r18, 0x01	; 1
    1d04:	28 83       	st	Y, r18
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2800

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1d06:	a4 89       	ldd	r26, Z+20	; 0x14
    1d08:	b5 89       	ldd	r27, Z+21	; 0x15
    1d0a:	10 97       	sbiw	r26, 0x00	; 0
    1d0c:	f9 f0       	breq	.+62     	; 0x1d4c <xTaskResumeAll+0x2d4>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2802
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    1d0e:	26 85       	ldd	r18, Z+14	; 0x0e
    1d10:	37 85       	ldd	r19, Z+15	; 0x0f
    1d12:	40 89       	ldd	r20, Z+16	; 0x10
    1d14:	51 89       	ldd	r21, Z+17	; 0x11
    1d16:	e9 01       	movw	r28, r18
    1d18:	5d 83       	std	Y+5, r21	; 0x05
    1d1a:	4c 83       	std	Y+4, r20	; 0x04
    1d1c:	40 89       	ldd	r20, Z+16	; 0x10
    1d1e:	51 89       	ldd	r21, Z+17	; 0x11
    1d20:	ea 01       	movw	r28, r20
    1d22:	3b 83       	std	Y+3, r19	; 0x03
    1d24:	2a 83       	std	Y+2, r18	; 0x02
    1d26:	11 96       	adiw	r26, 0x01	; 1
    1d28:	6d 91       	ld	r22, X+
    1d2a:	7c 91       	ld	r23, X
    1d2c:	12 97       	sbiw	r26, 0x02	; 2
    1d2e:	9f 01       	movw	r18, r30
    1d30:	24 5f       	subi	r18, 0xF4	; 244
    1d32:	3f 4f       	sbci	r19, 0xFF	; 255
    1d34:	62 17       	cp	r22, r18
    1d36:	73 07       	cpc	r23, r19
    1d38:	21 f4       	brne	.+8      	; 0x1d42 <xTaskResumeAll+0x2ca>
    1d3a:	12 96       	adiw	r26, 0x02	; 2
    1d3c:	5c 93       	st	X, r21
    1d3e:	4e 93       	st	-X, r20
    1d40:	11 97       	sbiw	r26, 0x01	; 1
    1d42:	15 8a       	std	Z+21, r1	; 0x15
    1d44:	14 8a       	std	Z+20, r1	; 0x14
    1d46:	2c 91       	ld	r18, X
    1d48:	21 50       	subi	r18, 0x01	; 1
    1d4a:	2c 93       	st	X, r18
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2811
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    1d4c:	a6 89       	ldd	r26, Z+22	; 0x16
    1d4e:	20 91 32 02 	lds	r18, 0x0232	; 0x800232 <uxTopReadyPriority>
    1d52:	2a 17       	cp	r18, r26
    1d54:	10 f4       	brcc	.+4      	; 0x1d5a <xTaskResumeAll+0x2e2>
    1d56:	a0 93 32 02 	sts	0x0232, r26	; 0x800232 <uxTopReadyPriority>
    1d5a:	da 9e       	mul	r13, r26
    1d5c:	d0 01       	movw	r26, r0
    1d5e:	11 24       	eor	r1, r1
    1d60:	a2 5f       	subi	r26, 0xF2	; 242
    1d62:	bd 4f       	sbci	r27, 0xFD	; 253
    1d64:	11 96       	adiw	r26, 0x01	; 1
    1d66:	0d 90       	ld	r0, X+
    1d68:	bc 91       	ld	r27, X
    1d6a:	a0 2d       	mov	r26, r0
    1d6c:	b5 83       	std	Z+5, r27	; 0x05
    1d6e:	a4 83       	std	Z+4, r26	; 0x04
    1d70:	14 96       	adiw	r26, 0x04	; 4
    1d72:	2d 91       	ld	r18, X+
    1d74:	3c 91       	ld	r19, X
    1d76:	15 97       	sbiw	r26, 0x05	; 5
    1d78:	37 83       	std	Z+7, r19	; 0x07
    1d7a:	26 83       	std	Z+6, r18	; 0x06
    1d7c:	14 96       	adiw	r26, 0x04	; 4
    1d7e:	2d 91       	ld	r18, X+
    1d80:	3c 91       	ld	r19, X
    1d82:	15 97       	sbiw	r26, 0x05	; 5
    1d84:	e9 01       	movw	r28, r18
    1d86:	9b 83       	std	Y+3, r25	; 0x03
    1d88:	8a 83       	std	Y+2, r24	; 0x02
    1d8a:	15 96       	adiw	r26, 0x05	; 5
    1d8c:	9c 93       	st	X, r25
    1d8e:	8e 93       	st	-X, r24
    1d90:	14 97       	sbiw	r26, 0x04	; 4
    1d92:	96 89       	ldd	r25, Z+22	; 0x16
    1d94:	9d 9d       	mul	r25, r13
    1d96:	d0 01       	movw	r26, r0
    1d98:	11 24       	eor	r1, r1
    1d9a:	a2 5f       	subi	r26, 0xF2	; 242
    1d9c:	bd 4f       	sbci	r27, 0xFD	; 253
    1d9e:	b3 87       	std	Z+11, r27	; 0x0b
    1da0:	a2 87       	std	Z+10, r26	; 0x0a
    1da2:	8c 91       	ld	r24, X
    1da4:	8f 5f       	subi	r24, 0xFF	; 255
    1da6:	8c 93       	st	X, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2821
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1da8:	e0 91 9e 01 	lds	r30, 0x019E	; 0x80019e <__data_end>
    1dac:	f0 91 9f 01 	lds	r31, 0x019F	; 0x80019f <__data_end+0x1>
    1db0:	86 89       	ldd	r24, Z+22	; 0x16
    1db2:	98 17       	cp	r25, r24
    1db4:	10 f0       	brcs	.+4      	; 0x1dba <xTaskResumeAll+0x342>
xTaskResumeAll():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2823
                            {
                                xSwitchRequired = pdTRUE;
    1db6:	bb 24       	eor	r11, r11
    1db8:	b3 94       	inc	r11
xTaskIncrementTick():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2761
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1dba:	e0 91 df 01 	lds	r30, 0x01DF	; 0x8001df <pxDelayedTaskList>
    1dbe:	f0 91 e0 01 	lds	r31, 0x01E0	; 0x8001e0 <pxDelayedTaskList+0x1>
    1dc2:	80 81       	ld	r24, Z
    1dc4:	81 11       	cpse	r24, r1
    1dc6:	6b cf       	rjmp	.-298    	; 0x1c9e <xTaskResumeAll+0x226>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2768
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1dc8:	10 93 d4 01 	sts	0x01D4, r17	; 0x8001d4 <xNextTaskUnblockTime+0x1>
    1dcc:	00 93 d3 01 	sts	0x01D3, r16	; 0x8001d3 <xNextTaskUnblockTime>
    1dd0:	ce ce       	rjmp	.-612    	; 0x1b6e <xTaskResumeAll+0xf6>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2881
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    1dd2:	80 91 ac 01 	lds	r24, 0x01AC	; 0x8001ac <xPendedTicks>
    1dd6:	90 91 ad 01 	lds	r25, 0x01AD	; 0x8001ad <xPendedTicks+0x1>
    1dda:	01 96       	adiw	r24, 0x01	; 1
    1ddc:	90 93 ad 01 	sts	0x01AD, r25	; 0x8001ad <xPendedTicks+0x1>
    1de0:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <xPendedTicks>
xTaskResumeAll():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2282
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    1de4:	d1 e0       	ldi	r29, 0x01	; 1
    1de6:	ed 1a       	sub	r14, r29
    1de8:	f1 08       	sbc	r15, r1
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2283
                        } while( xPendedCounts > ( TickType_t ) 0U );
    1dea:	09 f0       	breq	.+2      	; 0x1dee <xTaskResumeAll+0x376>
    1dec:	8d ce       	rjmp	.-742    	; 0x1b08 <xTaskResumeAll+0x90>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2285

                        xPendedTicks = 0;
    1dee:	10 92 ad 01 	sts	0x01AD, r1	; 0x8001ad <xPendedTicks+0x1>
    1df2:	10 92 ac 01 	sts	0x01AC, r1	; 0x8001ac <xPendedTicks>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2293
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    1df6:	80 91 ae 01 	lds	r24, 0x01AE	; 0x8001ae <xYieldPending>
    1dfa:	88 23       	and	r24, r24
    1dfc:	09 f4       	brne	.+2      	; 0x1e00 <xTaskResumeAll+0x388>
    1dfe:	53 ce       	rjmp	.-858    	; 0x1aa6 <xTaskResumeAll+0x2e>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2300
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    1e00:	0e 94 7e 0c 	call	0x18fc	; 0x18fc <vPortYield>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2297

                if( xYieldPending != pdFALSE )
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
    1e04:	81 e0       	ldi	r24, 0x01	; 1
    1e06:	50 ce       	rjmp	.-864    	; 0x1aa8 <xTaskResumeAll+0x30>

00001e08 <vTaskDelay.constprop.57>:
vTaskDelay.constprop.57():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:1340

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    1e08:	0e 94 17 0b 	call	0x162e	; 0x162e <vTaskSuspendAll>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:1351
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    1e0c:	60 e0       	ldi	r22, 0x00	; 0
    1e0e:	8f e1       	ldi	r24, 0x1F	; 31
    1e10:	90 e0       	ldi	r25, 0x00	; 0
    1e12:	0e 94 ee 0b 	call	0x17dc	; 0x17dc <prvAddCurrentTaskToDelayedList>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:1353
            }
            xAlreadyYielded = xTaskResumeAll();
    1e16:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <xTaskResumeAll>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:1362
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    1e1a:	81 11       	cpse	r24, r1
    1e1c:	02 c0       	rjmp	.+4      	; 0x1e22 <vTaskDelay.constprop.57+0x1a>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:1364
        {
            portYIELD_WITHIN_API();
    1e1e:	0e 94 7e 0c 	call	0x18fc	; 0x18fc <vPortYield>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:1370
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    1e22:	08 95       	ret

00001e24 <xQueueGenericSend.constprop.6>:
xQueueGenericSend.constprop.6():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:767
    }

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
    1e24:	af 92       	push	r10
    1e26:	bf 92       	push	r11
    1e28:	cf 92       	push	r12
    1e2a:	df 92       	push	r13
    1e2c:	ef 92       	push	r14
    1e2e:	ff 92       	push	r15
    1e30:	0f 93       	push	r16
    1e32:	1f 93       	push	r17
    1e34:	cf 93       	push	r28
    1e36:	df 93       	push	r29
    1e38:	00 d0       	rcall	.+0      	; 0x1e3a <xQueueGenericSend.constprop.6+0x16>
    1e3a:	00 d0       	rcall	.+0      	; 0x1e3c <xQueueGenericSend.constprop.6+0x18>
    1e3c:	1f 92       	push	r1
    1e3e:	cd b7       	in	r28, 0x3d	; 61
    1e40:	de b7       	in	r29, 0x3e	; 62
    1e42:	8c 01       	movw	r16, r24
    1e44:	7b 01       	movw	r14, r22
    1e46:	1d 82       	std	Y+5, r1	; 0x05
    1e48:	1c 82       	std	Y+4, r1	; 0x04
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:772
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1e4a:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:940
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1e4c:	68 01       	movw	r12, r16
    1e4e:	98 e0       	ldi	r25, 0x08	; 8
    1e50:	c9 0e       	add	r12, r25
    1e52:	d1 1c       	adc	r13, r1
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:790
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    1e54:	0f b6       	in	r0, 0x3f	; 63
    1e56:	f8 94       	cli
    1e58:	0f 92       	push	r0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:796
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1e5a:	d8 01       	movw	r26, r16
    1e5c:	5a 96       	adiw	r26, 0x1a	; 26
    1e5e:	2c 91       	ld	r18, X
    1e60:	5a 97       	sbiw	r26, 0x1a	; 26
    1e62:	5b 96       	adiw	r26, 0x1b	; 27
    1e64:	9c 91       	ld	r25, X
    1e66:	5b 97       	sbiw	r26, 0x1b	; 27
    1e68:	29 17       	cp	r18, r25
    1e6a:	08 f0       	brcs	.+2      	; 0x1e6e <xQueueGenericSend.constprop.6+0x4a>
    1e6c:	b0 c0       	rjmp	.+352    	; 0x1fce <xQueueGenericSend.constprop.6+0x1aa>
prvCopyDataToQueue():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2131
    BaseType_t xReturn = pdFALSE;
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1e6e:	5a 96       	adiw	r26, 0x1a	; 26
    1e70:	dc 90       	ld	r13, X
    1e72:	5a 97       	sbiw	r26, 0x1a	; 26
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2133

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1e74:	5c 96       	adiw	r26, 0x1c	; 28
    1e76:	4c 91       	ld	r20, X
    1e78:	5c 97       	sbiw	r26, 0x1c	; 28
    1e7a:	41 11       	cpse	r20, r1
    1e7c:	8d c0       	rjmp	.+282    	; 0x1f98 <xQueueGenericSend.constprop.6+0x174>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2137
    {
        #if ( configUSE_MUTEXES == 1 )
            {
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1e7e:	8d 91       	ld	r24, X+
    1e80:	9c 91       	ld	r25, X
    1e82:	89 2b       	or	r24, r25
    1e84:	11 f0       	breq	.+4      	; 0x1e8a <xQueueGenericSend.constprop.6+0x66>
xQueueGenericSend.constprop.6():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2126

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    BaseType_t xReturn = pdFALSE;
    1e86:	80 e0       	ldi	r24, 0x00	; 0
    1e88:	0a c0       	rjmp	.+20     	; 0x1e9e <xQueueGenericSend.constprop.6+0x7a>
prvCopyDataToQueue():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2140
        #if ( configUSE_MUTEXES == 1 )
            {
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
                {
                    /* The mutex is no longer being held. */
                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
    1e8a:	f8 01       	movw	r30, r16
    1e8c:	e4 80       	ldd	r14, Z+4	; 0x04
    1e8e:	f5 80       	ldd	r15, Z+5	; 0x05
xTaskPriorityDisinherit():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:4150
    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
        TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
        BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
    1e90:	e1 14       	cp	r14, r1
    1e92:	f1 04       	cpc	r15, r1
    1e94:	39 f5       	brne	.+78     	; 0x1ee4 <xQueueGenericSend.constprop.6+0xc0>
xQueueGenericSend.constprop.6():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:4148
#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
        TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
        BaseType_t xReturn = pdFALSE;
    1e96:	80 e0       	ldi	r24, 0x00	; 0
prvCopyDataToQueue():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2141
                    pxQueue->u.xSemaphore.xMutexHolder = NULL;
    1e98:	f8 01       	movw	r30, r16
    1e9a:	15 82       	std	Z+5, r1	; 0x05
    1e9c:	14 82       	std	Z+4, r1	; 0x04
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2199
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1e9e:	d3 94       	inc	r13
    1ea0:	d8 01       	movw	r26, r16
    1ea2:	5a 96       	adiw	r26, 0x1a	; 26
    1ea4:	dc 92       	st	X, r13
    1ea6:	5a 97       	sbiw	r26, 0x1a	; 26
xQueueGenericSend.constprop.6():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:866
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1ea8:	51 96       	adiw	r26, 0x11	; 17
    1eaa:	9c 91       	ld	r25, X
    1eac:	99 23       	and	r25, r25
    1eae:	21 f0       	breq	.+8      	; 0x1eb8 <xQueueGenericSend.constprop.6+0x94>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:868
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1eb0:	c8 01       	movw	r24, r16
    1eb2:	41 96       	adiw	r24, 0x11	; 17
    1eb4:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <xTaskRemoveFromEventList>
    1eb8:	81 11       	cpse	r24, r1
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:874
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
    1eba:	0e 94 7e 0c 	call	0x18fc	; 0x18fc <vPortYield>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:896
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    1ebe:	0f 90       	pop	r0
    1ec0:	0f be       	out	0x3f, r0	; 63
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:897
                return pdPASS;
    1ec2:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:976

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
        }
    } /*lint -restore */
}
    1ec4:	0f 90       	pop	r0
    1ec6:	0f 90       	pop	r0
    1ec8:	0f 90       	pop	r0
    1eca:	0f 90       	pop	r0
    1ecc:	0f 90       	pop	r0
    1ece:	df 91       	pop	r29
    1ed0:	cf 91       	pop	r28
    1ed2:	1f 91       	pop	r17
    1ed4:	0f 91       	pop	r16
    1ed6:	ff 90       	pop	r15
    1ed8:	ef 90       	pop	r14
    1eda:	df 90       	pop	r13
    1edc:	cf 90       	pop	r12
    1ede:	bf 90       	pop	r11
    1ee0:	af 90       	pop	r10
    1ee2:	08 95       	ret
xTaskPriorityDisinherit():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:4158
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    1ee4:	d7 01       	movw	r26, r14
    1ee6:	92 96       	adiw	r26, 0x22	; 34
    1ee8:	8c 91       	ld	r24, X
    1eea:	92 97       	sbiw	r26, 0x22	; 34
    1eec:	81 50       	subi	r24, 0x01	; 1
    1eee:	92 96       	adiw	r26, 0x22	; 34
    1ef0:	8c 93       	st	X, r24
    1ef2:	92 97       	sbiw	r26, 0x22	; 34
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:4162

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1ef4:	56 96       	adiw	r26, 0x16	; 22
    1ef6:	2c 91       	ld	r18, X
    1ef8:	56 97       	sbiw	r26, 0x16	; 22
    1efa:	91 96       	adiw	r26, 0x21	; 33
    1efc:	9c 91       	ld	r25, X
    1efe:	29 17       	cp	r18, r25
    1f00:	51 f2       	breq	.-108    	; 0x1e96 <xQueueGenericSend.constprop.6+0x72>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:4165
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    1f02:	81 11       	cpse	r24, r1
    1f04:	c8 cf       	rjmp	.-112    	; 0x1e96 <xQueueGenericSend.constprop.6+0x72>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:4172
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1f06:	57 01       	movw	r10, r14
    1f08:	b2 e0       	ldi	r27, 0x02	; 2
    1f0a:	ab 0e       	add	r10, r27
    1f0c:	b1 1c       	adc	r11, r1
    1f0e:	c5 01       	movw	r24, r10
    1f10:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uxListRemove>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:4184
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    1f14:	f7 01       	movw	r30, r14
    1f16:	81 a1       	ldd	r24, Z+33	; 0x21
    1f18:	86 8b       	std	Z+22, r24	; 0x16
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:4189

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1f1a:	48 2f       	mov	r20, r24
    1f1c:	50 e0       	ldi	r21, 0x00	; 0
    1f1e:	24 e0       	ldi	r18, 0x04	; 4
    1f20:	30 e0       	ldi	r19, 0x00	; 0
    1f22:	24 1b       	sub	r18, r20
    1f24:	35 0b       	sbc	r19, r21
    1f26:	35 87       	std	Z+13, r19	; 0x0d
    1f28:	24 87       	std	Z+12, r18	; 0x0c
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:4190
                    prvAddTaskToReadyList( pxTCB );
    1f2a:	90 91 32 02 	lds	r25, 0x0232	; 0x800232 <uxTopReadyPriority>
    1f2e:	98 17       	cp	r25, r24
    1f30:	10 f4       	brcc	.+4      	; 0x1f36 <xQueueGenericSend.constprop.6+0x112>
    1f32:	80 93 32 02 	sts	0x0232, r24	; 0x800232 <uxTopReadyPriority>
    1f36:	89 e0       	ldi	r24, 0x09	; 9
    1f38:	84 9f       	mul	r24, r20
    1f3a:	d0 01       	movw	r26, r0
    1f3c:	85 9f       	mul	r24, r21
    1f3e:	b0 0d       	add	r27, r0
    1f40:	11 24       	eor	r1, r1
    1f42:	a2 5f       	subi	r26, 0xF2	; 242
    1f44:	bd 4f       	sbci	r27, 0xFD	; 253
    1f46:	11 96       	adiw	r26, 0x01	; 1
    1f48:	0d 90       	ld	r0, X+
    1f4a:	bc 91       	ld	r27, X
    1f4c:	a0 2d       	mov	r26, r0
    1f4e:	f7 01       	movw	r30, r14
    1f50:	b5 83       	std	Z+5, r27	; 0x05
    1f52:	a4 83       	std	Z+4, r26	; 0x04
    1f54:	14 96       	adiw	r26, 0x04	; 4
    1f56:	2d 91       	ld	r18, X+
    1f58:	3c 91       	ld	r19, X
    1f5a:	15 97       	sbiw	r26, 0x05	; 5
    1f5c:	37 83       	std	Z+7, r19	; 0x07
    1f5e:	26 83       	std	Z+6, r18	; 0x06
    1f60:	14 96       	adiw	r26, 0x04	; 4
    1f62:	ed 91       	ld	r30, X+
    1f64:	fc 91       	ld	r31, X
    1f66:	15 97       	sbiw	r26, 0x05	; 5
    1f68:	b3 82       	std	Z+3, r11	; 0x03
    1f6a:	a2 82       	std	Z+2, r10	; 0x02
    1f6c:	15 96       	adiw	r26, 0x05	; 5
    1f6e:	bc 92       	st	X, r11
    1f70:	ae 92       	st	-X, r10
    1f72:	14 97       	sbiw	r26, 0x04	; 4
    1f74:	d7 01       	movw	r26, r14
    1f76:	56 96       	adiw	r26, 0x16	; 22
    1f78:	ec 91       	ld	r30, X
    1f7a:	56 97       	sbiw	r26, 0x16	; 22
    1f7c:	e8 9f       	mul	r30, r24
    1f7e:	f0 01       	movw	r30, r0
    1f80:	11 24       	eor	r1, r1
    1f82:	e2 5f       	subi	r30, 0xF2	; 242
    1f84:	fd 4f       	sbci	r31, 0xFD	; 253
    1f86:	1b 96       	adiw	r26, 0x0b	; 11
    1f88:	fc 93       	st	X, r31
    1f8a:	ee 93       	st	-X, r30
    1f8c:	1a 97       	sbiw	r26, 0x0a	; 10
    1f8e:	80 81       	ld	r24, Z
    1f90:	8f 5f       	subi	r24, 0xFF	; 255
    1f92:	80 83       	st	Z, r24
    1f94:	81 e0       	ldi	r24, 0x01	; 1
    1f96:	80 cf       	rjmp	.-256    	; 0x1e98 <xQueueGenericSend.constprop.6+0x74>
prvCopyDataToQueue():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2152
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1f98:	50 e0       	ldi	r21, 0x00	; 0
    1f9a:	b7 01       	movw	r22, r14
    1f9c:	12 96       	adiw	r26, 0x02	; 2
    1f9e:	8d 91       	ld	r24, X+
    1fa0:	9c 91       	ld	r25, X
    1fa2:	0e 94 a3 19 	call	0x3346	; 0x3346 <memcpy>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2153
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1fa6:	f8 01       	movw	r30, r16
    1fa8:	84 8d       	ldd	r24, Z+28	; 0x1c
    1faa:	22 81       	ldd	r18, Z+2	; 0x02
    1fac:	33 81       	ldd	r19, Z+3	; 0x03
    1fae:	82 0f       	add	r24, r18
    1fb0:	93 2f       	mov	r25, r19
    1fb2:	91 1d       	adc	r25, r1
    1fb4:	93 83       	std	Z+3, r25	; 0x03
    1fb6:	82 83       	std	Z+2, r24	; 0x02
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2155

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1fb8:	24 81       	ldd	r18, Z+4	; 0x04
    1fba:	35 81       	ldd	r19, Z+5	; 0x05
    1fbc:	82 17       	cp	r24, r18
    1fbe:	93 07       	cpc	r25, r19
    1fc0:	08 f4       	brcc	.+2      	; 0x1fc4 <xQueueGenericSend.constprop.6+0x1a0>
    1fc2:	61 cf       	rjmp	.-318    	; 0x1e86 <xQueueGenericSend.constprop.6+0x62>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2157
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    1fc4:	80 81       	ld	r24, Z
    1fc6:	91 81       	ldd	r25, Z+1	; 0x01
    1fc8:	93 83       	std	Z+3, r25	; 0x03
    1fca:	82 83       	std	Z+2, r24	; 0x02
    1fcc:	5c cf       	rjmp	.-328    	; 0x1e86 <xQueueGenericSend.constprop.6+0x62>
xQueueGenericSend.constprop.6():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:901
                taskEXIT_CRITICAL();
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1fce:	2c 81       	ldd	r18, Y+4	; 0x04
    1fd0:	3d 81       	ldd	r19, Y+5	; 0x05
    1fd2:	23 2b       	or	r18, r19
    1fd4:	21 f4       	brne	.+8      	; 0x1fde <xQueueGenericSend.constprop.6+0x1ba>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:905
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    1fd6:	0f 90       	pop	r0
    1fd8:	0f be       	out	0x3f, r0	; 63
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:973
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
            ( void ) xTaskResumeAll();

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    1fda:	80 e0       	ldi	r24, 0x00	; 0
    1fdc:	73 cf       	rjmp	.-282    	; 0x1ec4 <xQueueGenericSend.constprop.6+0xa0>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:912
                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
                }
                else if( xEntryTimeSet == pdFALSE )
    1fde:	81 11       	cpse	r24, r1
    1fe0:	09 c0       	rjmp	.+18     	; 0x1ff4 <xQueueGenericSend.constprop.6+0x1d0>
vTaskInternalSetTimeOutState():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3295
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    1fe2:	80 91 dc 01 	lds	r24, 0x01DC	; 0x8001dc <xNumOfOverflows>
    1fe6:	89 83       	std	Y+1, r24	; 0x01
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3296
    pxTimeOut->xTimeOnEntering = xTickCount;
    1fe8:	80 91 da 01 	lds	r24, 0x01DA	; 0x8001da <xTickCount>
    1fec:	90 91 db 01 	lds	r25, 0x01DB	; 0x8001db <xTickCount+0x1>
    1ff0:	9b 83       	std	Y+3, r25	; 0x03
    1ff2:	8a 83       	std	Y+2, r24	; 0x02
xQueueGenericSend.constprop.6():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:926
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1ff4:	0f 90       	pop	r0
    1ff6:	0f be       	out	0x3f, r0	; 63
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:931

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    1ff8:	0e 94 17 0b 	call	0x162e	; 0x162e <vTaskSuspendAll>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:932
        prvLockQueue( pxQueue );
    1ffc:	0f b6       	in	r0, 0x3f	; 63
    1ffe:	f8 94       	cli
    2000:	0f 92       	push	r0
    2002:	f8 01       	movw	r30, r16
    2004:	85 8d       	ldd	r24, Z+29	; 0x1d
    2006:	8f 3f       	cpi	r24, 0xFF	; 255
    2008:	09 f4       	brne	.+2      	; 0x200c <xQueueGenericSend.constprop.6+0x1e8>
    200a:	15 8e       	std	Z+29, r1	; 0x1d
    200c:	d8 01       	movw	r26, r16
    200e:	5e 96       	adiw	r26, 0x1e	; 30
    2010:	8c 91       	ld	r24, X
    2012:	5e 97       	sbiw	r26, 0x1e	; 30
    2014:	8f 3f       	cpi	r24, 0xFF	; 255
    2016:	11 f4       	brne	.+4      	; 0x201c <xQueueGenericSend.constprop.6+0x1f8>
    2018:	5e 96       	adiw	r26, 0x1e	; 30
    201a:	1c 92       	st	X, r1
    201c:	0f 90       	pop	r0
    201e:	0f be       	out	0x3f, r0	; 63
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:935

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2020:	be 01       	movw	r22, r28
    2022:	6c 5f       	subi	r22, 0xFC	; 252
    2024:	7f 4f       	sbci	r23, 0xFF	; 255
    2026:	ce 01       	movw	r24, r28
    2028:	01 96       	adiw	r24, 0x01	; 1
    202a:	0e 94 35 0a 	call	0x146a	; 0x146a <xTaskCheckForTimeOut>
    202e:	81 11       	cpse	r24, r1
    2030:	2a c0       	rjmp	.+84     	; 0x2086 <xQueueGenericSend.constprop.6+0x262>
prvIsQueueFull():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2391

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    2032:	0f b6       	in	r0, 0x3f	; 63
    2034:	f8 94       	cli
    2036:	0f 92       	push	r0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2393
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2038:	f8 01       	movw	r30, r16
    203a:	92 8d       	ldd	r25, Z+26	; 0x1a
    203c:	83 8d       	ldd	r24, Z+27	; 0x1b
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2402
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    203e:	0f 90       	pop	r0
    2040:	0f be       	out	0x3f, r0	; 63
xQueueGenericSend.constprop.6():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:937
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2042:	98 13       	cpse	r25, r24
    2044:	1a c0       	rjmp	.+52     	; 0x207a <xQueueGenericSend.constprop.6+0x256>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:940
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2046:	ac 80       	ldd	r10, Y+4	; 0x04
    2048:	bd 80       	ldd	r11, Y+5	; 0x05
vTaskPlaceOnEventList():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3096

    /* Place the event list item of the TCB in the appropriate event list.
     * This is placed in the list in priority order so the highest priority task
     * is the first to be woken by the event.  The queue that contains the event
     * list is locked, preventing simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    204a:	60 91 9e 01 	lds	r22, 0x019E	; 0x80019e <__data_end>
    204e:	70 91 9f 01 	lds	r23, 0x019F	; 0x80019f <__data_end+0x1>
    2052:	64 5f       	subi	r22, 0xF4	; 244
    2054:	7f 4f       	sbci	r23, 0xFF	; 255
    2056:	c6 01       	movw	r24, r12
    2058:	0e 94 8e 0b 	call	0x171c	; 0x171c <vListInsert>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3098

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    205c:	61 e0       	ldi	r22, 0x01	; 1
    205e:	c5 01       	movw	r24, r10
    2060:	0e 94 ee 0b 	call	0x17dc	; 0x17dc <prvAddCurrentTaskToDelayedList>
xQueueGenericSend.constprop.6():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:947
                /* Unlocking the queue means queue events can effect the
                 * event list.  It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready last instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    2064:	c8 01       	movw	r24, r16
    2066:	0e 94 28 0b 	call	0x1650	; 0x1650 <prvUnlockQueue>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:954
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in a ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    206a:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <xTaskResumeAll>
    206e:	81 11       	cpse	r24, r1
    2070:	02 c0       	rjmp	.+4      	; 0x2076 <xQueueGenericSend.constprop.6+0x252>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:956
                {
                    portYIELD_WITHIN_API();
    2072:	0e 94 7e 0c 	call	0x18fc	; 0x18fc <vPortYield>
    2076:	81 e0       	ldi	r24, 0x01	; 1
    2078:	ed ce       	rjmp	.-550    	; 0x1e54 <xQueueGenericSend.constprop.6+0x30>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:962
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    207a:	c8 01       	movw	r24, r16
    207c:	0e 94 28 0b 	call	0x1650	; 0x1650 <prvUnlockQueue>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:963
                ( void ) xTaskResumeAll();
    2080:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <xTaskResumeAll>
    2084:	f8 cf       	rjmp	.-16     	; 0x2076 <xQueueGenericSend.constprop.6+0x252>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:969
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    2086:	c8 01       	movw	r24, r16
    2088:	0e 94 28 0b 	call	0x1650	; 0x1650 <prvUnlockQueue>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:970
            ( void ) xTaskResumeAll();
    208c:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <xTaskResumeAll>
    2090:	a4 cf       	rjmp	.-184    	; 0x1fda <xQueueGenericSend.constprop.6+0x1b6>

00002092 <xTimerGenericCommand.constprop.3>:
xTimerGenericCommand.constprop.3():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:373
            traceTIMER_CREATE( pxNewTimer );
        }
    }
/*-----------------------------------------------------------*/

    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer,
    2092:	cf 93       	push	r28
    2094:	df 93       	push	r29
    2096:	00 d0       	rcall	.+0      	; 0x2098 <xTimerGenericCommand.constprop.3+0x6>
    2098:	00 d0       	rcall	.+0      	; 0x209a <xTimerGenericCommand.constprop.3+0x8>
    209a:	1f 92       	push	r1
    209c:	cd b7       	in	r28, 0x3d	; 61
    209e:	de b7       	in	r29, 0x3e	; 62
    20a0:	9c 01       	movw	r18, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:386

        configASSERT( xTimer );

        /* Send a message to the timer service task to perform a particular action
         * on a particular timer definition. */
        if( xTimerQueue != NULL )
    20a2:	80 91 d8 01 	lds	r24, 0x01D8	; 0x8001d8 <xTimerQueue>
    20a6:	90 91 d9 01 	lds	r25, 0x01D9	; 0x8001d9 <xTimerQueue+0x1>
    20aa:	00 97       	sbiw	r24, 0x00	; 0
    20ac:	b9 f0       	breq	.+46     	; 0x20dc <xTimerGenericCommand.constprop.3+0x4a>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:389
        {
            /* Send a command to the timer service task to start the xTimer timer. */
            xMessage.xMessageID = xCommandID;
    20ae:	19 82       	std	Y+1, r1	; 0x01
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:390
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    20b0:	7b 83       	std	Y+3, r23	; 0x03
    20b2:	6a 83       	std	Y+2, r22	; 0x02
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:391
            xMessage.u.xTimerParameters.pxTimer = xTimer;
    20b4:	3d 83       	std	Y+5, r19	; 0x05
    20b6:	2c 83       	std	Y+4, r18	; 0x04
xTaskGetSchedulerState():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:4031

    BaseType_t xTaskGetSchedulerState( void )
    {
        BaseType_t xReturn;

        if( xSchedulerRunning == pdFALSE )
    20b8:	20 91 34 02 	lds	r18, 0x0234	; 0x800234 <xSchedulerRunning>
xTimerGenericCommand.constprop.3():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:397

            if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
            {
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    20bc:	be 01       	movw	r22, r28
    20be:	6f 5f       	subi	r22, 0xFF	; 255
    20c0:	7f 4f       	sbci	r23, 0xFF	; 255
xTaskGetSchedulerState():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:4031
    20c2:	21 11       	cpse	r18, r1
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:4037
        {
            xReturn = taskSCHEDULER_NOT_STARTED;
        }
        else
        {
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    20c4:	20 91 d7 01 	lds	r18, 0x01D7	; 0x8001d7 <uxSchedulerSuspended>
xTimerGenericCommand.constprop.3():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:401
                }
                else
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    20c8:	0e 94 12 0f 	call	0x1e24	; 0x1e24 <xQueueGenericSend.constprop.6>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:417
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    20cc:	0f 90       	pop	r0
    20ce:	0f 90       	pop	r0
    20d0:	0f 90       	pop	r0
    20d2:	0f 90       	pop	r0
    20d4:	0f 90       	pop	r0
    20d6:	df 91       	pop	r29
    20d8:	cf 91       	pop	r28
    20da:	08 95       	ret
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:379
                                     const BaseType_t xCommandID,
                                     const TickType_t xOptionalValue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const TickType_t xTicksToWait )
    {
        BaseType_t xReturn = pdFAIL;
    20dc:	80 e0       	ldi	r24, 0x00	; 0
    20de:	f6 cf       	rjmp	.-20     	; 0x20cc <xTimerGenericCommand.constprop.3+0x3a>

000020e0 <prvSwitchTimerLists>:
prvSwitchTimerLists():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:890
        }
    }
/*-----------------------------------------------------------*/

    static void prvSwitchTimerLists( void )
    {
    20e0:	ef 92       	push	r14
    20e2:	ff 92       	push	r15
    20e4:	0f 93       	push	r16
    20e6:	1f 93       	push	r17
    20e8:	cf 93       	push	r28
    20ea:	df 93       	push	r29
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:900

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    20ec:	e0 91 bd 01 	lds	r30, 0x01BD	; 0x8001bd <pxCurrentTimerList>
    20f0:	f0 91 be 01 	lds	r31, 0x01BE	; 0x8001be <pxCurrentTimerList+0x1>
    20f4:	80 81       	ld	r24, Z
    20f6:	81 11       	cpse	r24, r1
    20f8:	13 c0       	rjmp	.+38     	; 0x2120 <prvSwitchTimerLists+0x40>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:944
                mtCOVERAGE_TEST_MARKER();
            }
        }

        pxTemp = pxCurrentTimerList;
        pxCurrentTimerList = pxOverflowTimerList;
    20fa:	80 91 bb 01 	lds	r24, 0x01BB	; 0x8001bb <pxOverflowTimerList>
    20fe:	90 91 bc 01 	lds	r25, 0x01BC	; 0x8001bc <pxOverflowTimerList+0x1>
    2102:	90 93 be 01 	sts	0x01BE, r25	; 0x8001be <pxCurrentTimerList+0x1>
    2106:	80 93 bd 01 	sts	0x01BD, r24	; 0x8001bd <pxCurrentTimerList>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:945
        pxOverflowTimerList = pxTemp;
    210a:	f0 93 bc 01 	sts	0x01BC, r31	; 0x8001bc <pxOverflowTimerList+0x1>
    210e:	e0 93 bb 01 	sts	0x01BB, r30	; 0x8001bb <pxOverflowTimerList>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:946
    }
    2112:	df 91       	pop	r29
    2114:	cf 91       	pop	r28
    2116:	1f 91       	pop	r17
    2118:	0f 91       	pop	r16
    211a:	ff 90       	pop	r15
    211c:	ef 90       	pop	r14
    211e:	08 95       	ret
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:902
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2120:	05 80       	ldd	r0, Z+5	; 0x05
    2122:	f6 81       	ldd	r31, Z+6	; 0x06
    2124:	e0 2d       	mov	r30, r0
    2126:	00 81       	ld	r16, Z
    2128:	11 81       	ldd	r17, Z+1	; 0x01
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:905

            /* Remove the timer from the list. */
            pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    212a:	c6 81       	ldd	r28, Z+6	; 0x06
    212c:	d7 81       	ldd	r29, Z+7	; 0x07
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:906
            ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    212e:	7e 01       	movw	r14, r28
    2130:	82 e0       	ldi	r24, 0x02	; 2
    2132:	e8 0e       	add	r14, r24
    2134:	f1 1c       	adc	r15, r1
    2136:	c7 01       	movw	r24, r14
    2138:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uxListRemove>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:912
            traceTIMER_EXPIRED( pxTimer );

            /* Execute its callback, then send a command to restart the timer if
             * it is an auto-reload timer.  It cannot be restarted here as the lists
             * have not yet been switched. */
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    213c:	e8 89       	ldd	r30, Y+16	; 0x10
    213e:	f9 89       	ldd	r31, Y+17	; 0x11
    2140:	ce 01       	movw	r24, r28
    2142:	09 95       	icall
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:914

            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    2144:	8a 89       	ldd	r24, Y+18	; 0x12
    2146:	82 ff       	sbrs	r24, 2
    2148:	d1 cf       	rjmp	.-94     	; 0x20ec <prvSwitchTimerLists+0xc>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:922
                 * the timer going into the same timer list then it has already expired
                 * and the timer should be re-inserted into the current list so it is
                 * processed again within this loop.  Otherwise a command should be sent
                 * to restart the timer to ensure it is only inserted into a list after
                 * the lists have been swapped. */
                xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    214a:	8c 85       	ldd	r24, Y+12	; 0x0c
    214c:	9d 85       	ldd	r25, Y+13	; 0x0d
    214e:	80 0f       	add	r24, r16
    2150:	91 1f       	adc	r25, r17
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:924

                if( xReloadTime > xNextExpireTime )
    2152:	08 17       	cp	r16, r24
    2154:	19 07       	cpc	r17, r25
    2156:	60 f4       	brcc	.+24     	; 0x2170 <prvSwitchTimerLists+0x90>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:926
                {
                    listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    2158:	9b 83       	std	Y+3, r25	; 0x03
    215a:	8a 83       	std	Y+2, r24	; 0x02
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:927
                    listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    215c:	d9 87       	std	Y+9, r29	; 0x09
    215e:	c8 87       	std	Y+8, r28	; 0x08
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:928
                    vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2160:	b7 01       	movw	r22, r14
    2162:	80 91 bd 01 	lds	r24, 0x01BD	; 0x8001bd <pxCurrentTimerList>
    2166:	90 91 be 01 	lds	r25, 0x01BE	; 0x8001be <pxCurrentTimerList+0x1>
    216a:	0e 94 8e 0b 	call	0x171c	; 0x171c <vListInsert>
    216e:	be cf       	rjmp	.-132    	; 0x20ec <prvSwitchTimerLists+0xc>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:932
                }
                else
                {
                    xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2170:	b8 01       	movw	r22, r16
    2172:	ce 01       	movw	r24, r28
    2174:	0e 94 49 10 	call	0x2092	; 0x2092 <xTimerGenericCommand.constprop.3>
    2178:	b9 cf       	rjmp	.-142    	; 0x20ec <prvSwitchTimerLists+0xc>

0000217a <xEventGroupSetBits>:
xEventGroupSetBits():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:533
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    217a:	af 92       	push	r10
    217c:	bf 92       	push	r11
    217e:	cf 92       	push	r12
    2180:	df 92       	push	r13
    2182:	ef 92       	push	r14
    2184:	ff 92       	push	r15
    2186:	0f 93       	push	r16
    2188:	1f 93       	push	r17
    218a:	cf 93       	push	r28
    218c:	df 93       	push	r29
    218e:	5c 01       	movw	r10, r24
    2190:	7b 01       	movw	r14, r22
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:547
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2192:	8c 01       	movw	r16, r24
    2194:	0b 5f       	subi	r16, 0xFB	; 251
    2196:	1f 4f       	sbci	r17, 0xFF	; 255
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:548
    vTaskSuspendAll();
    2198:	0e 94 17 0b 	call	0x162e	; 0x162e <vTaskSuspendAll>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:552
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    219c:	d5 01       	movw	r26, r10
    219e:	17 96       	adiw	r26, 0x07	; 7
    21a0:	ed 91       	ld	r30, X+
    21a2:	fc 91       	ld	r31, X
    21a4:	18 97       	sbiw	r26, 0x08	; 8
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:555

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    21a6:	6d 91       	ld	r22, X+
    21a8:	7c 91       	ld	r23, X
    21aa:	11 97       	sbiw	r26, 0x01	; 1
    21ac:	6e 29       	or	r22, r14
    21ae:	7f 29       	or	r23, r15
    21b0:	6d 93       	st	X+, r22
    21b2:	7c 93       	st	X, r23
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:537
                                const EventBits_t uxBitsToSet )
{
    ListItem_t * pxListItem, * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    21b4:	90 e0       	ldi	r25, 0x00	; 0
    21b6:	80 e0       	ldi	r24, 0x00	; 0
vTaskRemoveFromUnorderedEventList():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3267

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    prvAddTaskToReadyList( pxUnblockedTCB );
    21b8:	69 e0       	ldi	r22, 0x09	; 9
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3275
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    21ba:	71 e0       	ldi	r23, 0x01	; 1
    21bc:	d5 01       	movw	r26, r10
    21be:	2d 91       	ld	r18, X+
    21c0:	3c 91       	ld	r19, X
    21c2:	11 97       	sbiw	r26, 0x01	; 1
xEventGroupSetBits():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:558

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    21c4:	e0 17       	cp	r30, r16
    21c6:	f1 07       	cpc	r31, r17
    21c8:	b1 f4       	brne	.+44     	; 0x21f6 <xEventGroupSetBits+0x7c>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:618
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    21ca:	80 95       	com	r24
    21cc:	90 95       	com	r25
    21ce:	82 23       	and	r24, r18
    21d0:	93 23       	and	r25, r19
    21d2:	8d 93       	st	X+, r24
    21d4:	9c 93       	st	X, r25
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:620
    }
    ( void ) xTaskResumeAll();
    21d6:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <xTaskResumeAll>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:623

    return pxEventBits->uxEventBits;
}
    21da:	e5 01       	movw	r28, r10
    21dc:	88 81       	ld	r24, Y
    21de:	99 81       	ldd	r25, Y+1	; 0x01
    21e0:	df 91       	pop	r29
    21e2:	cf 91       	pop	r28
    21e4:	1f 91       	pop	r17
    21e6:	0f 91       	pop	r16
    21e8:	ff 90       	pop	r15
    21ea:	ef 90       	pop	r14
    21ec:	df 90       	pop	r13
    21ee:	cf 90       	pop	r12
    21f0:	bf 90       	pop	r11
    21f2:	af 90       	pop	r10
    21f4:	08 95       	ret
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:560
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
    21f6:	42 81       	ldd	r20, Z+2	; 0x02
    21f8:	53 81       	ldd	r21, Z+3	; 0x03
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:561
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    21fa:	e0 80       	ld	r14, Z
    21fc:	f1 80       	ldd	r15, Z+1	; 0x01
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:566
            xMatchFound = pdFALSE;

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    21fe:	d7 01       	movw	r26, r14
    2200:	bb 27       	eor	r27, r27
    2202:	6d 01       	movw	r12, r26
    2204:	c2 22       	and	r12, r18
    2206:	d3 22       	and	r13, r19
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:568

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    2208:	f2 fc       	sbrc	r15, 2
    220a:	04 c0       	rjmp	.+8      	; 0x2214 <xEventGroupSetBits+0x9a>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:571
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    220c:	cd 28       	or	r12, r13
    220e:	29 f4       	brne	.+10     	; 0x221a <xEventGroupSetBits+0xa0>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:533
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    2210:	fa 01       	movw	r30, r20
    2212:	d4 cf       	rjmp	.-88     	; 0x21bc <xEventGroupSetBits+0x42>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:580
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    2214:	ac 15       	cp	r26, r12
    2216:	bd 05       	cpc	r27, r13
    2218:	d9 f7       	brne	.-10     	; 0x2210 <xEventGroupSetBits+0x96>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:593
            }

            if( xMatchFound != pdFALSE )
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    221a:	f0 fe       	sbrs	r15, 0
    221c:	02 c0       	rjmp	.+4      	; 0x2222 <xEventGroupSetBits+0xa8>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/event_groups.c:595
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    221e:	8a 2b       	or	r24, r26
    2220:	9b 2b       	or	r25, r27
vTaskRemoveFromUnorderedEventList():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3241
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    2222:	32 68       	ori	r19, 0x82	; 130
    2224:	31 83       	std	Z+1, r19	; 0x01
    2226:	20 83       	st	Z, r18
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3245

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2228:	a6 81       	ldd	r26, Z+6	; 0x06
    222a:	b7 81       	ldd	r27, Z+7	; 0x07
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3247
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    222c:	20 85       	ldd	r18, Z+8	; 0x08
    222e:	31 85       	ldd	r19, Z+9	; 0x09
    2230:	e4 80       	ldd	r14, Z+4	; 0x04
    2232:	f5 80       	ldd	r15, Z+5	; 0x05
    2234:	ea 01       	movw	r28, r20
    2236:	fd 82       	std	Y+5, r15	; 0x05
    2238:	ec 82       	std	Y+4, r14	; 0x04
    223a:	e4 80       	ldd	r14, Z+4	; 0x04
    223c:	f5 80       	ldd	r15, Z+5	; 0x05
    223e:	e7 01       	movw	r28, r14
    2240:	5b 83       	std	Y+3, r21	; 0x03
    2242:	4a 83       	std	Y+2, r20	; 0x02
    2244:	e9 01       	movw	r28, r18
    2246:	c9 80       	ldd	r12, Y+1	; 0x01
    2248:	da 80       	ldd	r13, Y+2	; 0x02
    224a:	ec 15       	cp	r30, r12
    224c:	fd 05       	cpc	r31, r13
    224e:	11 f4       	brne	.+4      	; 0x2254 <xEventGroupSetBits+0xda>
    2250:	fa 82       	std	Y+2, r15	; 0x02
    2252:	e9 82       	std	Y+1, r14	; 0x01
    2254:	11 86       	std	Z+9, r1	; 0x09
    2256:	10 86       	std	Z+8, r1	; 0x08
    2258:	e9 01       	movw	r28, r18
    225a:	e8 81       	ld	r30, Y
    225c:	e1 50       	subi	r30, 0x01	; 1
    225e:	e8 83       	st	Y, r30
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3266
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    2260:	1a 96       	adiw	r26, 0x0a	; 10
    2262:	ed 91       	ld	r30, X+
    2264:	fc 91       	ld	r31, X
    2266:	1b 97       	sbiw	r26, 0x0b	; 11
    2268:	14 96       	adiw	r26, 0x04	; 4
    226a:	2d 91       	ld	r18, X+
    226c:	3c 91       	ld	r19, X
    226e:	15 97       	sbiw	r26, 0x05	; 5
    2270:	16 96       	adiw	r26, 0x06	; 6
    2272:	ed 90       	ld	r14, X+
    2274:	fc 90       	ld	r15, X
    2276:	17 97       	sbiw	r26, 0x07	; 7
    2278:	e9 01       	movw	r28, r18
    227a:	fd 82       	std	Y+5, r15	; 0x05
    227c:	ec 82       	std	Y+4, r14	; 0x04
    227e:	16 96       	adiw	r26, 0x06	; 6
    2280:	ed 90       	ld	r14, X+
    2282:	fc 90       	ld	r15, X
    2284:	17 97       	sbiw	r26, 0x07	; 7
    2286:	e7 01       	movw	r28, r14
    2288:	3b 83       	std	Y+3, r19	; 0x03
    228a:	2a 83       	std	Y+2, r18	; 0x02
    228c:	9d 01       	movw	r18, r26
    228e:	2e 5f       	subi	r18, 0xFE	; 254
    2290:	3f 4f       	sbci	r19, 0xFF	; 255
    2292:	c1 80       	ldd	r12, Z+1	; 0x01
    2294:	d2 80       	ldd	r13, Z+2	; 0x02
    2296:	c2 16       	cp	r12, r18
    2298:	d3 06       	cpc	r13, r19
    229a:	11 f4       	brne	.+4      	; 0x22a0 <xEventGroupSetBits+0x126>
    229c:	f2 82       	std	Z+2, r15	; 0x02
    229e:	e1 82       	std	Z+1, r14	; 0x01
    22a0:	1b 96       	adiw	r26, 0x0b	; 11
    22a2:	1c 92       	st	X, r1
    22a4:	1e 92       	st	-X, r1
    22a6:	1a 97       	sbiw	r26, 0x0a	; 10
    22a8:	f0 80       	ld	r15, Z
    22aa:	fa 94       	dec	r15
    22ac:	f0 82       	st	Z, r15
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3267
    prvAddTaskToReadyList( pxUnblockedTCB );
    22ae:	56 96       	adiw	r26, 0x16	; 22
    22b0:	ec 91       	ld	r30, X
    22b2:	56 97       	sbiw	r26, 0x16	; 22
    22b4:	f0 91 32 02 	lds	r31, 0x0232	; 0x800232 <uxTopReadyPriority>
    22b8:	fe 17       	cp	r31, r30
    22ba:	10 f4       	brcc	.+4      	; 0x22c0 <xEventGroupSetBits+0x146>
    22bc:	e0 93 32 02 	sts	0x0232, r30	; 0x800232 <uxTopReadyPriority>
    22c0:	6e 9f       	mul	r22, r30
    22c2:	f0 01       	movw	r30, r0
    22c4:	11 24       	eor	r1, r1
    22c6:	e2 5f       	subi	r30, 0xF2	; 242
    22c8:	fd 4f       	sbci	r31, 0xFD	; 253
    22ca:	01 80       	ldd	r0, Z+1	; 0x01
    22cc:	f2 81       	ldd	r31, Z+2	; 0x02
    22ce:	e0 2d       	mov	r30, r0
    22d0:	15 96       	adiw	r26, 0x05	; 5
    22d2:	fc 93       	st	X, r31
    22d4:	ee 93       	st	-X, r30
    22d6:	14 97       	sbiw	r26, 0x04	; 4
    22d8:	e4 80       	ldd	r14, Z+4	; 0x04
    22da:	f5 80       	ldd	r15, Z+5	; 0x05
    22dc:	17 96       	adiw	r26, 0x07	; 7
    22de:	fc 92       	st	X, r15
    22e0:	ee 92       	st	-X, r14
    22e2:	16 97       	sbiw	r26, 0x06	; 6
    22e4:	e4 80       	ldd	r14, Z+4	; 0x04
    22e6:	f5 80       	ldd	r15, Z+5	; 0x05
    22e8:	e7 01       	movw	r28, r14
    22ea:	3b 83       	std	Y+3, r19	; 0x03
    22ec:	2a 83       	std	Y+2, r18	; 0x02
    22ee:	35 83       	std	Z+5, r19	; 0x05
    22f0:	24 83       	std	Z+4, r18	; 0x04
    22f2:	56 96       	adiw	r26, 0x16	; 22
    22f4:	3c 91       	ld	r19, X
    22f6:	56 97       	sbiw	r26, 0x16	; 22
    22f8:	36 9f       	mul	r19, r22
    22fa:	f0 01       	movw	r30, r0
    22fc:	11 24       	eor	r1, r1
    22fe:	e2 5f       	subi	r30, 0xF2	; 242
    2300:	fd 4f       	sbci	r31, 0xFD	; 253
    2302:	1b 96       	adiw	r26, 0x0b	; 11
    2304:	fc 93       	st	X, r31
    2306:	ee 93       	st	-X, r30
    2308:	1a 97       	sbiw	r26, 0x0a	; 10
    230a:	20 81       	ld	r18, Z
    230c:	2f 5f       	subi	r18, 0xFF	; 255
    230e:	20 83       	st	Z, r18
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3269

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2310:	e0 91 9e 01 	lds	r30, 0x019E	; 0x80019e <__data_end>
    2314:	f0 91 9f 01 	lds	r31, 0x019F	; 0x80019f <__data_end+0x1>
    2318:	26 89       	ldd	r18, Z+22	; 0x16
    231a:	23 17       	cp	r18, r19
    231c:	08 f0       	brcs	.+2      	; 0x2320 <xEventGroupSetBits+0x1a6>
    231e:	78 cf       	rjmp	.-272    	; 0x2210 <xEventGroupSetBits+0x96>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3275
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    2320:	70 93 ae 01 	sts	0x01AE, r23	; 0x8001ae <xYieldPending>
    2324:	75 cf       	rjmp	.-278    	; 0x2210 <xEventGroupSetBits+0x96>

00002326 <vPortYieldFromTick>:
vPortYieldFromTick():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/port.c:657
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
    portSAVE_CONTEXT();
    2326:	0f 92       	push	r0
    2328:	0f b6       	in	r0, 0x3f	; 63
    232a:	f8 94       	cli
    232c:	0f 92       	push	r0
    232e:	1f 92       	push	r1
    2330:	11 24       	eor	r1, r1
    2332:	2f 92       	push	r2
    2334:	3f 92       	push	r3
    2336:	4f 92       	push	r4
    2338:	5f 92       	push	r5
    233a:	6f 92       	push	r6
    233c:	7f 92       	push	r7
    233e:	8f 92       	push	r8
    2340:	9f 92       	push	r9
    2342:	af 92       	push	r10
    2344:	bf 92       	push	r11
    2346:	cf 92       	push	r12
    2348:	df 92       	push	r13
    234a:	ef 92       	push	r14
    234c:	ff 92       	push	r15
    234e:	0f 93       	push	r16
    2350:	1f 93       	push	r17
    2352:	2f 93       	push	r18
    2354:	3f 93       	push	r19
    2356:	4f 93       	push	r20
    2358:	5f 93       	push	r21
    235a:	6f 93       	push	r22
    235c:	7f 93       	push	r23
    235e:	8f 93       	push	r24
    2360:	9f 93       	push	r25
    2362:	af 93       	push	r26
    2364:	bf 93       	push	r27
    2366:	cf 93       	push	r28
    2368:	df 93       	push	r29
    236a:	ef 93       	push	r30
    236c:	ff 93       	push	r31
    236e:	a0 91 9e 01 	lds	r26, 0x019E	; 0x80019e <__data_end>
    2372:	b0 91 9f 01 	lds	r27, 0x019F	; 0x80019f <__data_end+0x1>
    2376:	0d b6       	in	r0, 0x3d	; 61
    2378:	0d 92       	st	X+, r0
    237a:	0e b6       	in	r0, 0x3e	; 62
    237c:	0d 92       	st	X+, r0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/port.c:658
    sleep_reset();        /* reset the sleep_mode() faster than sleep_disable(); */
    237e:	13 be       	out	0x33, r1	; 51
xTaskIncrementTick():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2734
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2380:	80 91 d7 01 	lds	r24, 0x01D7	; 0x8001d7 <uxSchedulerSuspended>
    2384:	81 11       	cpse	r24, r1
    2386:	f9 c0       	rjmp	.+498    	; 0x257a <vPortYieldFromTick+0x254>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2738
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    2388:	80 91 da 01 	lds	r24, 0x01DA	; 0x8001da <xTickCount>
    238c:	90 91 db 01 	lds	r25, 0x01DB	; 0x8001db <xTickCount+0x1>
    2390:	01 96       	adiw	r24, 0x01	; 1
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2742

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    2392:	90 93 db 01 	sts	0x01DB, r25	; 0x8001db <xTickCount+0x1>
    2396:	80 93 da 01 	sts	0x01DA, r24	; 0x8001da <xTickCount>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2744

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    239a:	00 97       	sbiw	r24, 0x00	; 0
    239c:	81 f5       	brne	.+96     	; 0x23fe <vPortYieldFromTick+0xd8>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2746
        {
            taskSWITCH_DELAYED_LISTS();
    239e:	20 91 df 01 	lds	r18, 0x01DF	; 0x8001df <pxDelayedTaskList>
    23a2:	30 91 e0 01 	lds	r19, 0x01E0	; 0x8001e0 <pxDelayedTaskList+0x1>
    23a6:	40 91 dd 01 	lds	r20, 0x01DD	; 0x8001dd <pxOverflowDelayedTaskList>
    23aa:	50 91 de 01 	lds	r21, 0x01DE	; 0x8001de <pxOverflowDelayedTaskList+0x1>
    23ae:	50 93 e0 01 	sts	0x01E0, r21	; 0x8001e0 <pxDelayedTaskList+0x1>
    23b2:	40 93 df 01 	sts	0x01DF, r20	; 0x8001df <pxDelayedTaskList>
    23b6:	30 93 de 01 	sts	0x01DE, r19	; 0x8001de <pxOverflowDelayedTaskList+0x1>
    23ba:	20 93 dd 01 	sts	0x01DD, r18	; 0x8001dd <pxOverflowDelayedTaskList>
    23be:	20 91 dc 01 	lds	r18, 0x01DC	; 0x8001dc <xNumOfOverflows>
    23c2:	2f 5f       	subi	r18, 0xFF	; 255
    23c4:	20 93 dc 01 	sts	0x01DC, r18	; 0x8001dc <xNumOfOverflows>
prvResetNextTaskUnblockTime():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3989
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    23c8:	e0 91 df 01 	lds	r30, 0x01DF	; 0x8001df <pxDelayedTaskList>
    23cc:	f0 91 e0 01 	lds	r31, 0x01E0	; 0x8001e0 <pxDelayedTaskList+0x1>
    23d0:	20 81       	ld	r18, Z
    23d2:	21 11       	cpse	r18, r1
    23d4:	07 c0       	rjmp	.+14     	; 0x23e4 <vPortYieldFromTick+0xbe>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3995
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    23d6:	2f ef       	ldi	r18, 0xFF	; 255
    23d8:	3f ef       	ldi	r19, 0xFF	; 255
    23da:	30 93 d4 01 	sts	0x01D4, r19	; 0x8001d4 <xNextTaskUnblockTime+0x1>
    23de:	20 93 d3 01 	sts	0x01D3, r18	; 0x8001d3 <xNextTaskUnblockTime>
    23e2:	0d c0       	rjmp	.+26     	; 0x23fe <vPortYieldFromTick+0xd8>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:4003
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    23e4:	e0 91 df 01 	lds	r30, 0x01DF	; 0x8001df <pxDelayedTaskList>
    23e8:	f0 91 e0 01 	lds	r31, 0x01E0	; 0x8001e0 <pxDelayedTaskList+0x1>
    23ec:	05 80       	ldd	r0, Z+5	; 0x05
    23ee:	f6 81       	ldd	r31, Z+6	; 0x06
    23f0:	e0 2d       	mov	r30, r0
    23f2:	20 81       	ld	r18, Z
    23f4:	31 81       	ldd	r19, Z+1	; 0x01
    23f6:	30 93 d4 01 	sts	0x01D4, r19	; 0x8001d4 <xNextTaskUnblockTime+0x1>
    23fa:	20 93 d3 01 	sts	0x01D3, r18	; 0x8001d3 <xNextTaskUnblockTime>
xTaskIncrementTick():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2757

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    23fe:	20 91 d3 01 	lds	r18, 0x01D3	; 0x8001d3 <xNextTaskUnblockTime>
    2402:	30 91 d4 01 	lds	r19, 0x01D4	; 0x8001d4 <xNextTaskUnblockTime+0x1>
    2406:	82 17       	cp	r24, r18
    2408:	93 07       	cpc	r25, r19
    240a:	10 f4       	brcc	.+4      	; 0x2410 <vPortYieldFromTick+0xea>
vPortYieldFromTick():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2727

BaseType_t xTaskIncrementTick( void )
{
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    240c:	20 e0       	ldi	r18, 0x00	; 0
    240e:	a1 c0       	rjmp	.+322    	; 0x2552 <vPortYieldFromTick+0x22c>
    2410:	20 e0       	ldi	r18, 0x00	; 0
xTaskIncrementTick():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2811
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    2412:	39 e0       	ldi	r19, 0x09	; 9
    2414:	d3 2e       	mov	r13, r19
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2761
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2416:	e0 91 df 01 	lds	r30, 0x01DF	; 0x8001df <pxDelayedTaskList>
    241a:	f0 91 e0 01 	lds	r31, 0x01E0	; 0x8001e0 <pxDelayedTaskList+0x1>
    241e:	30 81       	ld	r19, Z
    2420:	31 11       	cpse	r19, r1
    2422:	07 c0       	rjmp	.+14     	; 0x2432 <vPortYieldFromTick+0x10c>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2768
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2424:	8f ef       	ldi	r24, 0xFF	; 255
    2426:	9f ef       	ldi	r25, 0xFF	; 255
    2428:	90 93 d4 01 	sts	0x01D4, r25	; 0x8001d4 <xNextTaskUnblockTime+0x1>
    242c:	80 93 d3 01 	sts	0x01D3, r24	; 0x8001d3 <xNextTaskUnblockTime>
    2430:	90 c0       	rjmp	.+288    	; 0x2552 <vPortYieldFromTick+0x22c>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2777
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2432:	e0 91 df 01 	lds	r30, 0x01DF	; 0x8001df <pxDelayedTaskList>
    2436:	f0 91 e0 01 	lds	r31, 0x01E0	; 0x8001e0 <pxDelayedTaskList+0x1>
    243a:	05 80       	ldd	r0, Z+5	; 0x05
    243c:	f6 81       	ldd	r31, Z+6	; 0x06
    243e:	e0 2d       	mov	r30, r0
    2440:	06 80       	ldd	r0, Z+6	; 0x06
    2442:	f7 81       	ldd	r31, Z+7	; 0x07
    2444:	e0 2d       	mov	r30, r0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2778
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    2446:	42 81       	ldd	r20, Z+2	; 0x02
    2448:	53 81       	ldd	r21, Z+3	; 0x03
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2780

                    if( xConstTickCount < xItemValue )
    244a:	84 17       	cp	r24, r20
    244c:	95 07       	cpc	r25, r21
    244e:	28 f4       	brcc	.+10     	; 0x245a <vPortYieldFromTick+0x134>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2787
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    2450:	50 93 d4 01 	sts	0x01D4, r21	; 0x8001d4 <xNextTaskUnblockTime+0x1>
    2454:	40 93 d3 01 	sts	0x01D3, r20	; 0x8001d3 <xNextTaskUnblockTime>
    2458:	7c c0       	rjmp	.+248    	; 0x2552 <vPortYieldFromTick+0x22c>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2796
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    245a:	a2 85       	ldd	r26, Z+10	; 0x0a
    245c:	b3 85       	ldd	r27, Z+11	; 0x0b
    245e:	44 81       	ldd	r20, Z+4	; 0x04
    2460:	55 81       	ldd	r21, Z+5	; 0x05
    2462:	66 81       	ldd	r22, Z+6	; 0x06
    2464:	77 81       	ldd	r23, Z+7	; 0x07
    2466:	ea 01       	movw	r28, r20
    2468:	7d 83       	std	Y+5, r23	; 0x05
    246a:	6c 83       	std	Y+4, r22	; 0x04
    246c:	66 81       	ldd	r22, Z+6	; 0x06
    246e:	77 81       	ldd	r23, Z+7	; 0x07
    2470:	eb 01       	movw	r28, r22
    2472:	5b 83       	std	Y+3, r21	; 0x03
    2474:	4a 83       	std	Y+2, r20	; 0x02
    2476:	af 01       	movw	r20, r30
    2478:	4e 5f       	subi	r20, 0xFE	; 254
    247a:	5f 4f       	sbci	r21, 0xFF	; 255
    247c:	11 96       	adiw	r26, 0x01	; 1
    247e:	0d 91       	ld	r16, X+
    2480:	1c 91       	ld	r17, X
    2482:	12 97       	sbiw	r26, 0x02	; 2
    2484:	04 17       	cp	r16, r20
    2486:	15 07       	cpc	r17, r21
    2488:	21 f4       	brne	.+8      	; 0x2492 <vPortYieldFromTick+0x16c>
    248a:	12 96       	adiw	r26, 0x02	; 2
    248c:	7c 93       	st	X, r23
    248e:	6e 93       	st	-X, r22
    2490:	11 97       	sbiw	r26, 0x01	; 1
    2492:	13 86       	std	Z+11, r1	; 0x0b
    2494:	12 86       	std	Z+10, r1	; 0x0a
    2496:	3c 91       	ld	r19, X
    2498:	31 50       	subi	r19, 0x01	; 1
    249a:	3c 93       	st	X, r19
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2800

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    249c:	a4 89       	ldd	r26, Z+20	; 0x14
    249e:	b5 89       	ldd	r27, Z+21	; 0x15
    24a0:	10 97       	sbiw	r26, 0x00	; 0
    24a2:	f9 f0       	breq	.+62     	; 0x24e2 <vPortYieldFromTick+0x1bc>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2802
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    24a4:	66 85       	ldd	r22, Z+14	; 0x0e
    24a6:	77 85       	ldd	r23, Z+15	; 0x0f
    24a8:	00 89       	ldd	r16, Z+16	; 0x10
    24aa:	11 89       	ldd	r17, Z+17	; 0x11
    24ac:	eb 01       	movw	r28, r22
    24ae:	1d 83       	std	Y+5, r17	; 0x05
    24b0:	0c 83       	std	Y+4, r16	; 0x04
    24b2:	00 89       	ldd	r16, Z+16	; 0x10
    24b4:	11 89       	ldd	r17, Z+17	; 0x11
    24b6:	e8 01       	movw	r28, r16
    24b8:	7b 83       	std	Y+3, r23	; 0x03
    24ba:	6a 83       	std	Y+2, r22	; 0x02
    24bc:	11 96       	adiw	r26, 0x01	; 1
    24be:	ed 90       	ld	r14, X+
    24c0:	fc 90       	ld	r15, X
    24c2:	12 97       	sbiw	r26, 0x02	; 2
    24c4:	bf 01       	movw	r22, r30
    24c6:	64 5f       	subi	r22, 0xF4	; 244
    24c8:	7f 4f       	sbci	r23, 0xFF	; 255
    24ca:	e6 16       	cp	r14, r22
    24cc:	f7 06       	cpc	r15, r23
    24ce:	21 f4       	brne	.+8      	; 0x24d8 <vPortYieldFromTick+0x1b2>
    24d0:	12 96       	adiw	r26, 0x02	; 2
    24d2:	1c 93       	st	X, r17
    24d4:	0e 93       	st	-X, r16
    24d6:	11 97       	sbiw	r26, 0x01	; 1
    24d8:	15 8a       	std	Z+21, r1	; 0x15
    24da:	14 8a       	std	Z+20, r1	; 0x14
    24dc:	3c 91       	ld	r19, X
    24de:	31 50       	subi	r19, 0x01	; 1
    24e0:	3c 93       	st	X, r19
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2811
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    24e2:	a6 89       	ldd	r26, Z+22	; 0x16
    24e4:	30 91 32 02 	lds	r19, 0x0232	; 0x800232 <uxTopReadyPriority>
    24e8:	3a 17       	cp	r19, r26
    24ea:	10 f4       	brcc	.+4      	; 0x24f0 <vPortYieldFromTick+0x1ca>
    24ec:	a0 93 32 02 	sts	0x0232, r26	; 0x800232 <uxTopReadyPriority>
    24f0:	da 9e       	mul	r13, r26
    24f2:	d0 01       	movw	r26, r0
    24f4:	11 24       	eor	r1, r1
    24f6:	a2 5f       	subi	r26, 0xF2	; 242
    24f8:	bd 4f       	sbci	r27, 0xFD	; 253
    24fa:	11 96       	adiw	r26, 0x01	; 1
    24fc:	0d 90       	ld	r0, X+
    24fe:	bc 91       	ld	r27, X
    2500:	a0 2d       	mov	r26, r0
    2502:	b5 83       	std	Z+5, r27	; 0x05
    2504:	a4 83       	std	Z+4, r26	; 0x04
    2506:	14 96       	adiw	r26, 0x04	; 4
    2508:	6d 91       	ld	r22, X+
    250a:	7c 91       	ld	r23, X
    250c:	15 97       	sbiw	r26, 0x05	; 5
    250e:	77 83       	std	Z+7, r23	; 0x07
    2510:	66 83       	std	Z+6, r22	; 0x06
    2512:	14 96       	adiw	r26, 0x04	; 4
    2514:	6d 91       	ld	r22, X+
    2516:	7c 91       	ld	r23, X
    2518:	15 97       	sbiw	r26, 0x05	; 5
    251a:	eb 01       	movw	r28, r22
    251c:	5b 83       	std	Y+3, r21	; 0x03
    251e:	4a 83       	std	Y+2, r20	; 0x02
    2520:	15 96       	adiw	r26, 0x05	; 5
    2522:	5c 93       	st	X, r21
    2524:	4e 93       	st	-X, r20
    2526:	14 97       	sbiw	r26, 0x04	; 4
    2528:	46 89       	ldd	r20, Z+22	; 0x16
    252a:	4d 9d       	mul	r20, r13
    252c:	d0 01       	movw	r26, r0
    252e:	11 24       	eor	r1, r1
    2530:	a2 5f       	subi	r26, 0xF2	; 242
    2532:	bd 4f       	sbci	r27, 0xFD	; 253
    2534:	b3 87       	std	Z+11, r27	; 0x0b
    2536:	a2 87       	std	Z+10, r26	; 0x0a
    2538:	3c 91       	ld	r19, X
    253a:	3f 5f       	subi	r19, 0xFF	; 255
    253c:	3c 93       	st	X, r19
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2821
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    253e:	e0 91 9e 01 	lds	r30, 0x019E	; 0x80019e <__data_end>
    2542:	f0 91 9f 01 	lds	r31, 0x019F	; 0x80019f <__data_end+0x1>
    2546:	36 89       	ldd	r19, Z+22	; 0x16
    2548:	43 17       	cp	r20, r19
    254a:	08 f4       	brcc	.+2      	; 0x254e <vPortYieldFromTick+0x228>
    254c:	64 cf       	rjmp	.-312    	; 0x2416 <vPortYieldFromTick+0xf0>
vPortYieldFromTick():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2823
                            {
                                xSwitchRequired = pdTRUE;
    254e:	21 e0       	ldi	r18, 0x01	; 1
    2550:	62 cf       	rjmp	.-316    	; 0x2416 <vPortYieldFromTick+0xf0>
xTaskIncrementTick():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2840
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    2552:	e0 91 9e 01 	lds	r30, 0x019E	; 0x80019e <__data_end>
    2556:	f0 91 9f 01 	lds	r31, 0x019F	; 0x80019f <__data_end+0x1>
    255a:	e6 89       	ldd	r30, Z+22	; 0x16
    255c:	d9 e0       	ldi	r29, 0x09	; 9
    255e:	ed 9f       	mul	r30, r29
    2560:	f0 01       	movw	r30, r0
    2562:	11 24       	eor	r1, r1
    2564:	e2 5f       	subi	r30, 0xF2	; 242
    2566:	fd 4f       	sbci	r31, 0xFD	; 253
    2568:	80 81       	ld	r24, Z
    256a:	82 30       	cpi	r24, 0x02	; 2
    256c:	08 f0       	brcs	.+2      	; 0x2570 <vPortYieldFromTick+0x24a>
vPortYieldFromTick():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2842
                {
                    xSwitchRequired = pdTRUE;
    256e:	21 e0       	ldi	r18, 0x01	; 1
xTaskIncrementTick():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2868
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
    2570:	80 91 ae 01 	lds	r24, 0x01AE	; 0x8001ae <xYieldPending>
    2574:	81 11       	cpse	r24, r1
    2576:	0e c0       	rjmp	.+28     	; 0x2594 <vPortYieldFromTick+0x26e>
    2578:	0a c0       	rjmp	.+20     	; 0x258e <vPortYieldFromTick+0x268>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2881
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    257a:	80 91 ac 01 	lds	r24, 0x01AC	; 0x8001ac <xPendedTicks>
    257e:	90 91 ad 01 	lds	r25, 0x01AD	; 0x8001ad <xPendedTicks+0x1>
    2582:	01 96       	adiw	r24, 0x01	; 1
    2584:	90 93 ad 01 	sts	0x01AD, r25	; 0x8001ad <xPendedTicks+0x1>
    2588:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <xPendedTicks>
    258c:	6a c0       	rjmp	.+212    	; 0x2662 <vPortYieldFromTick+0x33c>
vPortYieldFromTick():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/port.c:659
    if( xTaskIncrementTick() != pdFALSE )
    258e:	22 23       	and	r18, r18
    2590:	09 f4       	brne	.+2      	; 0x2594 <vPortYieldFromTick+0x26e>
    2592:	67 c0       	rjmp	.+206    	; 0x2662 <vPortYieldFromTick+0x33c>
vTaskSwitchContext():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3010
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    2594:	80 91 d7 01 	lds	r24, 0x01D7	; 0x8001d7 <uxSchedulerSuspended>
    2598:	88 23       	and	r24, r24
    259a:	21 f0       	breq	.+8      	; 0x25a4 <vPortYieldFromTick+0x27e>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3014
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    259c:	81 e0       	ldi	r24, 0x01	; 1
    259e:	80 93 ae 01 	sts	0x01AE, r24	; 0x8001ae <xYieldPending>
    25a2:	5f c0       	rjmp	.+190    	; 0x2662 <vPortYieldFromTick+0x33c>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3018
    }
    else
    {
        xYieldPending = pdFALSE;
    25a4:	10 92 ae 01 	sts	0x01AE, r1	; 0x8001ae <xYieldPending>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3050
                ulTaskSwitchedInTime = ulTotalRunTime;
            }
        #endif /* configGENERATE_RUN_TIME_STATS */

        /* Check for stack overflow, if configured. */
        taskCHECK_FOR_STACK_OVERFLOW();
    25a8:	a0 91 9e 01 	lds	r26, 0x019E	; 0x80019e <__data_end>
    25ac:	b0 91 9f 01 	lds	r27, 0x019F	; 0x80019f <__data_end+0x1>
    25b0:	e0 91 9e 01 	lds	r30, 0x019E	; 0x80019e <__data_end>
    25b4:	f0 91 9f 01 	lds	r31, 0x019F	; 0x80019f <__data_end+0x1>
    25b8:	2d 91       	ld	r18, X+
    25ba:	3c 91       	ld	r19, X
    25bc:	87 89       	ldd	r24, Z+23	; 0x17
    25be:	90 8d       	ldd	r25, Z+24	; 0x18
    25c0:	82 17       	cp	r24, r18
    25c2:	93 07       	cpc	r25, r19
    25c4:	a8 f0       	brcs	.+42     	; 0x25f0 <vPortYieldFromTick+0x2ca>
    25c6:	80 91 9e 01 	lds	r24, 0x019E	; 0x80019e <__data_end>
    25ca:	90 91 9f 01 	lds	r25, 0x019F	; 0x80019f <__data_end+0x1>
    25ce:	80 91 9e 01 	lds	r24, 0x019E	; 0x80019e <__data_end>
    25d2:	90 91 9f 01 	lds	r25, 0x019F	; 0x80019f <__data_end+0x1>
prvSetMainLedOn():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/variantHooks.cpp:101
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    25d6:	25 9a       	sbi	0x04, 5	; 4
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/variantHooks.cpp:102
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
    25d8:	2d 9a       	sbi	0x05, 5	; 5
_delay_ms():
c:\program files (x86)\arduino\hardware\tools\avr\avr\include\util/delay.h:187
    25da:	2f ef       	ldi	r18, 0xFF	; 255
    25dc:	87 ea       	ldi	r24, 0xA7	; 167
    25de:	91 e6       	ldi	r25, 0x61	; 97
    25e0:	21 50       	subi	r18, 0x01	; 1
    25e2:	80 40       	sbci	r24, 0x00	; 0
    25e4:	90 40       	sbci	r25, 0x00	; 0
    25e6:	e1 f7       	brne	.-8      	; 0x25e0 <vPortYieldFromTick+0x2ba>
    25e8:	00 c0       	rjmp	.+0      	; 0x25ea <vPortYieldFromTick+0x2c4>
    25ea:	00 00       	nop
prvBlinkMainLed():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/variantHooks.cpp:125

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle.
    25ec:	1d 9a       	sbi	0x03, 5	; 3
    25ee:	f5 cf       	rjmp	.-22     	; 0x25da <vPortYieldFromTick+0x2b4>
vTaskSwitchContext():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3061
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    25f0:	20 91 32 02 	lds	r18, 0x0232	; 0x800232 <uxTopReadyPriority>
    25f4:	89 e0       	ldi	r24, 0x09	; 9
    25f6:	01 c0       	rjmp	.+2      	; 0x25fa <vPortYieldFromTick+0x2d4>
    25f8:	21 50       	subi	r18, 0x01	; 1
    25fa:	42 2f       	mov	r20, r18
    25fc:	50 e0       	ldi	r21, 0x00	; 0
    25fe:	84 9f       	mul	r24, r20
    2600:	f0 01       	movw	r30, r0
    2602:	85 9f       	mul	r24, r21
    2604:	f0 0d       	add	r31, r0
    2606:	11 24       	eor	r1, r1
    2608:	e2 5f       	subi	r30, 0xF2	; 242
    260a:	fd 4f       	sbci	r31, 0xFD	; 253
    260c:	90 81       	ld	r25, Z
    260e:	99 23       	and	r25, r25
    2610:	99 f3       	breq	.-26     	; 0x25f8 <vPortYieldFromTick+0x2d2>
    2612:	a1 81       	ldd	r26, Z+1	; 0x01
    2614:	b2 81       	ldd	r27, Z+2	; 0x02
    2616:	12 96       	adiw	r26, 0x02	; 2
    2618:	0d 90       	ld	r0, X+
    261a:	bc 91       	ld	r27, X
    261c:	a0 2d       	mov	r26, r0
    261e:	b2 83       	std	Z+2, r27	; 0x02
    2620:	a1 83       	std	Z+1, r26	; 0x01
    2622:	28 9f       	mul	r18, r24
    2624:	c0 01       	movw	r24, r0
    2626:	11 24       	eor	r1, r1
    2628:	8f 5e       	subi	r24, 0xEF	; 239
    262a:	9d 4f       	sbci	r25, 0xFD	; 253
    262c:	a8 17       	cp	r26, r24
    262e:	b9 07       	cpc	r27, r25
    2630:	29 f4       	brne	.+10     	; 0x263c <vPortYieldFromTick+0x316>
    2632:	12 96       	adiw	r26, 0x02	; 2
    2634:	8d 91       	ld	r24, X+
    2636:	9c 91       	ld	r25, X
    2638:	92 83       	std	Z+2, r25	; 0x02
    263a:	81 83       	std	Z+1, r24	; 0x01
    263c:	89 e0       	ldi	r24, 0x09	; 9
    263e:	84 9f       	mul	r24, r20
    2640:	f0 01       	movw	r30, r0
    2642:	85 9f       	mul	r24, r21
    2644:	f0 0d       	add	r31, r0
    2646:	11 24       	eor	r1, r1
    2648:	e2 5f       	subi	r30, 0xF2	; 242
    264a:	fd 4f       	sbci	r31, 0xFD	; 253
    264c:	01 80       	ldd	r0, Z+1	; 0x01
    264e:	f2 81       	ldd	r31, Z+2	; 0x02
    2650:	e0 2d       	mov	r30, r0
    2652:	86 81       	ldd	r24, Z+6	; 0x06
    2654:	97 81       	ldd	r25, Z+7	; 0x07
    2656:	90 93 9f 01 	sts	0x019F, r25	; 0x80019f <__data_end+0x1>
    265a:	80 93 9e 01 	sts	0x019E, r24	; 0x80019e <__data_end>
    265e:	20 93 32 02 	sts	0x0232, r18	; 0x800232 <uxTopReadyPriority>
vPortYieldFromTick():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/port.c:663
    {
        vTaskSwitchContext();
    }
    portRESTORE_CONTEXT();
    2662:	a0 91 9e 01 	lds	r26, 0x019E	; 0x80019e <__data_end>
    2666:	b0 91 9f 01 	lds	r27, 0x019F	; 0x80019f <__data_end+0x1>
    266a:	cd 91       	ld	r28, X+
    266c:	cd bf       	out	0x3d, r28	; 61
    266e:	dd 91       	ld	r29, X+
    2670:	de bf       	out	0x3e, r29	; 62
    2672:	ff 91       	pop	r31
    2674:	ef 91       	pop	r30
    2676:	df 91       	pop	r29
    2678:	cf 91       	pop	r28
    267a:	bf 91       	pop	r27
    267c:	af 91       	pop	r26
    267e:	9f 91       	pop	r25
    2680:	8f 91       	pop	r24
    2682:	7f 91       	pop	r23
    2684:	6f 91       	pop	r22
    2686:	5f 91       	pop	r21
    2688:	4f 91       	pop	r20
    268a:	3f 91       	pop	r19
    268c:	2f 91       	pop	r18
    268e:	1f 91       	pop	r17
    2690:	0f 91       	pop	r16
    2692:	ff 90       	pop	r15
    2694:	ef 90       	pop	r14
    2696:	df 90       	pop	r13
    2698:	cf 90       	pop	r12
    269a:	bf 90       	pop	r11
    269c:	af 90       	pop	r10
    269e:	9f 90       	pop	r9
    26a0:	8f 90       	pop	r8
    26a2:	7f 90       	pop	r7
    26a4:	6f 90       	pop	r6
    26a6:	5f 90       	pop	r5
    26a8:	4f 90       	pop	r4
    26aa:	3f 90       	pop	r3
    26ac:	2f 90       	pop	r2
    26ae:	1f 90       	pop	r1
    26b0:	0f 90       	pop	r0
    26b2:	0f be       	out	0x3f, r0	; 63
    26b4:	0f 90       	pop	r0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/port.c:665

    __asm__ __volatile__ ( "ret" );
    26b6:	08 95       	ret

000026b8 <vPortFree>:
vPortFree():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/heap_3.c:82
    return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
    26b8:	cf 93       	push	r28
    26ba:	df 93       	push	r29
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/heap_3.c:83
    if( pv )
    26bc:	00 97       	sbiw	r24, 0x00	; 0
    26be:	51 f0       	breq	.+20     	; 0x26d4 <vPortFree+0x1c>
    26c0:	ec 01       	movw	r28, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/heap_3.c:85
    {
        vTaskSuspendAll();
    26c2:	0e 94 17 0b 	call	0x162e	; 0x162e <vTaskSuspendAll>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/heap_3.c:87
        {
            free( pv );
    26c6:	ce 01       	movw	r24, r28
    26c8:	0e 94 cc 18 	call	0x3198	; 0x3198 <free>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/heap_3.c:92
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    }
}
    26cc:	df 91       	pop	r29
    26ce:	cf 91       	pop	r28
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/heap_3.c:90
        vTaskSuspendAll();
        {
            free( pv );
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    26d0:	0c 94 3c 0d 	jmp	0x1a78	; 0x1a78 <xTaskResumeAll>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/heap_3.c:92
    }
}
    26d4:	df 91       	pop	r29
    26d6:	cf 91       	pop	r28
    26d8:	08 95       	ret

000026da <prvTimerTask>:
prvTimerTask():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:548
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    }
/*-----------------------------------------------------------*/

    static portTASK_FUNCTION( prvTimerTask, pvParameters )
    {
    26da:	cf 93       	push	r28
    26dc:	df 93       	push	r29
    26de:	cd b7       	in	r28, 0x3d	; 61
    26e0:	de b7       	in	r29, 0x3e	; 62
    26e2:	2a 97       	sbiw	r28, 0x0a	; 10
    26e4:	0f b6       	in	r0, 0x3f	; 63
    26e6:	f8 94       	cli
    26e8:	de bf       	out	0x3e, r29	; 62
    26ea:	0f be       	out	0x3f, r0	; 63
    26ec:	cd bf       	out	0x3d, r28	; 61
prvGetNextExpireTime():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:656
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    26ee:	e0 91 bd 01 	lds	r30, 0x01BD	; 0x8001bd <pxCurrentTimerList>
    26f2:	f0 91 be 01 	lds	r31, 0x01BE	; 0x8001be <pxCurrentTimerList+0x1>
    26f6:	10 81       	ld	r17, Z
prvTimerTask():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:665
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
        }
        else
        {
            /* Ensure the task unblocks when the tick count rolls over. */
            xNextExpireTime = ( TickType_t ) 0U;
    26f8:	f1 2c       	mov	r15, r1
    26fa:	e1 2c       	mov	r14, r1
prvGetNextExpireTime():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:658
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );

        if( *pxListWasEmpty == pdFALSE )
    26fc:	11 23       	and	r17, r17
    26fe:	29 f0       	breq	.+10     	; 0x270a <prvTimerTask+0x30>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:660
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2700:	05 80       	ldd	r0, Z+5	; 0x05
    2702:	f6 81       	ldd	r31, Z+6	; 0x06
    2704:	e0 2d       	mov	r30, r0
    2706:	e0 80       	ld	r14, Z
    2708:	f1 80       	ldd	r15, Z+1	; 0x01
prvProcessTimerOrBlockTask():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:589
                                            BaseType_t xListWasEmpty )
    {
        TickType_t xTimeNow;
        BaseType_t xTimerListsWereSwitched;

        vTaskSuspendAll();
    270a:	0e 94 17 0b 	call	0x162e	; 0x162e <vTaskSuspendAll>
prvSampleTimeNow():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:677
    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    {
        TickType_t xTimeNow;
        PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

        xTimeNow = xTaskGetTickCount();
    270e:	0e 94 0d 0b 	call	0x161a	; 0x161a <xTaskGetTickCount>
    2712:	6c 01       	movw	r12, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:679

        if( xTimeNow < xLastTime )
    2714:	80 91 b0 01 	lds	r24, 0x01B0	; 0x8001b0 <xLastTime.2336>
    2718:	90 91 b1 01 	lds	r25, 0x01B1	; 0x8001b1 <xLastTime.2336+0x1>
    271c:	c8 16       	cp	r12, r24
    271e:	d9 06       	cpc	r13, r25
    2720:	08 f0       	brcs	.+2      	; 0x2724 <prvTimerTask+0x4a>
    2722:	7b c0       	rjmp	.+246    	; 0x281a <prvTimerTask+0x140>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:681
        {
            prvSwitchTimerLists();
    2724:	0e 94 70 10 	call	0x20e0	; 0x20e0 <prvSwitchTimerLists>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:689
        else
        {
            *pxTimerListsWereSwitched = pdFALSE;
        }

        xLastTime = xTimeNow;
    2728:	d0 92 b1 01 	sts	0x01B1, r13	; 0x8001b1 <xLastTime.2336+0x1>
    272c:	c0 92 b0 01 	sts	0x01B0, r12	; 0x8001b0 <xLastTime.2336>
prvProcessTimerOrBlockTask():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:639
                    }
                }
            }
            else
            {
                ( void ) xTaskResumeAll();
    2730:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <xTaskResumeAll>
prvProcessReceivedCommands():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:746
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched, xResult;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2734:	00 91 d8 01 	lds	r16, 0x01D8	; 0x8001d8 <xTimerQueue>
    2738:	10 91 d9 01 	lds	r17, 0x01D9	; 0x8001d9 <xTimerQueue+0x1>
    273c:	1a 86       	std	Y+10, r1	; 0x0a
    273e:	19 86       	std	Y+9, r1	; 0x09
prvTimerTask():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1318

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    BaseType_t xEntryTimeSet = pdFALSE;
    2740:	80 e0       	ldi	r24, 0x00	; 0
xQueueReceive():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1416
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2742:	68 01       	movw	r12, r16
    2744:	b1 e1       	ldi	r27, 0x11	; 17
    2746:	cb 0e       	add	r12, r27
    2748:	d1 1c       	adc	r13, r1
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1341
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    274a:	0f b6       	in	r0, 0x3f	; 63
    274c:	f8 94       	cli
    274e:	0f 92       	push	r0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1343
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2750:	f8 01       	movw	r30, r16
    2752:	f2 8c       	ldd	r15, Z+26	; 0x1a
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1347

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2754:	ff 20       	and	r15, r15
    2756:	09 f4       	brne	.+2      	; 0x275a <prvTimerTask+0x80>
    2758:	41 c1       	rjmp	.+642    	; 0x29dc <prvTimerTask+0x302>
prvCopyDataFromQueue():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2208
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    275a:	44 8d       	ldd	r20, Z+28	; 0x1c
    275c:	44 23       	and	r20, r20
    275e:	c1 f0       	breq	.+48     	; 0x2790 <prvTimerTask+0xb6>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2210
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2760:	50 e0       	ldi	r21, 0x00	; 0
    2762:	86 81       	ldd	r24, Z+6	; 0x06
    2764:	97 81       	ldd	r25, Z+7	; 0x07
    2766:	84 0f       	add	r24, r20
    2768:	95 1f       	adc	r25, r21
    276a:	97 83       	std	Z+7, r25	; 0x07
    276c:	86 83       	std	Z+6, r24	; 0x06
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2212

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    276e:	24 81       	ldd	r18, Z+4	; 0x04
    2770:	35 81       	ldd	r19, Z+5	; 0x05
    2772:	82 17       	cp	r24, r18
    2774:	93 07       	cpc	r25, r19
    2776:	20 f0       	brcs	.+8      	; 0x2780 <prvTimerTask+0xa6>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2214
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2778:	80 81       	ld	r24, Z
    277a:	91 81       	ldd	r25, Z+1	; 0x01
    277c:	97 83       	std	Z+7, r25	; 0x07
    277e:	86 83       	std	Z+6, r24	; 0x06
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2221
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2780:	d8 01       	movw	r26, r16
    2782:	16 96       	adiw	r26, 0x06	; 6
    2784:	6d 91       	ld	r22, X+
    2786:	7c 91       	ld	r23, X
    2788:	ce 01       	movw	r24, r28
    278a:	01 96       	adiw	r24, 0x01	; 1
    278c:	0e 94 a3 19 	call	0x3346	; 0x3346 <memcpy>
xQueueReceive():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1352
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2790:	fa 94       	dec	r15
    2792:	f8 01       	movw	r30, r16
    2794:	f2 8e       	std	Z+26, r15	; 0x1a
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1357

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2796:	80 85       	ldd	r24, Z+8	; 0x08
    2798:	88 23       	and	r24, r24
    279a:	39 f0       	breq	.+14     	; 0x27aa <prvTimerTask+0xd0>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1359
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    279c:	c8 01       	movw	r24, r16
    279e:	08 96       	adiw	r24, 0x08	; 8
    27a0:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <xTaskRemoveFromEventList>
    27a4:	81 11       	cpse	r24, r1
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1361
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    27a6:	0e 94 7e 0c 	call	0x18fc	; 0x18fc <vPortYield>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1373
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    27aa:	0f 90       	pop	r0
    27ac:	0f be       	out	0x3f, r0	; 63
prvProcessReceivedCommands():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:772
                }
            #endif /* INCLUDE_xTimerPendFunctionCall */

            /* Commands that are positive are timer commands rather than pended
             * function calls. */
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    27ae:	d9 80       	ldd	r13, Y+1	; 0x01
    27b0:	d7 fc       	sbrc	r13, 7
    27b2:	c0 cf       	rjmp	.-128    	; 0x2734 <prvTimerTask+0x5a>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:776
            {
                /* The messages uses the xTimerParameters member to work on a
                 * software timer. */
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
    27b4:	0c 81       	ldd	r16, Y+4	; 0x04
    27b6:	1d 81       	ldd	r17, Y+5	; 0x05
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:778

                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    27b8:	f8 01       	movw	r30, r16
    27ba:	82 85       	ldd	r24, Z+10	; 0x0a
    27bc:	93 85       	ldd	r25, Z+11	; 0x0b
    27be:	89 2b       	or	r24, r25
    27c0:	21 f0       	breq	.+8      	; 0x27ca <prvTimerTask+0xf0>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:781
                {
                    /* The timer is in a list, remove it. */
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    27c2:	c8 01       	movw	r24, r16
    27c4:	02 96       	adiw	r24, 0x02	; 2
    27c6:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uxListRemove>
prvSampleTimeNow():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:677
    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    {
        TickType_t xTimeNow;
        PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

        xTimeNow = xTaskGetTickCount();
    27ca:	0e 94 0d 0b 	call	0x161a	; 0x161a <xTaskGetTickCount>
    27ce:	7c 01       	movw	r14, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:679

        if( xTimeNow < xLastTime )
    27d0:	80 91 b0 01 	lds	r24, 0x01B0	; 0x8001b0 <xLastTime.2336>
    27d4:	90 91 b1 01 	lds	r25, 0x01B1	; 0x8001b1 <xLastTime.2336+0x1>
    27d8:	e8 16       	cp	r14, r24
    27da:	f9 06       	cpc	r15, r25
    27dc:	10 f4       	brcc	.+4      	; 0x27e2 <prvTimerTask+0x108>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:681
        {
            prvSwitchTimerLists();
    27de:	0e 94 70 10 	call	0x20e0	; 0x20e0 <prvSwitchTimerLists>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:689
        else
        {
            *pxTimerListsWereSwitched = pdFALSE;
        }

        xLastTime = xTimeNow;
    27e2:	f0 92 b1 01 	sts	0x01B1, r15	; 0x8001b1 <xLastTime.2336+0x1>
    27e6:	e0 92 b0 01 	sts	0x01B0, r14	; 0x8001b0 <xLastTime.2336>
prvProcessReceivedCommands():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:798
                 *  possibility of a higher priority task adding a message to the message
                 *  queue with a time that is ahead of the timer daemon task (because it
                 *  pre-empted the timer daemon task after the xTimeNow value was set). */
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

                switch( xMessage.xMessageID )
    27ea:	f9 e0       	ldi	r31, 0x09	; 9
    27ec:	fd 15       	cp	r31, r13
    27ee:	08 f4       	brcc	.+2      	; 0x27f2 <prvTimerTask+0x118>
    27f0:	a1 cf       	rjmp	.-190    	; 0x2734 <prvTimerTask+0x5a>
    27f2:	ed 2d       	mov	r30, r13
    27f4:	dd 0c       	add	r13, r13
    27f6:	ff 0b       	sbc	r31, r31
    27f8:	ed 5f       	subi	r30, 0xFD	; 253
    27fa:	fb 4e       	sbci	r31, 0xEB	; 235
    27fc:	d8 01       	movw	r26, r16
    27fe:	52 96       	adiw	r26, 0x12	; 18
    2800:	8c 91       	ld	r24, X
    2802:	0c 94 9d 19 	jmp	0x333a	; 0x333a <__tablejump2__>
    2806:	b1 14       	cp	r11, r1
    2808:	b1 14       	cp	r11, r1
    280a:	b1 14       	cp	r11, r1
    280c:	e9 14       	cp	r14, r9
    280e:	d4 14       	cp	r13, r4
    2810:	e3 14       	cp	r14, r3
    2812:	b1 14       	cp	r11, r1
    2814:	b1 14       	cp	r11, r1
    2816:	e9 14       	cp	r14, r9
    2818:	d4 14       	cp	r13, r4
prvSampleTimeNow():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:689
        else
        {
            *pxTimerListsWereSwitched = pdFALSE;
        }

        xLastTime = xTimeNow;
    281a:	d0 92 b1 01 	sts	0x01B1, r13	; 0x8001b1 <xLastTime.2336+0x1>
    281e:	c0 92 b0 01 	sts	0x01B0, r12	; 0x8001b0 <xLastTime.2336>
prvProcessTimerOrBlockTask():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:601
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

            if( xTimerListsWereSwitched == pdFALSE )
            {
                /* The tick count has not overflowed, has the timer expired? */
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2822:	11 23       	and	r17, r17
    2824:	99 f1       	breq	.+102    	; 0x288c <prvTimerTask+0x1b2>
    2826:	ce 14       	cp	r12, r14
    2828:	df 04       	cpc	r13, r15
    282a:	b8 f1       	brcs	.+110    	; 0x289a <prvTimerTask+0x1c0>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:603
                {
                    ( void ) xTaskResumeAll();
    282c:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <xTaskResumeAll>
prvProcessExpiredTimer():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:508

    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
                                        const TickType_t xTimeNow )
    {
        BaseType_t xResult;
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2830:	e0 91 bd 01 	lds	r30, 0x01BD	; 0x8001bd <pxCurrentTimerList>
    2834:	f0 91 be 01 	lds	r31, 0x01BE	; 0x8001be <pxCurrentTimerList+0x1>
    2838:	05 80       	ldd	r0, Z+5	; 0x05
    283a:	f6 81       	ldd	r31, Z+6	; 0x06
    283c:	e0 2d       	mov	r30, r0
    283e:	06 81       	ldd	r16, Z+6	; 0x06
    2840:	17 81       	ldd	r17, Z+7	; 0x07
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:513

        /* Remove the timer from the list of active timers.  A check has already
         * been performed to ensure the list is not empty. */

        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2842:	c8 01       	movw	r24, r16
    2844:	02 96       	adiw	r24, 0x02	; 2
    2846:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uxListRemove>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:518
        traceTIMER_EXPIRED( pxTimer );

        /* If the timer is an auto-reload timer then calculate the next
         * expiry time and re-insert the timer in the list of active timers. */
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    284a:	d8 01       	movw	r26, r16
    284c:	52 96       	adiw	r26, 0x12	; 18
    284e:	8c 91       	ld	r24, X
    2850:	52 97       	sbiw	r26, 0x12	; 18
    2852:	82 ff       	sbrs	r24, 2
    2854:	17 c0       	rjmp	.+46     	; 0x2884 <prvTimerTask+0x1aa>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:523
        {
            /* The timer is inserted into a list using a time relative to anything
             * other than the current time.  It will therefore be inserted into the
             * correct list relative to the time this task thinks it is now. */
            if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    2856:	1c 96       	adiw	r26, 0x0c	; 12
    2858:	6d 91       	ld	r22, X+
    285a:	7c 91       	ld	r23, X
    285c:	6e 0d       	add	r22, r14
    285e:	7f 1d       	adc	r23, r15
    2860:	97 01       	movw	r18, r14
    2862:	a6 01       	movw	r20, r12
    2864:	c8 01       	movw	r24, r16
    2866:	0e 94 c4 0b 	call	0x1788	; 0x1788 <prvInsertTimerInActiveList>
    286a:	88 23       	and	r24, r24
    286c:	21 f0       	breq	.+8      	; 0x2876 <prvTimerTask+0x19c>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:527
            {
                /* The timer expired before it was added to the active timer
                 * list.  Reload it now.  */
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    286e:	b7 01       	movw	r22, r14
    2870:	c8 01       	movw	r24, r16
    2872:	0e 94 49 10 	call	0x2092	; 0x2092 <xTimerGenericCommand.constprop.3>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:543
            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
            mtCOVERAGE_TEST_MARKER();
        }

        /* Call the timer callback. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2876:	d8 01       	movw	r26, r16
    2878:	50 96       	adiw	r26, 0x10	; 16
    287a:	ed 91       	ld	r30, X+
    287c:	fc 91       	ld	r31, X
    287e:	c8 01       	movw	r24, r16
    2880:	09 95       	icall
    2882:	58 cf       	rjmp	.-336    	; 0x2734 <prvTimerTask+0x5a>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:538
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    2884:	8e 7f       	andi	r24, 0xFE	; 254
    2886:	f8 01       	movw	r30, r16
    2888:	82 8b       	std	Z+18, r24	; 0x12
    288a:	f5 cf       	rjmp	.-22     	; 0x2876 <prvTimerTask+0x19c>
prvProcessTimerOrBlockTask():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:618
                     * case when the current timer list is empty. */
                    if( xListWasEmpty != pdFALSE )
                    {
                        /* The current timer list is empty - is the overflow list
                         * also empty? */
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    288c:	e0 91 bb 01 	lds	r30, 0x01BB	; 0x8001bb <pxOverflowTimerList>
    2890:	f0 91 bc 01 	lds	r31, 0x01BC	; 0x8001bc <pxOverflowTimerList+0x1>
    2894:	80 81       	ld	r24, Z
    2896:	61 e0       	ldi	r22, 0x01	; 1
    2898:	81 11       	cpse	r24, r1
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:601
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

            if( xTimerListsWereSwitched == pdFALSE )
            {
                /* The tick count has not overflowed, has the timer expired? */
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    289a:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:621
                        /* The current timer list is empty - is the overflow list
                         * also empty? */
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                    }

                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    289c:	00 91 d8 01 	lds	r16, 0x01D8	; 0x8001d8 <xTimerQueue>
    28a0:	10 91 d9 01 	lds	r17, 0x01D9	; 0x8001d9 <xTimerQueue+0x1>
vQueueWaitForMessageRestricted():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2827
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    28a4:	0f b6       	in	r0, 0x3f	; 63
    28a6:	f8 94       	cli
    28a8:	0f 92       	push	r0
    28aa:	f8 01       	movw	r30, r16
    28ac:	85 8d       	ldd	r24, Z+29	; 0x1d
    28ae:	8f 3f       	cpi	r24, 0xFF	; 255
    28b0:	09 f4       	brne	.+2      	; 0x28b4 <prvTimerTask+0x1da>
    28b2:	15 8e       	std	Z+29, r1	; 0x1d
    28b4:	d8 01       	movw	r26, r16
    28b6:	5e 96       	adiw	r26, 0x1e	; 30
    28b8:	8c 91       	ld	r24, X
    28ba:	5e 97       	sbiw	r26, 0x1e	; 30
    28bc:	8f 3f       	cpi	r24, 0xFF	; 255
    28be:	11 f4       	brne	.+4      	; 0x28c4 <prvTimerTask+0x1ea>
    28c0:	5e 96       	adiw	r26, 0x1e	; 30
    28c2:	1c 92       	st	X, r1
    28c4:	0f 90       	pop	r0
    28c6:	0f be       	out	0x3f, r0	; 63
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2829

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    28c8:	f8 01       	movw	r30, r16
    28ca:	82 8d       	ldd	r24, Z+26	; 0x1a
    28cc:	81 11       	cpse	r24, r1
    28ce:	3f c0       	rjmp	.+126    	; 0x294e <prvTimerTask+0x274>
vTaskPlaceOnEventListRestricted():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3146

        /* Place the event list item of the TCB in the appropriate event list.
         * In this case it is assume that this is the only task that is going to
         * be waiting on this event list, so the faster vListInsertEnd() function
         * can be used in place of vListInsert. */
        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    28d0:	02 88       	ldd	r0, Z+18	; 0x12
    28d2:	f3 89       	ldd	r31, Z+19	; 0x13
    28d4:	e0 2d       	mov	r30, r0
    28d6:	a0 91 9e 01 	lds	r26, 0x019E	; 0x80019e <__data_end>
    28da:	b0 91 9f 01 	lds	r27, 0x019F	; 0x80019f <__data_end+0x1>
    28de:	1f 96       	adiw	r26, 0x0f	; 15
    28e0:	fc 93       	st	X, r31
    28e2:	ee 93       	st	-X, r30
    28e4:	1e 97       	sbiw	r26, 0x0e	; 14
    28e6:	a0 91 9e 01 	lds	r26, 0x019E	; 0x80019e <__data_end>
    28ea:	b0 91 9f 01 	lds	r27, 0x019F	; 0x80019f <__data_end+0x1>
    28ee:	84 81       	ldd	r24, Z+4	; 0x04
    28f0:	95 81       	ldd	r25, Z+5	; 0x05
    28f2:	51 96       	adiw	r26, 0x11	; 17
    28f4:	9c 93       	st	X, r25
    28f6:	8e 93       	st	-X, r24
    28f8:	50 97       	sbiw	r26, 0x10	; 16
    28fa:	80 91 9e 01 	lds	r24, 0x019E	; 0x80019e <__data_end>
    28fe:	90 91 9f 01 	lds	r25, 0x019F	; 0x80019f <__data_end+0x1>
    2902:	a4 81       	ldd	r26, Z+4	; 0x04
    2904:	b5 81       	ldd	r27, Z+5	; 0x05
    2906:	0c 96       	adiw	r24, 0x0c	; 12
    2908:	13 96       	adiw	r26, 0x03	; 3
    290a:	9c 93       	st	X, r25
    290c:	8e 93       	st	-X, r24
    290e:	12 97       	sbiw	r26, 0x02	; 2
    2910:	80 91 9e 01 	lds	r24, 0x019E	; 0x80019e <__data_end>
    2914:	90 91 9f 01 	lds	r25, 0x019F	; 0x80019f <__data_end+0x1>
    2918:	0c 96       	adiw	r24, 0x0c	; 12
    291a:	95 83       	std	Z+5, r25	; 0x05
    291c:	84 83       	std	Z+4, r24	; 0x04
    291e:	e0 91 9e 01 	lds	r30, 0x019E	; 0x80019e <__data_end>
    2922:	f0 91 9f 01 	lds	r31, 0x019F	; 0x80019f <__data_end+0x1>
vQueueWaitForMessageRestricted():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2832
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    2926:	c8 01       	movw	r24, r16
    2928:	41 96       	adiw	r24, 0x11	; 17
vTaskPlaceOnEventListRestricted():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3146
    292a:	95 8b       	std	Z+21, r25	; 0x15
    292c:	84 8b       	std	Z+20, r24	; 0x14
    292e:	d8 01       	movw	r26, r16
    2930:	51 96       	adiw	r26, 0x11	; 17
    2932:	8c 91       	ld	r24, X
    2934:	51 97       	sbiw	r26, 0x11	; 17
    2936:	8f 5f       	subi	r24, 0xFF	; 255
    2938:	51 96       	adiw	r26, 0x11	; 17
    293a:	8c 93       	st	X, r24
prvProcessTimerOrBlockTask():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:621
    293c:	c7 01       	movw	r24, r14
    293e:	8c 19       	sub	r24, r12
    2940:	9d 09       	sbc	r25, r13
vTaskPlaceOnEventListRestricted():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3151

        /* If the task should block indefinitely then set the block time to a
         * value that will be recognised as an indefinite delay inside the
         * prvAddCurrentTaskToDelayedList() function. */
        if( xWaitIndefinitely != pdFALSE )
    2942:	66 23       	and	r22, r22
    2944:	11 f0       	breq	.+4      	; 0x294a <prvTimerTask+0x270>
prvTimerTask():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3153
        {
            xTicksToWait = portMAX_DELAY;
    2946:	8f ef       	ldi	r24, 0xFF	; 255
    2948:	9f ef       	ldi	r25, 0xFF	; 255
vTaskPlaceOnEventListRestricted():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3157
        }

        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    294a:	0e 94 ee 0b 	call	0x17dc	; 0x17dc <prvAddCurrentTaskToDelayedList>
vQueueWaitForMessageRestricted():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:2839
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
    294e:	c8 01       	movw	r24, r16
    2950:	0e 94 28 0b 	call	0x1650	; 0x1650 <prvUnlockQueue>
prvProcessTimerOrBlockTask():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:623

                    if( xTaskResumeAll() == pdFALSE )
    2954:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <xTaskResumeAll>
    2958:	81 11       	cpse	r24, r1
    295a:	ec ce       	rjmp	.-552    	; 0x2734 <prvTimerTask+0x5a>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:629
                    {
                        /* Yield to wait for either a command to arrive, or the
                         * block time to expire.  If a command arrived between the
                         * critical section being exited and this yield then the yield
                         * will not cause the task to block. */
                        portYIELD_WITHIN_API();
    295c:	0e 94 7e 0c 	call	0x18fc	; 0x18fc <vPortYield>
    2960:	e9 ce       	rjmp	.-558    	; 0x2734 <prvTimerTask+0x5a>
prvProcessReceivedCommands():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:806
                    case tmrCOMMAND_START_FROM_ISR:
                    case tmrCOMMAND_RESET:
                    case tmrCOMMAND_RESET_FROM_ISR:
                    case tmrCOMMAND_START_DONT_TRACE:
                        /* Start or restart a timer. */
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    2962:	81 60       	ori	r24, 0x01	; 1
    2964:	f8 01       	movw	r30, r16
    2966:	82 8b       	std	Z+18, r24	; 0x12
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:808

                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    2968:	ca 80       	ldd	r12, Y+2	; 0x02
    296a:	db 80       	ldd	r13, Y+3	; 0x03
    296c:	64 85       	ldd	r22, Z+12	; 0x0c
    296e:	75 85       	ldd	r23, Z+13	; 0x0d
    2970:	6c 0d       	add	r22, r12
    2972:	7d 1d       	adc	r23, r13
    2974:	96 01       	movw	r18, r12
    2976:	a7 01       	movw	r20, r14
    2978:	c8 01       	movw	r24, r16
    297a:	0e 94 c4 0b 	call	0x1788	; 0x1788 <prvInsertTimerInActiveList>
    297e:	88 23       	and	r24, r24
    2980:	09 f4       	brne	.+2      	; 0x2984 <prvTimerTask+0x2aa>
    2982:	d8 ce       	rjmp	.-592    	; 0x2734 <prvTimerTask+0x5a>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:812
                        {
                            /* The timer expired before it was added to the active
                             * timer list.  Process it now. */
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2984:	d8 01       	movw	r26, r16
    2986:	50 96       	adiw	r26, 0x10	; 16
    2988:	ed 91       	ld	r30, X+
    298a:	fc 91       	ld	r31, X
    298c:	c8 01       	movw	r24, r16
    298e:	09 95       	icall
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:815
                            traceTIMER_EXPIRED( pxTimer );

                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    2990:	f8 01       	movw	r30, r16
    2992:	82 89       	ldd	r24, Z+18	; 0x12
    2994:	82 ff       	sbrs	r24, 2
    2996:	ce ce       	rjmp	.-612    	; 0x2734 <prvTimerTask+0x5a>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:817
                            {
                                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    2998:	64 85       	ldd	r22, Z+12	; 0x0c
    299a:	75 85       	ldd	r23, Z+13	; 0x0d
    299c:	6c 0d       	add	r22, r12
    299e:	7d 1d       	adc	r23, r13
    29a0:	c8 01       	movw	r24, r16
    29a2:	0e 94 49 10 	call	0x2092	; 0x2092 <xTimerGenericCommand.constprop.3>
    29a6:	c6 ce       	rjmp	.-628    	; 0x2734 <prvTimerTask+0x5a>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:841
                        pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
                        break;

                    case tmrCOMMAND_CHANGE_PERIOD:
                    case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR:
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    29a8:	81 60       	ori	r24, 0x01	; 1
    29aa:	f8 01       	movw	r30, r16
    29ac:	82 8b       	std	Z+18, r24	; 0x12
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:842
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    29ae:	6a 81       	ldd	r22, Y+2	; 0x02
    29b0:	7b 81       	ldd	r23, Y+3	; 0x03
    29b2:	75 87       	std	Z+13, r23	; 0x0d
    29b4:	64 87       	std	Z+12, r22	; 0x0c
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:851
                         * be longer or shorter than the old one.  The command time is
                         * therefore set to the current time, and as the period cannot
                         * be zero the next expiry time can only be in the future,
                         * meaning (unlike for the xTimerStart() case above) there is
                         * no fail case that needs to be handled here. */
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    29b6:	6e 0d       	add	r22, r14
    29b8:	7f 1d       	adc	r23, r15
    29ba:	97 01       	movw	r18, r14
    29bc:	a7 01       	movw	r20, r14
    29be:	c8 01       	movw	r24, r16
    29c0:	0e 94 c4 0b 	call	0x1788	; 0x1788 <prvInsertTimerInActiveList>
    29c4:	b7 ce       	rjmp	.-658    	; 0x2734 <prvTimerTask+0x5a>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:860
                        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                            {
                                /* The timer has already been removed from the active list,
                                 * just free up the memory if the memory was dynamically
                                 * allocated. */
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    29c6:	81 fd       	sbrc	r24, 1
    29c8:	04 c0       	rjmp	.+8      	; 0x29d2 <prvTimerTask+0x2f8>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:862
                                {
                                    vPortFree( pxTimer );
    29ca:	c8 01       	movw	r24, r16
    29cc:	0e 94 5c 13 	call	0x26b8	; 0x26b8 <vPortFree>
    29d0:	b1 ce       	rjmp	.-670    	; 0x2734 <prvTimerTask+0x5a>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:866
                                }
                                else
                                {
                                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    29d2:	8e 7f       	andi	r24, 0xFE	; 254
    29d4:	d8 01       	movw	r26, r16
    29d6:	52 96       	adiw	r26, 0x12	; 18
    29d8:	8c 93       	st	X, r24
    29da:	ac ce       	rjmp	.-680    	; 0x2734 <prvTimerTask+0x5a>
xQueueReceive():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1378
                taskEXIT_CRITICAL();
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    29dc:	29 85       	ldd	r18, Y+9	; 0x09
    29de:	3a 85       	ldd	r19, Y+10	; 0x0a
    29e0:	23 2b       	or	r18, r19
    29e2:	19 f4       	brne	.+6      	; 0x29ea <prvTimerTask+0x310>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1382
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    29e4:	0f 90       	pop	r0
    29e6:	0f be       	out	0x3f, r0	; 63
    29e8:	82 ce       	rjmp	.-764    	; 0x26ee <prvTimerTask+0x14>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1386
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
    29ea:	81 11       	cpse	r24, r1
    29ec:	09 c0       	rjmp	.+18     	; 0x2a00 <prvTimerTask+0x326>
vTaskInternalSetTimeOutState():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3295
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    29ee:	80 91 dc 01 	lds	r24, 0x01DC	; 0x8001dc <xNumOfOverflows>
    29f2:	8e 83       	std	Y+6, r24	; 0x06
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3296
    pxTimeOut->xTimeOnEntering = xTickCount;
    29f4:	80 91 da 01 	lds	r24, 0x01DA	; 0x8001da <xTickCount>
    29f8:	90 91 db 01 	lds	r25, 0x01DB	; 0x8001db <xTickCount+0x1>
    29fc:	98 87       	std	Y+8, r25	; 0x08
    29fe:	8f 83       	std	Y+7, r24	; 0x07
xQueueReceive():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1400
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2a00:	0f 90       	pop	r0
    2a02:	0f be       	out	0x3f, r0	; 63
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1405

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2a04:	0e 94 17 0b 	call	0x162e	; 0x162e <vTaskSuspendAll>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1406
        prvLockQueue( pxQueue );
    2a08:	0f b6       	in	r0, 0x3f	; 63
    2a0a:	f8 94       	cli
    2a0c:	0f 92       	push	r0
    2a0e:	d8 01       	movw	r26, r16
    2a10:	5d 96       	adiw	r26, 0x1d	; 29
    2a12:	8c 91       	ld	r24, X
    2a14:	5d 97       	sbiw	r26, 0x1d	; 29
    2a16:	8f 3f       	cpi	r24, 0xFF	; 255
    2a18:	11 f4       	brne	.+4      	; 0x2a1e <prvTimerTask+0x344>
    2a1a:	5d 96       	adiw	r26, 0x1d	; 29
    2a1c:	1c 92       	st	X, r1
    2a1e:	f8 01       	movw	r30, r16
    2a20:	86 8d       	ldd	r24, Z+30	; 0x1e
    2a22:	8f 3f       	cpi	r24, 0xFF	; 255
    2a24:	09 f4       	brne	.+2      	; 0x2a28 <prvTimerTask+0x34e>
    2a26:	16 8e       	std	Z+30, r1	; 0x1e
    2a28:	0f 90       	pop	r0
    2a2a:	0f be       	out	0x3f, r0	; 63
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1409

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2a2c:	be 01       	movw	r22, r28
    2a2e:	67 5f       	subi	r22, 0xF7	; 247
    2a30:	7f 4f       	sbci	r23, 0xFF	; 255
    2a32:	ce 01       	movw	r24, r28
    2a34:	06 96       	adiw	r24, 0x06	; 6
    2a36:	0e 94 35 0a 	call	0x146a	; 0x146a <xTaskCheckForTimeOut>
    2a3a:	81 11       	cpse	r24, r1
    2a3c:	25 c0       	rjmp	.+74     	; 0x2a88 <prvTimerTask+0x3ae>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1413
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2a3e:	c8 01       	movw	r24, r16
    2a40:	0e 94 1d 0b 	call	0x163a	; 0x163a <prvIsQueueEmpty>
    2a44:	88 23       	and	r24, r24
    2a46:	d1 f0       	breq	.+52     	; 0x2a7c <prvTimerTask+0x3a2>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1416
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2a48:	e9 84       	ldd	r14, Y+9	; 0x09
    2a4a:	fa 84       	ldd	r15, Y+10	; 0x0a
vTaskPlaceOnEventList():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3096

    /* Place the event list item of the TCB in the appropriate event list.
     * This is placed in the list in priority order so the highest priority task
     * is the first to be woken by the event.  The queue that contains the event
     * list is locked, preventing simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    2a4c:	60 91 9e 01 	lds	r22, 0x019E	; 0x80019e <__data_end>
    2a50:	70 91 9f 01 	lds	r23, 0x019F	; 0x80019f <__data_end+0x1>
    2a54:	64 5f       	subi	r22, 0xF4	; 244
    2a56:	7f 4f       	sbci	r23, 0xFF	; 255
    2a58:	c6 01       	movw	r24, r12
    2a5a:	0e 94 8e 0b 	call	0x171c	; 0x171c <vListInsert>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3098

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2a5e:	61 e0       	ldi	r22, 0x01	; 1
    2a60:	c7 01       	movw	r24, r14
    2a62:	0e 94 ee 0b 	call	0x17dc	; 0x17dc <prvAddCurrentTaskToDelayedList>
xQueueReceive():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1417
                prvUnlockQueue( pxQueue );
    2a66:	c8 01       	movw	r24, r16
    2a68:	0e 94 28 0b 	call	0x1650	; 0x1650 <prvUnlockQueue>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1419

                if( xTaskResumeAll() == pdFALSE )
    2a6c:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <xTaskResumeAll>
    2a70:	81 11       	cpse	r24, r1
    2a72:	02 c0       	rjmp	.+4      	; 0x2a78 <prvTimerTask+0x39e>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1421
                {
                    portYIELD_WITHIN_API();
    2a74:	0e 94 7e 0c 	call	0x18fc	; 0x18fc <vPortYield>
    2a78:	81 e0       	ldi	r24, 0x01	; 1
    2a7a:	67 ce       	rjmp	.-818    	; 0x274a <prvTimerTask+0x70>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1432
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    2a7c:	c8 01       	movw	r24, r16
    2a7e:	0e 94 28 0b 	call	0x1650	; 0x1650 <prvUnlockQueue>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1433
                ( void ) xTaskResumeAll();
    2a82:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <xTaskResumeAll>
    2a86:	f8 cf       	rjmp	.-16     	; 0x2a78 <prvTimerTask+0x39e>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1440
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    2a88:	c8 01       	movw	r24, r16
    2a8a:	0e 94 28 0b 	call	0x1650	; 0x1650 <prvUnlockQueue>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1441
            ( void ) xTaskResumeAll();
    2a8e:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <xTaskResumeAll>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:1443

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2a92:	c8 01       	movw	r24, r16
    2a94:	0e 94 1d 0b 	call	0x163a	; 0x163a <prvIsQueueEmpty>
    2a98:	88 23       	and	r24, r24
    2a9a:	71 f3       	breq	.-36     	; 0x2a78 <prvTimerTask+0x39e>
    2a9c:	28 ce       	rjmp	.-944    	; 0x26ee <prvTimerTask+0x14>

00002a9e <prvIdleTask>:
prvIdleTask():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:67
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
    2a9e:	00 e0       	ldi	r16, 0x00	; 0
    2aa0:	10 e0       	ldi	r17, 0x00	; 0
prvCheckTasksWaitingTermination():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3688
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    2aa2:	80 91 af 01 	lds	r24, 0x01AF	; 0x8001af <uxDeletedTasksWaitingCleanUp>
    2aa6:	81 11       	cpse	r24, r1
    2aa8:	0e c0       	rjmp	.+28     	; 0x2ac6 <prvIdleTask+0x28>
prvIdleTask():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3461
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    2aaa:	80 91 0e 02 	lds	r24, 0x020E	; 0x80020e <pxReadyTasksLists>
    2aae:	82 30       	cpi	r24, 0x02	; 2
    2ab0:	10 f0       	brcs	.+4      	; 0x2ab6 <prvIdleTask+0x18>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3463
                {
                    taskYIELD();
    2ab2:	0e 94 7e 0c 	call	0x18fc	; 0x18fc <vPortYield>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/variantHooks.cpp:75
 */
void vApplicationIdleHook( void ) __attribute__((weak));

void vApplicationIdleHook( void )
{
    loop();                     // the normal Arduino loop() function is run here.
    2ab6:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <loop>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:67
    2aba:	01 15       	cp	r16, r1
    2abc:	11 05       	cpc	r17, r1
    2abe:	89 f3       	breq	.-30     	; 0x2aa2 <prvIdleTask+0x4>
    2ac0:	0e 94 47 01 	call	0x28e	; 0x28e <serialEventRun() [clone .part.1]>
    2ac4:	ee cf       	rjmp	.-36     	; 0x2aa2 <prvIdleTask+0x4>
prvCheckTasksWaitingTermination():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3690

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
    2ac6:	0f b6       	in	r0, 0x3f	; 63
    2ac8:	f8 94       	cli
    2aca:	0f 92       	push	r0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3692
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2acc:	e0 91 ef 01 	lds	r30, 0x01EF	; 0x8001ef <xTasksWaitingTermination+0x5>
    2ad0:	f0 91 f0 01 	lds	r31, 0x01F0	; 0x8001f0 <xTasksWaitingTermination+0x6>
    2ad4:	c6 81       	ldd	r28, Z+6	; 0x06
    2ad6:	d7 81       	ldd	r29, Z+7	; 0x07
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3693
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2ad8:	ce 01       	movw	r24, r28
    2ada:	02 96       	adiw	r24, 0x02	; 2
    2adc:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uxListRemove>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3694
                    --uxCurrentNumberOfTasks;
    2ae0:	80 91 35 02 	lds	r24, 0x0235	; 0x800235 <uxCurrentNumberOfTasks>
    2ae4:	81 50       	subi	r24, 0x01	; 1
    2ae6:	80 93 35 02 	sts	0x0235, r24	; 0x800235 <uxCurrentNumberOfTasks>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3695
                    --uxDeletedTasksWaitingCleanUp;
    2aea:	80 91 af 01 	lds	r24, 0x01AF	; 0x8001af <uxDeletedTasksWaitingCleanUp>
    2aee:	81 50       	subi	r24, 0x01	; 1
    2af0:	80 93 af 01 	sts	0x01AF, r24	; 0x8001af <uxDeletedTasksWaitingCleanUp>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3697
                }
                taskEXIT_CRITICAL();
    2af4:	0f 90       	pop	r0
    2af6:	0f be       	out	0x3f, r0	; 63
prvDeleteTCB():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3952

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFree( pxTCB->pxStack );
    2af8:	8f 89       	ldd	r24, Y+23	; 0x17
    2afa:	98 8d       	ldd	r25, Y+24	; 0x18
    2afc:	0e 94 5c 13 	call	0x26b8	; 0x26b8 <vPortFree>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3953
                vPortFree( pxTCB );
    2b00:	ce 01       	movw	r24, r28
    2b02:	0e 94 5c 13 	call	0x26b8	; 0x26b8 <vPortFree>
    2b06:	cd cf       	rjmp	.-102    	; 0x2aa2 <prvIdleTask+0x4>

00002b08 <pvPortMalloc>:
pvPortMalloc():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/heap_3.c:57
#if( configSUPPORT_DYNAMIC_ALLOCATION > 0 )

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
    2b08:	cf 93       	push	r28
    2b0a:	df 93       	push	r29
    2b0c:	ec 01       	movw	r28, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/heap_3.c:60
    void * pvReturn;

    vTaskSuspendAll();
    2b0e:	0e 94 17 0b 	call	0x162e	; 0x162e <vTaskSuspendAll>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/heap_3.c:62
    {
        pvReturn = malloc( xWantedSize );
    2b12:	ce 01       	movw	r24, r28
    2b14:	0e 94 30 18 	call	0x3060	; 0x3060 <malloc>
    2b18:	ec 01       	movw	r28, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/heap_3.c:65
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    2b1a:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <xTaskResumeAll>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/heap_3.c:69

    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )
        {
            if( pvReturn == NULL )
    2b1e:	20 97       	sbiw	r28, 0x00	; 0
    2b20:	69 f4       	brne	.+26     	; 0x2b3c <pvPortMalloc+0x34>
prvSetMainLedOn():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/variantHooks.cpp:101
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    2b22:	25 9a       	sbi	0x04, 5	; 4
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/variantHooks.cpp:102
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
    2b24:	2d 9a       	sbi	0x05, 5	; 5
_delay_ms():
c:\program files (x86)\arduino\hardware\tools\avr\avr\include\util/delay.h:187
    2b26:	2f ef       	ldi	r18, 0xFF	; 255
    2b28:	80 e7       	ldi	r24, 0x70	; 112
    2b2a:	92 e0       	ldi	r25, 0x02	; 2
    2b2c:	21 50       	subi	r18, 0x01	; 1
    2b2e:	80 40       	sbci	r24, 0x00	; 0
    2b30:	90 40       	sbci	r25, 0x00	; 0
    2b32:	e1 f7       	brne	.-8      	; 0x2b2c <pvPortMalloc+0x24>
    2b34:	00 c0       	rjmp	.+0      	; 0x2b36 <pvPortMalloc+0x2e>
    2b36:	00 00       	nop
prvBlinkMainLed():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/variantHooks.cpp:125

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle.
    2b38:	1d 9a       	sbi	0x03, 5	; 3
    2b3a:	f5 cf       	rjmp	.-22     	; 0x2b26 <pvPortMalloc+0x1e>
pvPortMalloc():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/heap_3.c:78
            }
        }
    #endif

    return pvReturn;
}
    2b3c:	ce 01       	movw	r24, r28
    2b3e:	df 91       	pop	r29
    2b40:	cf 91       	pop	r28
    2b42:	08 95       	ret

00002b44 <xTaskCreate.constprop.25>:
xTaskCreate.constprop.25():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:722
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    BaseType_t xTaskCreate( TaskFunction_t pxTaskCode,
    2b44:	7f 92       	push	r7
    2b46:	8f 92       	push	r8
    2b48:	9f 92       	push	r9
    2b4a:	af 92       	push	r10
    2b4c:	bf 92       	push	r11
    2b4e:	cf 92       	push	r12
    2b50:	df 92       	push	r13
    2b52:	ef 92       	push	r14
    2b54:	ff 92       	push	r15
    2b56:	0f 93       	push	r16
    2b58:	1f 93       	push	r17
    2b5a:	cf 93       	push	r28
    2b5c:	df 93       	push	r29
    2b5e:	98 2e       	mov	r9, r24
    2b60:	a9 2e       	mov	r10, r25
    2b62:	76 2e       	mov	r7, r22
    2b64:	87 2e       	mov	r8, r23
    2b66:	7a 01       	movw	r14, r20
    2b68:	b2 2e       	mov	r11, r18
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:762
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    2b6a:	ca 01       	movw	r24, r20
    2b6c:	0e 94 84 15 	call	0x2b08	; 0x2b08 <pvPortMalloc>
    2b70:	6c 01       	movw	r12, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:764

                if( pxStack != NULL )
    2b72:	89 2b       	or	r24, r25
    2b74:	09 f4       	brne	.+2      	; 0x2b78 <xTaskCreate.constprop.25+0x34>
    2b76:	f2 c0       	rjmp	.+484    	; 0x2d5c <xTaskCreate.constprop.25+0x218>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:767
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    2b78:	88 e2       	ldi	r24, 0x28	; 40
    2b7a:	90 e0       	ldi	r25, 0x00	; 0
    2b7c:	0e 94 84 15 	call	0x2b08	; 0x2b08 <pvPortMalloc>
    2b80:	ec 01       	movw	r28, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:769

                    if( pxNewTCB != NULL )
    2b82:	89 2b       	or	r24, r25
    2b84:	09 f4       	brne	.+2      	; 0x2b88 <xTaskCreate.constprop.25+0x44>
    2b86:	e7 c0       	rjmp	.+462    	; 0x2d56 <xTaskCreate.constprop.25+0x212>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:772
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
    2b88:	d8 8e       	std	Y+24, r13	; 0x18
    2b8a:	cf 8a       	std	Y+23, r12	; 0x17
prvInitialiseNewTask.isra.2():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:844

    /* Avoid dependency on memset() if it is not required. */
    #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
        {
            /* Fill the stack with a known value to assist debugging. */
            ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    2b8c:	a7 01       	movw	r20, r14
    2b8e:	65 ea       	ldi	r22, 0xA5	; 165
    2b90:	70 e0       	ldi	r23, 0x00	; 0
    2b92:	c6 01       	movw	r24, r12
    2b94:	0e 94 ac 19 	call	0x3358	; 0x3358 <memset>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:854
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( configSTACK_DEPTH_TYPE ) 1 ] );
    2b98:	81 e0       	ldi	r24, 0x01	; 1
    2b9a:	e8 1a       	sub	r14, r24
    2b9c:	f1 08       	sbc	r15, r1
    2b9e:	ef 89       	ldd	r30, Y+23	; 0x17
    2ba0:	f8 8d       	ldd	r31, Y+24	; 0x18
    2ba2:	ee 0d       	add	r30, r14
    2ba4:	ff 1d       	adc	r31, r15
    2ba6:	67 2d       	mov	r22, r7
    2ba8:	78 2d       	mov	r23, r8
    2baa:	ce 01       	movw	r24, r28
    2bac:	49 96       	adiw	r24, 0x19	; 25
    2bae:	9b 01       	movw	r18, r22
    2bb0:	28 5f       	subi	r18, 0xF8	; 248
    2bb2:	3f 4f       	sbci	r19, 0xFF	; 255
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:886
    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    2bb4:	db 01       	movw	r26, r22
    2bb6:	4d 91       	ld	r20, X+
    2bb8:	bd 01       	movw	r22, r26
    2bba:	dc 01       	movw	r26, r24
    2bbc:	4d 93       	st	X+, r20
    2bbe:	cd 01       	movw	r24, r26
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:891

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    2bc0:	ab 01       	movw	r20, r22
    2bc2:	41 50       	subi	r20, 0x01	; 1
    2bc4:	51 09       	sbc	r21, r1
    2bc6:	da 01       	movw	r26, r20
    2bc8:	4c 91       	ld	r20, X
    2bca:	44 23       	and	r20, r20
    2bcc:	19 f0       	breq	.+6      	; 0x2bd4 <xTaskCreate.constprop.25+0x90>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:884
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2bce:	62 17       	cp	r22, r18
    2bd0:	73 07       	cpc	r23, r19
    2bd2:	81 f7       	brne	.-32     	; 0x2bb4 <xTaskCreate.constprop.25+0x70>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:903
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    2bd4:	18 a2       	std	Y+32, r1	; 0x20
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:923
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    2bd6:	be 8a       	std	Y+22, r11	; 0x16
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:926
    #if ( configUSE_MUTEXES == 1 )
        {
            pxNewTCB->uxBasePriority = uxPriority;
    2bd8:	b9 a2       	std	Y+33, r11	; 0x21
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:927
            pxNewTCB->uxMutexesHeld = 0;
    2bda:	1a a2       	std	Y+34, r1	; 0x22
vListInitialiseItem():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/list.c:76
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    2bdc:	1b 86       	std	Y+11, r1	; 0x0b
    2bde:	1a 86       	std	Y+10, r1	; 0x0a
    2be0:	1d 8a       	std	Y+21, r1	; 0x15
    2be2:	1c 8a       	std	Y+20, r1	; 0x14
prvInitialiseNewTask.isra.2():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:936
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    2be4:	d9 87       	std	Y+9, r29	; 0x09
    2be6:	c8 87       	std	Y+8, r28	; 0x08
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:939

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2be8:	84 e0       	ldi	r24, 0x04	; 4
    2bea:	90 e0       	ldi	r25, 0x00	; 0
    2bec:	8b 19       	sub	r24, r11
    2bee:	91 09       	sbc	r25, r1
    2bf0:	9d 87       	std	Y+13, r25	; 0x0d
    2bf2:	8c 87       	std	Y+12, r24	; 0x0c
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:940
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    2bf4:	db 8b       	std	Y+19, r29	; 0x13
    2bf6:	ca 8b       	std	Y+18, r28	; 0x12
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:979
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
    2bf8:	84 e0       	ldi	r24, 0x04	; 4
    2bfa:	9e 01       	movw	r18, r28
    2bfc:	2d 5d       	subi	r18, 0xDD	; 221
    2bfe:	3f 4f       	sbci	r19, 0xFF	; 255
    2c00:	d9 01       	movw	r26, r18
    2c02:	1d 92       	st	X+, r1
    2c04:	8a 95       	dec	r24
    2c06:	e9 f7       	brne	.-6      	; 0x2c02 <xTaskCreate.constprop.25+0xbe>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:980
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
    2c08:	1f a2       	std	Y+39, r1	; 0x27
pxPortInitialiseStack():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/port.c:524
    the compiler. */

    /* The start of the task code will be popped off the stack last, so place
    it on first. */
    usAddress = ( uint16_t ) pxCode;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2c0a:	90 82       	st	Z, r9
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/port.c:528
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2c0c:	df 01       	movw	r26, r30
    2c0e:	11 97       	sbiw	r26, 0x01	; 1
    2c10:	ac 92       	st	X, r10
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/port.c:550

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
    portSAVE_CONTEXT places the flags on the stack immediately after r0
    to ensure the interrupts get disabled as soon as possible, and so ensuring
    the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( StackType_t ) 0x00;    /* R0 */
    2c12:	11 97       	sbiw	r26, 0x01	; 1
    2c14:	1c 92       	st	X, r1
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/port.c:552
    pxTopOfStack--;
    *pxTopOfStack = portFLAGS_INT_ENABLED;
    2c16:	11 97       	sbiw	r26, 0x01	; 1
    2c18:	80 e8       	ldi	r24, 0x80	; 128
    2c1a:	8c 93       	st	X, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/port.c:572
    *pxTopOfStack = ( StackType_t ) 0x00;    /* RAMPZ */
    pxTopOfStack--;
#endif

    /* Now the remaining registers. The compiler expects R1 to be 0. */
    *pxTopOfStack = ( StackType_t ) 0x00;    /* R1 */
    2c1c:	11 97       	sbiw	r26, 0x01	; 1
    2c1e:	1c 92       	st	X, r1
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/port.c:579
    /* Leave R2 - R23 untouched */
    pxTopOfStack -= 23;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2c20:	57 97       	sbiw	r26, 0x17	; 23
    2c22:	1c 92       	st	X, r1
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/port.c:583
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2c24:	11 97       	sbiw	r26, 0x01	; 1
    2c26:	1c 92       	st	X, r1
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/port.c:586

    /* Leave register R26 - R31 untouched */
    pxTopOfStack -= 7;
    2c28:	b3 97       	sbiw	r30, 0x23	; 35
prvInitialiseNewTask.isra.2():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:1045
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2c2a:	f9 83       	std	Y+1, r31	; 0x01
    2c2c:	e8 83       	st	Y, r30
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:1051
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    2c2e:	01 15       	cp	r16, r1
    2c30:	11 05       	cpc	r17, r1
    2c32:	19 f0       	breq	.+6      	; 0x2c3a <xTaskCreate.constprop.25+0xf6>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:1055
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    2c34:	f8 01       	movw	r30, r16
    2c36:	d1 83       	std	Z+1, r29	; 0x01
    2c38:	c0 83       	st	Z, r28
prvAddNewTaskToReadyList():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:1068

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    2c3a:	0f b6       	in	r0, 0x3f	; 63
    2c3c:	f8 94       	cli
    2c3e:	0f 92       	push	r0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:1070
    {
        uxCurrentNumberOfTasks++;
    2c40:	80 91 35 02 	lds	r24, 0x0235	; 0x800235 <uxCurrentNumberOfTasks>
    2c44:	8f 5f       	subi	r24, 0xFF	; 255
    2c46:	80 93 35 02 	sts	0x0235, r24	; 0x800235 <uxCurrentNumberOfTasks>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:1072

        if( pxCurrentTCB == NULL )
    2c4a:	80 91 9e 01 	lds	r24, 0x019E	; 0x80019e <__data_end>
    2c4e:	90 91 9f 01 	lds	r25, 0x019F	; 0x80019f <__data_end+0x1>
    2c52:	89 2b       	or	r24, r25
    2c54:	09 f0       	breq	.+2      	; 0x2c58 <xTaskCreate.constprop.25+0x114>
    2c56:	91 c0       	rjmp	.+290    	; 0x2d7a <xTaskCreate.constprop.25+0x236>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:1076
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    2c58:	d0 93 9f 01 	sts	0x019F, r29	; 0x80019f <__data_end+0x1>
    2c5c:	c0 93 9e 01 	sts	0x019E, r28	; 0x80019e <__data_end>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:1078

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    2c60:	80 91 35 02 	lds	r24, 0x0235	; 0x800235 <uxCurrentNumberOfTasks>
    2c64:	81 30       	cpi	r24, 0x01	; 1
    2c66:	81 f5       	brne	.+96     	; 0x2cc8 <xTaskCreate.constprop.25+0x184>
prvInitialiseTaskLists():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3652
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    2c68:	8e e0       	ldi	r24, 0x0E	; 14
    2c6a:	92 e0       	ldi	r25, 0x02	; 2
    2c6c:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <vListInitialise>
    2c70:	87 e1       	ldi	r24, 0x17	; 23
    2c72:	92 e0       	ldi	r25, 0x02	; 2
    2c74:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <vListInitialise>
    2c78:	80 e2       	ldi	r24, 0x20	; 32
    2c7a:	92 e0       	ldi	r25, 0x02	; 2
    2c7c:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <vListInitialise>
    2c80:	89 e2       	ldi	r24, 0x29	; 41
    2c82:	92 e0       	ldi	r25, 0x02	; 2
    2c84:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <vListInitialise>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3655
    }

    vListInitialise( &xDelayedTaskList1 );
    2c88:	85 e0       	ldi	r24, 0x05	; 5
    2c8a:	92 e0       	ldi	r25, 0x02	; 2
    2c8c:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <vListInitialise>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3656
    vListInitialise( &xDelayedTaskList2 );
    2c90:	8c ef       	ldi	r24, 0xFC	; 252
    2c92:	91 e0       	ldi	r25, 0x01	; 1
    2c94:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <vListInitialise>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3657
    vListInitialise( &xPendingReadyList );
    2c98:	83 ef       	ldi	r24, 0xF3	; 243
    2c9a:	91 e0       	ldi	r25, 0x01	; 1
    2c9c:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <vListInitialise>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3661

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
    2ca0:	8a ee       	ldi	r24, 0xEA	; 234
    2ca2:	91 e0       	ldi	r25, 0x01	; 1
    2ca4:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <vListInitialise>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3667
        }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            vListInitialise( &xSuspendedTaskList );
    2ca8:	81 ee       	ldi	r24, 0xE1	; 225
    2caa:	91 e0       	ldi	r25, 0x01	; 1
    2cac:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <vListInitialise>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3673
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    2cb0:	85 e0       	ldi	r24, 0x05	; 5
    2cb2:	92 e0       	ldi	r25, 0x02	; 2
    2cb4:	90 93 e0 01 	sts	0x01E0, r25	; 0x8001e0 <pxDelayedTaskList+0x1>
    2cb8:	80 93 df 01 	sts	0x01DF, r24	; 0x8001df <pxDelayedTaskList>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:3674
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2cbc:	8c ef       	ldi	r24, 0xFC	; 252
    2cbe:	91 e0       	ldi	r25, 0x01	; 1
    2cc0:	90 93 de 01 	sts	0x01DE, r25	; 0x8001de <pxOverflowDelayedTaskList+0x1>
    2cc4:	80 93 dd 01 	sts	0x01DD, r24	; 0x8001dd <pxOverflowDelayedTaskList>
prvAddNewTaskToReadyList():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:1112
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    2cc8:	80 91 33 02 	lds	r24, 0x0233	; 0x800233 <uxTaskNumber>
    2ccc:	8f 5f       	subi	r24, 0xFF	; 255
    2cce:	80 93 33 02 	sts	0x0233, r24	; 0x800233 <uxTaskNumber>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:1122
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    2cd2:	ae 89       	ldd	r26, Y+22	; 0x16
    2cd4:	80 91 32 02 	lds	r24, 0x0232	; 0x800232 <uxTopReadyPriority>
    2cd8:	8a 17       	cp	r24, r26
    2cda:	10 f4       	brcc	.+4      	; 0x2ce0 <xTaskCreate.constprop.25+0x19c>
    2cdc:	a0 93 32 02 	sts	0x0232, r26	; 0x800232 <uxTopReadyPriority>
    2ce0:	29 e0       	ldi	r18, 0x09	; 9
    2ce2:	2a 9f       	mul	r18, r26
    2ce4:	d0 01       	movw	r26, r0
    2ce6:	11 24       	eor	r1, r1
    2ce8:	a2 5f       	subi	r26, 0xF2	; 242
    2cea:	bd 4f       	sbci	r27, 0xFD	; 253
    2cec:	11 96       	adiw	r26, 0x01	; 1
    2cee:	0d 90       	ld	r0, X+
    2cf0:	bc 91       	ld	r27, X
    2cf2:	a0 2d       	mov	r26, r0
    2cf4:	bd 83       	std	Y+5, r27	; 0x05
    2cf6:	ac 83       	std	Y+4, r26	; 0x04
    2cf8:	14 96       	adiw	r26, 0x04	; 4
    2cfa:	8d 91       	ld	r24, X+
    2cfc:	9c 91       	ld	r25, X
    2cfe:	15 97       	sbiw	r26, 0x05	; 5
    2d00:	9f 83       	std	Y+7, r25	; 0x07
    2d02:	8e 83       	std	Y+6, r24	; 0x06
    2d04:	14 96       	adiw	r26, 0x04	; 4
    2d06:	ed 91       	ld	r30, X+
    2d08:	fc 91       	ld	r31, X
    2d0a:	15 97       	sbiw	r26, 0x05	; 5
    2d0c:	ce 01       	movw	r24, r28
    2d0e:	02 96       	adiw	r24, 0x02	; 2
    2d10:	93 83       	std	Z+3, r25	; 0x03
    2d12:	82 83       	std	Z+2, r24	; 0x02
    2d14:	15 96       	adiw	r26, 0x05	; 5
    2d16:	9c 93       	st	X, r25
    2d18:	8e 93       	st	-X, r24
    2d1a:	14 97       	sbiw	r26, 0x04	; 4
    2d1c:	ee 89       	ldd	r30, Y+22	; 0x16
    2d1e:	e2 9f       	mul	r30, r18
    2d20:	f0 01       	movw	r30, r0
    2d22:	11 24       	eor	r1, r1
    2d24:	e2 5f       	subi	r30, 0xF2	; 242
    2d26:	fd 4f       	sbci	r31, 0xFD	; 253
    2d28:	fb 87       	std	Y+11, r31	; 0x0b
    2d2a:	ea 87       	std	Y+10, r30	; 0x0a
    2d2c:	80 81       	ld	r24, Z
    2d2e:	8f 5f       	subi	r24, 0xFF	; 255
    2d30:	80 83       	st	Z, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:1126

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    2d32:	0f 90       	pop	r0
    2d34:	0f be       	out	0x3f, r0	; 63
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:1128

    if( xSchedulerRunning != pdFALSE )
    2d36:	80 91 34 02 	lds	r24, 0x0234	; 0x800234 <xSchedulerRunning>
    2d3a:	88 23       	and	r24, r24
    2d3c:	51 f0       	breq	.+20     	; 0x2d52 <xTaskCreate.constprop.25+0x20e>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:1132
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    2d3e:	e0 91 9e 01 	lds	r30, 0x019E	; 0x80019e <__data_end>
    2d42:	f0 91 9f 01 	lds	r31, 0x019F	; 0x80019f <__data_end+0x1>
    2d46:	96 89       	ldd	r25, Z+22	; 0x16
    2d48:	8e 89       	ldd	r24, Y+22	; 0x16
    2d4a:	98 17       	cp	r25, r24
    2d4c:	10 f4       	brcc	.+4      	; 0x2d52 <xTaskCreate.constprop.25+0x20e>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:1134
        {
            taskYIELD_IF_USING_PREEMPTION();
    2d4e:	0e 94 7e 0c 	call	0x18fc	; 0x18fc <vPortYield>
xTaskCreate.constprop.25():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:800
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( configSTACK_DEPTH_TYPE ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
            prvAddNewTaskToReadyList( pxNewTCB );
            xReturn = pdPASS;
    2d52:	81 e0       	ldi	r24, 0x01	; 1
    2d54:	04 c0       	rjmp	.+8      	; 0x2d5e <xTaskCreate.constprop.25+0x21a>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:778
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFree( pxStack );
    2d56:	c6 01       	movw	r24, r12
    2d58:	0e 94 5c 13 	call	0x26b8	; 0x26b8 <vPortFree>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:804
            prvAddNewTaskToReadyList( pxNewTCB );
            xReturn = pdPASS;
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2d5c:	8f ef       	ldi	r24, 0xFF	; 255
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:808
        }

        return xReturn;
    }
    2d5e:	df 91       	pop	r29
    2d60:	cf 91       	pop	r28
    2d62:	1f 91       	pop	r17
    2d64:	0f 91       	pop	r16
    2d66:	ff 90       	pop	r15
    2d68:	ef 90       	pop	r14
    2d6a:	df 90       	pop	r13
    2d6c:	cf 90       	pop	r12
    2d6e:	bf 90       	pop	r11
    2d70:	af 90       	pop	r10
    2d72:	9f 90       	pop	r9
    2d74:	8f 90       	pop	r8
    2d76:	7f 90       	pop	r7
    2d78:	08 95       	ret
prvAddNewTaskToReadyList():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:1095
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    2d7a:	80 91 34 02 	lds	r24, 0x0234	; 0x800234 <xSchedulerRunning>
    2d7e:	81 11       	cpse	r24, r1
    2d80:	a3 cf       	rjmp	.-186    	; 0x2cc8 <xTaskCreate.constprop.25+0x184>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:1097
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    2d82:	e0 91 9e 01 	lds	r30, 0x019E	; 0x80019e <__data_end>
    2d86:	f0 91 9f 01 	lds	r31, 0x019F	; 0x80019f <__data_end+0x1>
    2d8a:	96 89       	ldd	r25, Z+22	; 0x16
    2d8c:	8e 89       	ldd	r24, Y+22	; 0x16
    2d8e:	89 17       	cp	r24, r25
    2d90:	08 f4       	brcc	.+2      	; 0x2d94 <xTaskCreate.constprop.25+0x250>
    2d92:	9a cf       	rjmp	.-204    	; 0x2cc8 <xTaskCreate.constprop.25+0x184>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:1099
                {
                    pxCurrentTCB = pxNewTCB;
    2d94:	d0 93 9f 01 	sts	0x019F, r29	; 0x80019f <__data_end+0x1>
    2d98:	c0 93 9e 01 	sts	0x019E, r28	; 0x80019e <__data_end>
    2d9c:	95 cf       	rjmp	.-214    	; 0x2cc8 <xTaskCreate.constprop.25+0x184>

00002d9e <__vector_6>:
__vector_6():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/port.c:697
    ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
/*  ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
 */
    ISR(portSCHEDULER_ISR)
    {
        vPortYieldFromTick();
    2d9e:	0e 94 93 11 	call	0x2326	; 0x2326 <vPortYieldFromTick>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/port.c:698
        __asm__ __volatile__ ( "reti" );
    2da2:	18 95       	reti

00002da4 <global constructors keyed to 65535_0_event_group_3_tasks.cpp.o.2591>:
_GLOBAL__I_65535_0_event_group_3_tasks.cpp.o.2591():
    2da4:	e6 e3       	ldi	r30, 0x36	; 54
    2da6:	f2 e0       	ldi	r31, 0x02	; 2
    2da8:	13 82       	std	Z+3, r1	; 0x03
    2daa:	12 82       	std	Z+2, r1	; 0x02
    2dac:	88 ee       	ldi	r24, 0xE8	; 232
    2dae:	93 e0       	ldi	r25, 0x03	; 3
    2db0:	a0 e0       	ldi	r26, 0x00	; 0
    2db2:	b0 e0       	ldi	r27, 0x00	; 0
    2db4:	84 83       	std	Z+4, r24	; 0x04
    2db6:	95 83       	std	Z+5, r25	; 0x05
    2db8:	a6 83       	std	Z+6, r26	; 0x06
    2dba:	b7 83       	std	Z+7, r27	; 0x07
    2dbc:	8b e0       	ldi	r24, 0x0B	; 11
    2dbe:	91 e0       	ldi	r25, 0x01	; 1
    2dc0:	91 83       	std	Z+1, r25	; 0x01
    2dc2:	80 83       	st	Z, r24
    2dc4:	85 ec       	ldi	r24, 0xC5	; 197
    2dc6:	90 e0       	ldi	r25, 0x00	; 0
    2dc8:	95 87       	std	Z+13, r25	; 0x0d
    2dca:	84 87       	std	Z+12, r24	; 0x0c
    2dcc:	84 ec       	ldi	r24, 0xC4	; 196
    2dce:	90 e0       	ldi	r25, 0x00	; 0
    2dd0:	97 87       	std	Z+15, r25	; 0x0f
    2dd2:	86 87       	std	Z+14, r24	; 0x0e
    2dd4:	80 ec       	ldi	r24, 0xC0	; 192
    2dd6:	90 e0       	ldi	r25, 0x00	; 0
    2dd8:	91 8b       	std	Z+17, r25	; 0x11
    2dda:	80 8b       	std	Z+16, r24	; 0x10
    2ddc:	81 ec       	ldi	r24, 0xC1	; 193
    2dde:	90 e0       	ldi	r25, 0x00	; 0
    2de0:	93 8b       	std	Z+19, r25	; 0x13
    2de2:	82 8b       	std	Z+18, r24	; 0x12
    2de4:	82 ec       	ldi	r24, 0xC2	; 194
    2de6:	90 e0       	ldi	r25, 0x00	; 0
    2de8:	95 8b       	std	Z+21, r25	; 0x15
    2dea:	84 8b       	std	Z+20, r24	; 0x14
    2dec:	86 ec       	ldi	r24, 0xC6	; 198
    2dee:	90 e0       	ldi	r25, 0x00	; 0
    2df0:	97 8b       	std	Z+23, r25	; 0x17
    2df2:	86 8b       	std	Z+22, r24	; 0x16
    2df4:	11 8e       	std	Z+25, r1	; 0x19
    2df6:	12 8e       	std	Z+26, r1	; 0x1a
    2df8:	13 8e       	std	Z+27, r1	; 0x1b
    2dfa:	14 8e       	std	Z+28, r1	; 0x1c
    2dfc:	e3 ed       	ldi	r30, 0xD3	; 211
    2dfe:	f2 e0       	ldi	r31, 0x02	; 2
    2e00:	16 82       	std	Z+6, r1	; 0x06
    2e02:	17 82       	std	Z+7, r1	; 0x07
    2e04:	10 86       	std	Z+8, r1	; 0x08
    2e06:	11 86       	std	Z+9, r1	; 0x09
    2e08:	12 86       	std	Z+10, r1	; 0x0a
    2e0a:	13 86       	std	Z+11, r1	; 0x0b
    2e0c:	14 86       	std	Z+12, r1	; 0x0c
    2e0e:	15 86       	std	Z+13, r1	; 0x0d
    2e10:	16 86       	std	Z+14, r1	; 0x0e
    2e12:	17 86       	std	Z+15, r1	; 0x0f
    2e14:	10 8a       	std	Z+16, r1	; 0x10
    2e16:	11 8a       	std	Z+17, r1	; 0x11
    2e18:	12 8a       	std	Z+18, r1	; 0x12
    2e1a:	13 8a       	std	Z+19, r1	; 0x13
    2e1c:	14 8a       	std	Z+20, r1	; 0x14
    2e1e:	15 8a       	std	Z+21, r1	; 0x15
    2e20:	08 95       	ret

00002e22 <main>:
main():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:245

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    2e22:	78 94       	sei
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:251
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    2e24:	84 b5       	in	r24, 0x24	; 36
    2e26:	82 60       	ori	r24, 0x02	; 2
    2e28:	84 bd       	out	0x24, r24	; 36
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:252
	sbi(TCCR0A, WGM00);
    2e2a:	84 b5       	in	r24, 0x24	; 36
    2e2c:	81 60       	ori	r24, 0x01	; 1
    2e2e:	84 bd       	out	0x24, r24	; 36
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:265
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    2e30:	85 b5       	in	r24, 0x25	; 37
    2e32:	82 60       	ori	r24, 0x02	; 2
    2e34:	85 bd       	out	0x25, r24	; 37
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:266
	sbi(TCCR0B, CS00);
    2e36:	85 b5       	in	r24, 0x25	; 37
    2e38:	81 60       	ori	r24, 0x01	; 1
    2e3a:	85 bd       	out	0x25, r24	; 37
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:279

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    2e3c:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <__DATA_REGION_ORIGIN__+0xe>
    2e40:	81 60       	ori	r24, 0x01	; 1
    2e42:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__DATA_REGION_ORIGIN__+0xe>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:290
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    2e46:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:293

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    2e4a:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
    2e4e:	82 60       	ori	r24, 0x02	; 2
    2e50:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:295
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    2e54:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
    2e58:	81 60       	ori	r24, 0x01	; 1
    2e5a:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:305
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    2e5e:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    2e62:	81 60       	ori	r24, 0x01	; 1
    2e64:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:312

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    2e68:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
    2e6c:	84 60       	ori	r24, 0x04	; 4
    2e6e:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:321

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    2e72:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    2e76:	81 60       	ori	r24, 0x01	; 1
    2e78:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:356
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
    2e7c:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    2e80:	84 60       	ori	r24, 0x04	; 4
    2e82:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:357
		sbi(ADCSRA, ADPS1);
    2e86:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    2e8a:	82 60       	ori	r24, 0x02	; 2
    2e8c:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:358
		sbi(ADCSRA, ADPS0);
    2e90:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    2e94:	81 60       	ori	r24, 0x01	; 1
    2e96:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:381
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    2e9a:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    2e9e:	80 68       	ori	r24, 0x80	; 128
    2ea0:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/wiring.c:390
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    2ea4:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
initVariant():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/variantHooks.cpp:50
void initVariant(void) __attribute__ ((OS_main));
void initVariant(void)
{
    // As the Task stacks are on heap before Task allocated heap variables,
    // the library default __malloc_heap_end = 0 doesn't work.
    __malloc_heap_end = (char *)(RAMEND - __malloc_margin);
    2ea8:	20 91 05 01 	lds	r18, 0x0105	; 0x800105 <__malloc_margin>
    2eac:	30 91 06 01 	lds	r19, 0x0106	; 0x800106 <__malloc_margin+0x1>
    2eb0:	8f ef       	ldi	r24, 0xFF	; 255
    2eb2:	98 e0       	ldi	r25, 0x08	; 8
    2eb4:	82 1b       	sub	r24, r18
    2eb6:	93 0b       	sbc	r25, r19
    2eb8:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__malloc_heap_end+0x1>
    2ebc:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <__malloc_heap_end>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/variantHooks.cpp:56

#if defined(USBCON)
    USBDevice.attach();
#endif

    setup();                    // the normal Arduino setup() function is run here.
    2ec0:	0e 94 a8 08 	call	0x1150	; 0x1150 <setup>
vTaskStartScheduler():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2017
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
    2ec4:	05 ed       	ldi	r16, 0xD5	; 213
    2ec6:	11 e0       	ldi	r17, 0x01	; 1
    2ec8:	20 e0       	ldi	r18, 0x00	; 0
    2eca:	40 ec       	ldi	r20, 0xC0	; 192
    2ecc:	50 e0       	ldi	r21, 0x00	; 0
    2ece:	61 e9       	ldi	r22, 0x91	; 145
    2ed0:	71 e0       	ldi	r23, 0x01	; 1
    2ed2:	8f e4       	ldi	r24, 0x4F	; 79
    2ed4:	95 e1       	ldi	r25, 0x15	; 21
    2ed6:	0e 94 a2 15 	call	0x2b44	; 0x2b44 <xTaskCreate.constprop.25>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2028
        }
    #endif /* configSUPPORT_STATIC_ALLOCATION */

    #if ( configUSE_TIMERS == 1 )
        {
            if( xReturn == pdPASS )
    2eda:	81 30       	cpi	r24, 0x01	; 1
    2edc:	09 f0       	breq	.+2      	; 0x2ee0 <main+0xbe>
    2ede:	b3 c0       	rjmp	.+358    	; 0x3046 <main+0x224>
prvCheckForValidListAndQueue():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:954
    static void prvCheckForValidListAndQueue( void )
    {
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
    2ee0:	0f b6       	in	r0, 0x3f	; 63
    2ee2:	f8 94       	cli
    2ee4:	0f 92       	push	r0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:956
        {
            if( xTimerQueue == NULL )
    2ee6:	80 91 d8 01 	lds	r24, 0x01D8	; 0x8001d8 <xTimerQueue>
    2eea:	90 91 d9 01 	lds	r25, 0x01D9	; 0x8001d9 <xTimerQueue+0x1>
    2eee:	89 2b       	or	r24, r25
    2ef0:	09 f0       	breq	.+2      	; 0x2ef4 <main+0xd2>
    2ef2:	4f c0       	rjmp	.+158    	; 0x2f92 <main+0x170>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:958
            {
                vListInitialise( &xActiveTimerList1 );
    2ef4:	88 ec       	ldi	r24, 0xC8	; 200
    2ef6:	91 e0       	ldi	r25, 0x01	; 1
    2ef8:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <vListInitialise>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:959
                vListInitialise( &xActiveTimerList2 );
    2efc:	8f eb       	ldi	r24, 0xBF	; 191
    2efe:	91 e0       	ldi	r25, 0x01	; 1
    2f00:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <vListInitialise>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:960
                pxCurrentTimerList = &xActiveTimerList1;
    2f04:	88 ec       	ldi	r24, 0xC8	; 200
    2f06:	91 e0       	ldi	r25, 0x01	; 1
    2f08:	90 93 be 01 	sts	0x01BE, r25	; 0x8001be <pxCurrentTimerList+0x1>
    2f0c:	80 93 bd 01 	sts	0x01BD, r24	; 0x8001bd <pxCurrentTimerList>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:961
                pxOverflowTimerList = &xActiveTimerList2;
    2f10:	8f eb       	ldi	r24, 0xBF	; 191
    2f12:	91 e0       	ldi	r25, 0x01	; 1
    2f14:	90 93 bc 01 	sts	0x01BC, r25	; 0x8001bc <pxOverflowTimerList+0x1>
    2f18:	80 93 bb 01 	sts	0x01BB, r24	; 0x8001bb <pxOverflowTimerList>
xQueueGenericCreate():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:408
         * alignment requirements of the Queue_t structure - which in this case
         * is an int8_t *.  Therefore, whenever the stack alignment requirements
         * are greater than or equal to the pointer to char requirements the cast
         * is safe.  In other cases alignment requirements are not strict (one or
         * two bytes). */
        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    2f1c:	81 e5       	ldi	r24, 0x51	; 81
    2f1e:	90 e0       	ldi	r25, 0x00	; 0
    2f20:	0e 94 84 15 	call	0x2b08	; 0x2b08 <pvPortMalloc>
    2f24:	ec 01       	movw	r28, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:410

        if( pxNewQueue != NULL )
    2f26:	00 97       	sbiw	r24, 0x00	; 0
    2f28:	81 f1       	breq	.+96     	; 0x2f8a <main+0x168>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:415
        {
            /* Jump past the queue structure to find the location of the queue
             * storage area. */
            pucQueueStorage = ( uint8_t * ) pxNewQueue;
            pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2f2a:	4f 96       	adiw	r24, 0x1f	; 31
prvInitialiseNewQueue.isra.0():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:461
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    2f2c:	99 83       	std	Y+1, r25	; 0x01
    2f2e:	88 83       	st	Y, r24
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:466
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    2f30:	8a e0       	ldi	r24, 0x0A	; 10
    2f32:	8b 8f       	std	Y+27, r24	; 0x1b
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:467
    pxNewQueue->uxItemSize = uxItemSize;
    2f34:	85 e0       	ldi	r24, 0x05	; 5
    2f36:	8c 8f       	std	Y+28, r24	; 0x1c
xQueueGenericReset():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:267
{
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    2f38:	0f b6       	in	r0, 0x3f	; 63
    2f3a:	f8 94       	cli
    2f3c:	0f 92       	push	r0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:269
    {
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2f3e:	88 81       	ld	r24, Y
    2f40:	99 81       	ldd	r25, Y+1	; 0x01
    2f42:	2b 8d       	ldd	r18, Y+27	; 0x1b
    2f44:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2f46:	bc 01       	movw	r22, r24
    2f48:	24 9f       	mul	r18, r20
    2f4a:	60 0d       	add	r22, r0
    2f4c:	71 1d       	adc	r23, r1
    2f4e:	11 24       	eor	r1, r1
    2f50:	7d 83       	std	Y+5, r23	; 0x05
    2f52:	6c 83       	std	Y+4, r22	; 0x04
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:270
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2f54:	1a 8e       	std	Y+26, r1	; 0x1a
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:271
        pxQueue->pcWriteTo = pxQueue->pcHead;
    2f56:	9b 83       	std	Y+3, r25	; 0x03
    2f58:	8a 83       	std	Y+2, r24	; 0x02
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:272
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2f5a:	21 50       	subi	r18, 0x01	; 1
    2f5c:	33 0b       	sbc	r19, r19
    2f5e:	42 9f       	mul	r20, r18
    2f60:	b0 01       	movw	r22, r0
    2f62:	43 9f       	mul	r20, r19
    2f64:	70 0d       	add	r23, r0
    2f66:	11 24       	eor	r1, r1
    2f68:	86 0f       	add	r24, r22
    2f6a:	97 1f       	adc	r25, r23
    2f6c:	9f 83       	std	Y+7, r25	; 0x07
    2f6e:	8e 83       	std	Y+6, r24	; 0x06
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:273
        pxQueue->cRxLock = queueUNLOCKED;
    2f70:	8f ef       	ldi	r24, 0xFF	; 255
    2f72:	8d 8f       	std	Y+29, r24	; 0x1d
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:274
        pxQueue->cTxLock = queueUNLOCKED;
    2f74:	8e 8f       	std	Y+30, r24	; 0x1e
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:302
            }
        }
        else
        {
            /* Ensure the event queues start in the correct state. */
            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    2f76:	ce 01       	movw	r24, r28
    2f78:	08 96       	adiw	r24, 0x08	; 8
    2f7a:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <vListInitialise>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:303
            vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    2f7e:	ce 01       	movw	r24, r28
    2f80:	41 96       	adiw	r24, 0x11	; 17
    2f82:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <vListInitialise>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/queue.c:306
        }
    }
    taskEXIT_CRITICAL();
    2f86:	0f 90       	pop	r0
    2f88:	0f be       	out	0x3f, r0	; 63
prvCheckForValidListAndQueue():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:974

                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
                    }
                #else
                    {
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    2f8a:	d0 93 d9 01 	sts	0x01D9, r29	; 0x8001d9 <xTimerQueue+0x1>
    2f8e:	c0 93 d8 01 	sts	0x01D8, r28	; 0x8001d8 <xTimerQueue>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:996
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    2f92:	0f 90       	pop	r0
    2f94:	0f be       	out	0x3f, r0	; 63
xTimerCreateTimerTask():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:227
         * configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
         * timer service task has been created/initialised.  If timers have already
         * been created then the initialisation will already have been performed. */
        prvCheckForValidListAndQueue();

        if( xTimerQueue != NULL )
    2f96:	80 91 d8 01 	lds	r24, 0x01D8	; 0x8001d8 <xTimerQueue>
    2f9a:	90 91 d9 01 	lds	r25, 0x01D9	; 0x8001d9 <xTimerQueue+0x1>
    2f9e:	89 2b       	or	r24, r25
    2fa0:	09 f4       	brne	.+2      	; 0x2fa4 <main+0x182>
    2fa2:	51 c0       	rjmp	.+162    	; 0x3046 <main+0x224>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/timers.c:251
                        xReturn = pdPASS;
                    }
                }
            #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
                {
                    xReturn = xTaskCreate( prvTimerTask,
    2fa4:	01 ed       	ldi	r16, 0xD1	; 209
    2fa6:	11 e0       	ldi	r17, 0x01	; 1
    2fa8:	23 e0       	ldi	r18, 0x03	; 3
    2faa:	45 e5       	ldi	r20, 0x55	; 85
    2fac:	50 e0       	ldi	r21, 0x00	; 0
    2fae:	66 e9       	ldi	r22, 0x96	; 150
    2fb0:	71 e0       	ldi	r23, 0x01	; 1
    2fb2:	8d e6       	ldi	r24, 0x6D	; 109
    2fb4:	93 e1       	ldi	r25, 0x13	; 19
    2fb6:	0e 94 a2 15 	call	0x2b44	; 0x2b44 <xTaskCreate.constprop.25>
vTaskStartScheduler():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2039
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    2fba:	81 30       	cpi	r24, 0x01	; 1
    2fbc:	09 f0       	breq	.+2      	; 0x2fc0 <main+0x19e>
    2fbe:	43 c0       	rjmp	.+134    	; 0x3046 <main+0x224>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2055
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    2fc0:	f8 94       	cli
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2067
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
    2fc2:	2f ef       	ldi	r18, 0xFF	; 255
    2fc4:	3f ef       	ldi	r19, 0xFF	; 255
    2fc6:	30 93 d4 01 	sts	0x01D4, r19	; 0x8001d4 <xNextTaskUnblockTime+0x1>
    2fca:	20 93 d3 01 	sts	0x01D3, r18	; 0x8001d3 <xNextTaskUnblockTime>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2068
        xSchedulerRunning = pdTRUE;
    2fce:	80 93 34 02 	sts	0x0234, r24	; 0x800234 <xSchedulerRunning>
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2069
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    2fd2:	10 92 db 01 	sts	0x01DB, r1	; 0x8001db <xTickCount+0x1>
    2fd6:	10 92 da 01 	sts	0x01DA, r1	; 0x8001da <xTickCount>
prvSetupTimerInterrupt():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/port.c:675
 * Setup WDT to generate a tick interrupt.
 */
void prvSetupTimerInterrupt( void )
{
    /* reset watchdog */
    wdt_reset();
    2fda:	a8 95       	wdr
wdt_interrupt_enable():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/port.c:97
                : "r0"
        );
    }
    else
    {
        __asm__ __volatile__ (
    2fdc:	88 e1       	ldi	r24, 0x18	; 24
    2fde:	90 ec       	ldi	r25, 0xC0	; 192
    2fe0:	0f b6       	in	r0, 0x3f	; 63
    2fe2:	f8 94       	cli
    2fe4:	a8 95       	wdr
    2fe6:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    2fea:	0f be       	out	0x3f, r0	; 63
    2fec:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__DATA_REGION_ORIGIN__>
xPortStartScheduler():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/port.c:598
{
    /* Setup the relevant timer hardware to generate the tick. */
    prvSetupTimerInterrupt();

    /* Restore the context of the first task that is going to run. */
    portRESTORE_CONTEXT();
    2ff0:	a0 91 9e 01 	lds	r26, 0x019E	; 0x80019e <__data_end>
    2ff4:	b0 91 9f 01 	lds	r27, 0x019F	; 0x80019f <__data_end+0x1>
    2ff8:	cd 91       	ld	r28, X+
    2ffa:	cd bf       	out	0x3d, r28	; 61
    2ffc:	dd 91       	ld	r29, X+
    2ffe:	de bf       	out	0x3e, r29	; 62
    3000:	ff 91       	pop	r31
    3002:	ef 91       	pop	r30
    3004:	df 91       	pop	r29
    3006:	cf 91       	pop	r28
    3008:	bf 91       	pop	r27
    300a:	af 91       	pop	r26
    300c:	9f 91       	pop	r25
    300e:	8f 91       	pop	r24
    3010:	7f 91       	pop	r23
    3012:	6f 91       	pop	r22
    3014:	5f 91       	pop	r21
    3016:	4f 91       	pop	r20
    3018:	3f 91       	pop	r19
    301a:	2f 91       	pop	r18
    301c:	1f 91       	pop	r17
    301e:	0f 91       	pop	r16
    3020:	ff 90       	pop	r15
    3022:	ef 90       	pop	r14
    3024:	df 90       	pop	r13
    3026:	cf 90       	pop	r12
    3028:	bf 90       	pop	r11
    302a:	af 90       	pop	r10
    302c:	9f 90       	pop	r9
    302e:	8f 90       	pop	r8
    3030:	7f 90       	pop	r7
    3032:	6f 90       	pop	r6
    3034:	5f 90       	pop	r5
    3036:	4f 90       	pop	r4
    3038:	3f 90       	pop	r3
    303a:	2f 90       	pop	r2
    303c:	1f 90       	pop	r1
    303e:	0f 90       	pop	r0
    3040:	0f be       	out	0x3f, r0	; 63
    3042:	0f 90       	pop	r0
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/port.c:602

    /* Simulate a function call end as generated by the compiler. We will now
    jump to the start of the task the context of which we have just restored. */
    __asm__ __volatile__ ( "ret" );
    3044:	08 95       	ret
vTaskStartScheduler():
C:\Users\IMRUL\OneDrive\Documents\Arduino\libraries\FreeRTOS\src/tasks.c:2107
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    3046:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
main():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/main.cpp:43

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
    304a:	0e 94 a8 08 	call	0x1150	; 0x1150 <setup>
serialEventRun():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:67
    304e:	c0 e0       	ldi	r28, 0x00	; 0
    3050:	d0 e0       	ldi	r29, 0x00	; 0
main():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/main.cpp:46
    
	for (;;) {
		loop();
    3052:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <loop>
serialEventRun():
C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino/HardwareSerial.cpp:67
    3056:	20 97       	sbiw	r28, 0x00	; 0
    3058:	e1 f3       	breq	.-8      	; 0x3052 <main+0x230>
    305a:	0e 94 47 01 	call	0x28e	; 0x28e <serialEventRun() [clone .part.1]>
    305e:	f9 cf       	rjmp	.-14     	; 0x3052 <main+0x230>

00003060 <malloc>:
malloc():
    3060:	0f 93       	push	r16
    3062:	1f 93       	push	r17
    3064:	cf 93       	push	r28
    3066:	df 93       	push	r29
    3068:	82 30       	cpi	r24, 0x02	; 2
    306a:	91 05       	cpc	r25, r1
    306c:	10 f4       	brcc	.+4      	; 0x3072 <malloc+0x12>
    306e:	82 e0       	ldi	r24, 0x02	; 2
    3070:	90 e0       	ldi	r25, 0x00	; 0
    3072:	e0 91 1b 03 	lds	r30, 0x031B	; 0x80031b <__flp>
    3076:	f0 91 1c 03 	lds	r31, 0x031C	; 0x80031c <__flp+0x1>
    307a:	30 e0       	ldi	r19, 0x00	; 0
    307c:	20 e0       	ldi	r18, 0x00	; 0
    307e:	b0 e0       	ldi	r27, 0x00	; 0
    3080:	a0 e0       	ldi	r26, 0x00	; 0
    3082:	30 97       	sbiw	r30, 0x00	; 0
    3084:	99 f4       	brne	.+38     	; 0x30ac <malloc+0x4c>
    3086:	21 15       	cp	r18, r1
    3088:	31 05       	cpc	r19, r1
    308a:	09 f4       	brne	.+2      	; 0x308e <malloc+0x2e>
    308c:	4a c0       	rjmp	.+148    	; 0x3122 <malloc+0xc2>
    308e:	28 1b       	sub	r18, r24
    3090:	39 0b       	sbc	r19, r25
    3092:	24 30       	cpi	r18, 0x04	; 4
    3094:	31 05       	cpc	r19, r1
    3096:	d8 f5       	brcc	.+118    	; 0x310e <malloc+0xae>
    3098:	8a 81       	ldd	r24, Y+2	; 0x02
    309a:	9b 81       	ldd	r25, Y+3	; 0x03
    309c:	61 15       	cp	r22, r1
    309e:	71 05       	cpc	r23, r1
    30a0:	89 f1       	breq	.+98     	; 0x3104 <malloc+0xa4>
    30a2:	fb 01       	movw	r30, r22
    30a4:	93 83       	std	Z+3, r25	; 0x03
    30a6:	82 83       	std	Z+2, r24	; 0x02
    30a8:	fe 01       	movw	r30, r28
    30aa:	11 c0       	rjmp	.+34     	; 0x30ce <malloc+0x6e>
    30ac:	40 81       	ld	r20, Z
    30ae:	51 81       	ldd	r21, Z+1	; 0x01
    30b0:	02 81       	ldd	r16, Z+2	; 0x02
    30b2:	13 81       	ldd	r17, Z+3	; 0x03
    30b4:	48 17       	cp	r20, r24
    30b6:	59 07       	cpc	r21, r25
    30b8:	e0 f0       	brcs	.+56     	; 0x30f2 <malloc+0x92>
    30ba:	48 17       	cp	r20, r24
    30bc:	59 07       	cpc	r21, r25
    30be:	99 f4       	brne	.+38     	; 0x30e6 <malloc+0x86>
    30c0:	10 97       	sbiw	r26, 0x00	; 0
    30c2:	61 f0       	breq	.+24     	; 0x30dc <malloc+0x7c>
    30c4:	12 96       	adiw	r26, 0x02	; 2
    30c6:	0c 93       	st	X, r16
    30c8:	12 97       	sbiw	r26, 0x02	; 2
    30ca:	13 96       	adiw	r26, 0x03	; 3
    30cc:	1c 93       	st	X, r17
    30ce:	32 96       	adiw	r30, 0x02	; 2
    30d0:	cf 01       	movw	r24, r30
    30d2:	df 91       	pop	r29
    30d4:	cf 91       	pop	r28
    30d6:	1f 91       	pop	r17
    30d8:	0f 91       	pop	r16
    30da:	08 95       	ret
    30dc:	00 93 1b 03 	sts	0x031B, r16	; 0x80031b <__flp>
    30e0:	10 93 1c 03 	sts	0x031C, r17	; 0x80031c <__flp+0x1>
    30e4:	f4 cf       	rjmp	.-24     	; 0x30ce <malloc+0x6e>
    30e6:	21 15       	cp	r18, r1
    30e8:	31 05       	cpc	r19, r1
    30ea:	51 f0       	breq	.+20     	; 0x3100 <malloc+0xa0>
    30ec:	42 17       	cp	r20, r18
    30ee:	53 07       	cpc	r21, r19
    30f0:	38 f0       	brcs	.+14     	; 0x3100 <malloc+0xa0>
    30f2:	a9 01       	movw	r20, r18
    30f4:	db 01       	movw	r26, r22
    30f6:	9a 01       	movw	r18, r20
    30f8:	bd 01       	movw	r22, r26
    30fa:	df 01       	movw	r26, r30
    30fc:	f8 01       	movw	r30, r16
    30fe:	c1 cf       	rjmp	.-126    	; 0x3082 <malloc+0x22>
    3100:	ef 01       	movw	r28, r30
    3102:	f9 cf       	rjmp	.-14     	; 0x30f6 <malloc+0x96>
    3104:	90 93 1c 03 	sts	0x031C, r25	; 0x80031c <__flp+0x1>
    3108:	80 93 1b 03 	sts	0x031B, r24	; 0x80031b <__flp>
    310c:	cd cf       	rjmp	.-102    	; 0x30a8 <malloc+0x48>
    310e:	fe 01       	movw	r30, r28
    3110:	e2 0f       	add	r30, r18
    3112:	f3 1f       	adc	r31, r19
    3114:	81 93       	st	Z+, r24
    3116:	91 93       	st	Z+, r25
    3118:	22 50       	subi	r18, 0x02	; 2
    311a:	31 09       	sbc	r19, r1
    311c:	39 83       	std	Y+1, r19	; 0x01
    311e:	28 83       	st	Y, r18
    3120:	d7 cf       	rjmp	.-82     	; 0x30d0 <malloc+0x70>
    3122:	20 91 19 03 	lds	r18, 0x0319	; 0x800319 <__brkval>
    3126:	30 91 1a 03 	lds	r19, 0x031A	; 0x80031a <__brkval+0x1>
    312a:	23 2b       	or	r18, r19
    312c:	41 f4       	brne	.+16     	; 0x313e <malloc+0xde>
    312e:	20 91 03 01 	lds	r18, 0x0103	; 0x800103 <__malloc_heap_start>
    3132:	30 91 04 01 	lds	r19, 0x0104	; 0x800104 <__malloc_heap_start+0x1>
    3136:	30 93 1a 03 	sts	0x031A, r19	; 0x80031a <__brkval+0x1>
    313a:	20 93 19 03 	sts	0x0319, r18	; 0x800319 <__brkval>
    313e:	20 91 01 01 	lds	r18, 0x0101	; 0x800101 <__malloc_heap_end>
    3142:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__malloc_heap_end+0x1>
    3146:	21 15       	cp	r18, r1
    3148:	31 05       	cpc	r19, r1
    314a:	41 f4       	brne	.+16     	; 0x315c <malloc+0xfc>
    314c:	2d b7       	in	r18, 0x3d	; 61
    314e:	3e b7       	in	r19, 0x3e	; 62
    3150:	40 91 05 01 	lds	r20, 0x0105	; 0x800105 <__malloc_margin>
    3154:	50 91 06 01 	lds	r21, 0x0106	; 0x800106 <__malloc_margin+0x1>
    3158:	24 1b       	sub	r18, r20
    315a:	35 0b       	sbc	r19, r21
    315c:	e0 91 19 03 	lds	r30, 0x0319	; 0x800319 <__brkval>
    3160:	f0 91 1a 03 	lds	r31, 0x031A	; 0x80031a <__brkval+0x1>
    3164:	e2 17       	cp	r30, r18
    3166:	f3 07       	cpc	r31, r19
    3168:	a0 f4       	brcc	.+40     	; 0x3192 <malloc+0x132>
    316a:	2e 1b       	sub	r18, r30
    316c:	3f 0b       	sbc	r19, r31
    316e:	28 17       	cp	r18, r24
    3170:	39 07       	cpc	r19, r25
    3172:	78 f0       	brcs	.+30     	; 0x3192 <malloc+0x132>
    3174:	ac 01       	movw	r20, r24
    3176:	4e 5f       	subi	r20, 0xFE	; 254
    3178:	5f 4f       	sbci	r21, 0xFF	; 255
    317a:	24 17       	cp	r18, r20
    317c:	35 07       	cpc	r19, r21
    317e:	48 f0       	brcs	.+18     	; 0x3192 <malloc+0x132>
    3180:	4e 0f       	add	r20, r30
    3182:	5f 1f       	adc	r21, r31
    3184:	50 93 1a 03 	sts	0x031A, r21	; 0x80031a <__brkval+0x1>
    3188:	40 93 19 03 	sts	0x0319, r20	; 0x800319 <__brkval>
    318c:	81 93       	st	Z+, r24
    318e:	91 93       	st	Z+, r25
    3190:	9f cf       	rjmp	.-194    	; 0x30d0 <malloc+0x70>
    3192:	f0 e0       	ldi	r31, 0x00	; 0
    3194:	e0 e0       	ldi	r30, 0x00	; 0
    3196:	9c cf       	rjmp	.-200    	; 0x30d0 <malloc+0x70>

00003198 <free>:
free():
    3198:	cf 93       	push	r28
    319a:	df 93       	push	r29
    319c:	00 97       	sbiw	r24, 0x00	; 0
    319e:	e9 f0       	breq	.+58     	; 0x31da <free+0x42>
    31a0:	fc 01       	movw	r30, r24
    31a2:	32 97       	sbiw	r30, 0x02	; 2
    31a4:	13 82       	std	Z+3, r1	; 0x03
    31a6:	12 82       	std	Z+2, r1	; 0x02
    31a8:	a0 91 1b 03 	lds	r26, 0x031B	; 0x80031b <__flp>
    31ac:	b0 91 1c 03 	lds	r27, 0x031C	; 0x80031c <__flp+0x1>
    31b0:	ed 01       	movw	r28, r26
    31b2:	30 e0       	ldi	r19, 0x00	; 0
    31b4:	20 e0       	ldi	r18, 0x00	; 0
    31b6:	10 97       	sbiw	r26, 0x00	; 0
    31b8:	a1 f4       	brne	.+40     	; 0x31e2 <free+0x4a>
    31ba:	20 81       	ld	r18, Z
    31bc:	31 81       	ldd	r19, Z+1	; 0x01
    31be:	82 0f       	add	r24, r18
    31c0:	93 1f       	adc	r25, r19
    31c2:	20 91 19 03 	lds	r18, 0x0319	; 0x800319 <__brkval>
    31c6:	30 91 1a 03 	lds	r19, 0x031A	; 0x80031a <__brkval+0x1>
    31ca:	28 17       	cp	r18, r24
    31cc:	39 07       	cpc	r19, r25
    31ce:	09 f0       	breq	.+2      	; 0x31d2 <free+0x3a>
    31d0:	61 c0       	rjmp	.+194    	; 0x3294 <free+0xfc>
    31d2:	f0 93 1a 03 	sts	0x031A, r31	; 0x80031a <__brkval+0x1>
    31d6:	e0 93 19 03 	sts	0x0319, r30	; 0x800319 <__brkval>
    31da:	df 91       	pop	r29
    31dc:	cf 91       	pop	r28
    31de:	08 95       	ret
    31e0:	ea 01       	movw	r28, r20
    31e2:	ce 17       	cp	r28, r30
    31e4:	df 07       	cpc	r29, r31
    31e6:	e8 f5       	brcc	.+122    	; 0x3262 <free+0xca>
    31e8:	4a 81       	ldd	r20, Y+2	; 0x02
    31ea:	5b 81       	ldd	r21, Y+3	; 0x03
    31ec:	9e 01       	movw	r18, r28
    31ee:	41 15       	cp	r20, r1
    31f0:	51 05       	cpc	r21, r1
    31f2:	b1 f7       	brne	.-20     	; 0x31e0 <free+0x48>
    31f4:	e9 01       	movw	r28, r18
    31f6:	fb 83       	std	Y+3, r31	; 0x03
    31f8:	ea 83       	std	Y+2, r30	; 0x02
    31fa:	49 91       	ld	r20, Y+
    31fc:	59 91       	ld	r21, Y+
    31fe:	c4 0f       	add	r28, r20
    3200:	d5 1f       	adc	r29, r21
    3202:	ec 17       	cp	r30, r28
    3204:	fd 07       	cpc	r31, r29
    3206:	61 f4       	brne	.+24     	; 0x3220 <free+0x88>
    3208:	80 81       	ld	r24, Z
    320a:	91 81       	ldd	r25, Z+1	; 0x01
    320c:	02 96       	adiw	r24, 0x02	; 2
    320e:	84 0f       	add	r24, r20
    3210:	95 1f       	adc	r25, r21
    3212:	e9 01       	movw	r28, r18
    3214:	99 83       	std	Y+1, r25	; 0x01
    3216:	88 83       	st	Y, r24
    3218:	82 81       	ldd	r24, Z+2	; 0x02
    321a:	93 81       	ldd	r25, Z+3	; 0x03
    321c:	9b 83       	std	Y+3, r25	; 0x03
    321e:	8a 83       	std	Y+2, r24	; 0x02
    3220:	f0 e0       	ldi	r31, 0x00	; 0
    3222:	e0 e0       	ldi	r30, 0x00	; 0
    3224:	12 96       	adiw	r26, 0x02	; 2
    3226:	8d 91       	ld	r24, X+
    3228:	9c 91       	ld	r25, X
    322a:	13 97       	sbiw	r26, 0x03	; 3
    322c:	00 97       	sbiw	r24, 0x00	; 0
    322e:	b9 f5       	brne	.+110    	; 0x329e <free+0x106>
    3230:	2d 91       	ld	r18, X+
    3232:	3c 91       	ld	r19, X
    3234:	11 97       	sbiw	r26, 0x01	; 1
    3236:	cd 01       	movw	r24, r26
    3238:	02 96       	adiw	r24, 0x02	; 2
    323a:	82 0f       	add	r24, r18
    323c:	93 1f       	adc	r25, r19
    323e:	20 91 19 03 	lds	r18, 0x0319	; 0x800319 <__brkval>
    3242:	30 91 1a 03 	lds	r19, 0x031A	; 0x80031a <__brkval+0x1>
    3246:	28 17       	cp	r18, r24
    3248:	39 07       	cpc	r19, r25
    324a:	39 f6       	brne	.-114    	; 0x31da <free+0x42>
    324c:	30 97       	sbiw	r30, 0x00	; 0
    324e:	51 f5       	brne	.+84     	; 0x32a4 <free+0x10c>
    3250:	10 92 1c 03 	sts	0x031C, r1	; 0x80031c <__flp+0x1>
    3254:	10 92 1b 03 	sts	0x031B, r1	; 0x80031b <__flp>
    3258:	b0 93 1a 03 	sts	0x031A, r27	; 0x80031a <__brkval+0x1>
    325c:	a0 93 19 03 	sts	0x0319, r26	; 0x800319 <__brkval>
    3260:	bc cf       	rjmp	.-136    	; 0x31da <free+0x42>
    3262:	d3 83       	std	Z+3, r29	; 0x03
    3264:	c2 83       	std	Z+2, r28	; 0x02
    3266:	40 81       	ld	r20, Z
    3268:	51 81       	ldd	r21, Z+1	; 0x01
    326a:	84 0f       	add	r24, r20
    326c:	95 1f       	adc	r25, r21
    326e:	c8 17       	cp	r28, r24
    3270:	d9 07       	cpc	r29, r25
    3272:	61 f4       	brne	.+24     	; 0x328c <free+0xf4>
    3274:	4e 5f       	subi	r20, 0xFE	; 254
    3276:	5f 4f       	sbci	r21, 0xFF	; 255
    3278:	88 81       	ld	r24, Y
    327a:	99 81       	ldd	r25, Y+1	; 0x01
    327c:	48 0f       	add	r20, r24
    327e:	59 1f       	adc	r21, r25
    3280:	51 83       	std	Z+1, r21	; 0x01
    3282:	40 83       	st	Z, r20
    3284:	8a 81       	ldd	r24, Y+2	; 0x02
    3286:	9b 81       	ldd	r25, Y+3	; 0x03
    3288:	93 83       	std	Z+3, r25	; 0x03
    328a:	82 83       	std	Z+2, r24	; 0x02
    328c:	21 15       	cp	r18, r1
    328e:	31 05       	cpc	r19, r1
    3290:	09 f0       	breq	.+2      	; 0x3294 <free+0xfc>
    3292:	b0 cf       	rjmp	.-160    	; 0x31f4 <free+0x5c>
    3294:	f0 93 1c 03 	sts	0x031C, r31	; 0x80031c <__flp+0x1>
    3298:	e0 93 1b 03 	sts	0x031B, r30	; 0x80031b <__flp>
    329c:	9e cf       	rjmp	.-196    	; 0x31da <free+0x42>
    329e:	fd 01       	movw	r30, r26
    32a0:	dc 01       	movw	r26, r24
    32a2:	c0 cf       	rjmp	.-128    	; 0x3224 <free+0x8c>
    32a4:	13 82       	std	Z+3, r1	; 0x03
    32a6:	12 82       	std	Z+2, r1	; 0x02
    32a8:	d7 cf       	rjmp	.-82     	; 0x3258 <free+0xc0>

000032aa <atoi>:
atoi():
    32aa:	fc 01       	movw	r30, r24
    32ac:	88 27       	eor	r24, r24
    32ae:	99 27       	eor	r25, r25
    32b0:	e8 94       	clt
    32b2:	21 91       	ld	r18, Z+
    32b4:	20 32       	cpi	r18, 0x20	; 32
    32b6:	e9 f3       	breq	.-6      	; 0x32b2 <atoi+0x8>
    32b8:	29 30       	cpi	r18, 0x09	; 9
    32ba:	10 f0       	brcs	.+4      	; 0x32c0 <atoi+0x16>
    32bc:	2e 30       	cpi	r18, 0x0E	; 14
    32be:	c8 f3       	brcs	.-14     	; 0x32b2 <atoi+0x8>
    32c0:	2b 32       	cpi	r18, 0x2B	; 43
    32c2:	41 f0       	breq	.+16     	; 0x32d4 <atoi+0x2a>
    32c4:	2d 32       	cpi	r18, 0x2D	; 45
    32c6:	39 f4       	brne	.+14     	; 0x32d6 <atoi+0x2c>
    32c8:	68 94       	set
    32ca:	04 c0       	rjmp	.+8      	; 0x32d4 <atoi+0x2a>
    32cc:	0e 94 73 19 	call	0x32e6	; 0x32e6 <__mulhi_const_10>
    32d0:	82 0f       	add	r24, r18
    32d2:	91 1d       	adc	r25, r1
    32d4:	21 91       	ld	r18, Z+
    32d6:	20 53       	subi	r18, 0x30	; 48
    32d8:	2a 30       	cpi	r18, 0x0A	; 10
    32da:	c0 f3       	brcs	.-16     	; 0x32cc <atoi+0x22>
    32dc:	1e f4       	brtc	.+6      	; 0x32e4 <atoi+0x3a>
    32de:	90 95       	com	r25
    32e0:	81 95       	neg	r24
    32e2:	9f 4f       	sbci	r25, 0xFF	; 255
    32e4:	08 95       	ret

000032e6 <__mulhi_const_10>:
__mulhi_const_10():
    32e6:	7a e0       	ldi	r23, 0x0A	; 10
    32e8:	97 9f       	mul	r25, r23
    32ea:	90 2d       	mov	r25, r0
    32ec:	87 9f       	mul	r24, r23
    32ee:	80 2d       	mov	r24, r0
    32f0:	91 0d       	add	r25, r1
    32f2:	11 24       	eor	r1, r1
    32f4:	08 95       	ret

000032f6 <__udivmodsi4>:
__udivmodsi4():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1638
    32f6:	a1 e2       	ldi	r26, 0x21	; 33
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1639
    32f8:	1a 2e       	mov	r1, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1640
    32fa:	aa 1b       	sub	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1641
    32fc:	bb 1b       	sub	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1642
    32fe:	fd 01       	movw	r30, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1644
    3300:	0d c0       	rjmp	.+26     	; 0x331c <__udivmodsi4_ep>

00003302 <__udivmodsi4_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1646
    3302:	aa 1f       	adc	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1647
    3304:	bb 1f       	adc	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1648
    3306:	ee 1f       	adc	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1649
    3308:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1650
    330a:	a2 17       	cp	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1651
    330c:	b3 07       	cpc	r27, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1652
    330e:	e4 07       	cpc	r30, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1653
    3310:	f5 07       	cpc	r31, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1654
    3312:	20 f0       	brcs	.+8      	; 0x331c <__udivmodsi4_ep>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1655
    3314:	a2 1b       	sub	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1656
    3316:	b3 0b       	sbc	r27, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1657
    3318:	e4 0b       	sbc	r30, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1658
    331a:	f5 0b       	sbc	r31, r21

0000331c <__udivmodsi4_ep>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1660
    331c:	66 1f       	adc	r22, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1661
    331e:	77 1f       	adc	r23, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1662
    3320:	88 1f       	adc	r24, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1663
    3322:	99 1f       	adc	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1664
    3324:	1a 94       	dec	r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1665
    3326:	69 f7       	brne	.-38     	; 0x3302 <__udivmodsi4_loop>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1667
    3328:	60 95       	com	r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1668
    332a:	70 95       	com	r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1669
    332c:	80 95       	com	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1670
    332e:	90 95       	com	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1672
    3330:	9b 01       	movw	r18, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1674
    3332:	ac 01       	movw	r20, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1676
    3334:	bd 01       	movw	r22, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1678
    3336:	cf 01       	movw	r24, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1680
    3338:	08 95       	ret

0000333a <__tablejump2__>:
__tablejump2__():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
    333a:	ee 0f       	add	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
    333c:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
    333e:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
    3340:	f4 91       	lpm	r31, Z
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
    3342:	e0 2d       	mov	r30, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
    3344:	09 94       	ijmp

00003346 <memcpy>:
memcpy():
    3346:	fb 01       	movw	r30, r22
    3348:	dc 01       	movw	r26, r24
    334a:	02 c0       	rjmp	.+4      	; 0x3350 <memcpy+0xa>
    334c:	01 90       	ld	r0, Z+
    334e:	0d 92       	st	X+, r0
    3350:	41 50       	subi	r20, 0x01	; 1
    3352:	50 40       	sbci	r21, 0x00	; 0
    3354:	d8 f7       	brcc	.-10     	; 0x334c <memcpy+0x6>
    3356:	08 95       	ret

00003358 <memset>:
memset():
    3358:	dc 01       	movw	r26, r24
    335a:	01 c0       	rjmp	.+2      	; 0x335e <memset+0x6>
    335c:	6d 93       	st	X+, r22
    335e:	41 50       	subi	r20, 0x01	; 1
    3360:	50 40       	sbci	r21, 0x00	; 0
    3362:	e0 f7       	brcc	.-8      	; 0x335c <memset+0x4>
    3364:	08 95       	ret

00003366 <_exit>:
exit():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
    3366:	f8 94       	cli

00003368 <__stop_program>:
__stop_program():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
    3368:	ff cf       	rjmp	.-2      	; 0x3368 <__stop_program>
